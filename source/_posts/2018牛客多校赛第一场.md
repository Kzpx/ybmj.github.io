---
title: 2018牛客多校赛第一场
comments: true
date: 2018-07-19 20:34:33
categories:
- ACM
- 训练报告
- 2018
---



## J

### 题意
长度为n的序列,Q个询问(l,r),每次询问$[1,l]\cup [r,n]$ 中有多少不同的数字

$1 \leq n,Q,a_i \leq 1e5$

### 分析
#### 做法一

#### 做法二
将区间再复制一份放到尾部,这样就变成了查询$[r,n+l]$中有多少个不同的数字

然后主席树,第i个版本维护前i个数中,每个数最后一次出现的位置.(比如某个数最后一次出现的位置是k,那么k位置的value++,这个数上一次最后出现的位置要value--)


这样我再查询区间$[l,r]$有多少不同的数时,只要查询第r个版本时$[l,r]$的和,就是答案.

但是...无情的T了...多交几次也不管用了...可能是写的丑把
#### 做法三
1e5的话就莫队瞎搞搞... 如果超时的话多交几次也许就过了

### 代码

#### 做法一

#### 做法三
```cpp
//ybmj
// 如果T了就多交几次
#include<bits/stdc++.h>
using namespace std;
#define lson (rt << 1)
#define rson (rt << 1 | 1)
#define lson_len (len - (len >> 1))
#define rson_len (len >> 1)
#define pb(x) push_back(x)
#define clr(a, x) memset(a, x, sizeof(a))
#define mp(x, y) make_pair(x, y)
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<double,double> pdd;
const int INF = 0x3f3f3f3f;
const int NINF = 0xc0c0c0c0;
const int maxn = 1e5+5;
int S;
int a[maxn],cnt[maxn];
struct P{
    int l,r,id,ans;
    bool operator < (const P&A) const{
        if(l / S == A.l / S) return r > A.r;
        return l / S < A.l / S;
    }
};
P b[maxn];
 
int main(){
    // /*
    #ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    #endif
    // */
    std::ios::sync_with_stdio(false);
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        S = sqrt(n);        //  如果T了就改几次
        clr(cnt,0);
        for(int i=0;i<n;i++) {
            scanf("%d",a+i);
        }
        for(int i=0;i<m;i++) scanf("%d%d",&b[i].l,&b[i].r), b[i].id = i;
        sort(b,b+m);
        int ans = 0;
        int l = -1 ,r = n;
        for(int i=0;i<m;i++){
            int L = b[i].l - 1;
            int R = b[i].r - 1;
            while(l < L){
                l++;
                ans += cnt[a[l]] == 0;
                cnt[a[l]]++;
            }
            while(l > L){
                cnt[a[l]]--;
                ans -= cnt[a[l]] == 0;
                l--;
            }
            while(r < R){
                cnt[a[r]]--;
                ans -= cnt[a[r]] == 0;
                r++;
            }
            while(r > R){
                r--;
                ans += cnt[a[r]] == 0;
                cnt[a[r]]++;
            }
            b[i].ans = ans;
        }
        sort(b,b+m,[](const P&A, const P&B){return A.id < B.id;});
        for(int i=0;i<m;i++) printf("%d\n",b[i].ans);
    }
}
```