<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[增量最小生成树]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%A2%9E%E9%87%8F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义每次加入一个新边后，最小生成树的权值是多少？ 解法维护当前的MST的边集，对于新加的一条边，重新计算MST，然后将多余的那条边删掉。 这样每次计算MST的复杂度就是$O(nlogn)$ （手动排序的话就是$O(n)$，因为只有新加的那条边是无序的） 假如一共要加$m$条边，那么时间复杂度为$O(mnlogn)$ 例题题意就是上述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// LightOJ 1123// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 205;int par[maxn];vector&lt;int&gt; G[maxn];struct Edge &#123; int u, v, w; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;Edge&gt; edges;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;inline bool merge(int x, int y) &#123; x = find(x); y = find(y); if (x == y) return false; par[x] = y; return true;&#125;int kruskal(vector&lt;Edge&gt; &amp;tmp, int n) &#123; int ret = 0; for (int i = 0; i &lt;= n; i++) par[i] = i; sort(tmp.begin(), tmp.end()); int pos = -1; for (int i = 0; i &lt; tmp.size(); i++) &#123; Edge &amp;e = tmp[i]; if (merge(e.u, e.v)) ret += e.w; else pos = i; &#125; if (pos != -1) tmp.erase(tmp.begin() + pos); if (tmp.size() == n - 1) return ret; else return -1;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 0; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); edges.clear(); printf("Case %d:\n", ++kase); for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edges.push_back(&#123;u, v, w&#125;); printf("%d\n", kruskal(edges, n)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GYM101667E]]></title>
    <url>%2F2018%2F10%2F18%2FGYM101667E%2F</url>
    <content type="text"><![CDATA[题目一张无向图$G$，定义$H(e)$为如果$e$这条边属于$G$的最小生成树，那么最少要在原图上删除边的数量。 求$G$中所有边的$H(e)$和 $1 \leq n \leq 100, 1 \leq m \leq 500$ 分析如何计算$H(e)$呢？ 考虑将所有权值小于$e$的重新构图。 对于$e$的两个端点跑一个最小割，割边的数量就是$H(e)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 105;struct Edge &#123; int from, to, cap, flow;&#125;;struct EdmonsKarp &#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int a[maxn], p[maxn]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.push_back(&#123;from, to, cap, 0&#125;); edges.push_back(&#123;to, from, cap, 0&#125;); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int MaxFlow(int s, int t) &#123; int flow = 0; for (;;) &#123; memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (auto &amp;id : G[x]) &#123; Edge &amp;e = edges[id]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; p[e.to] = id; a[e.to] = min(a[x], e.cap - e.flow); Q.push(e.to); &#125; &#125; if (a[t]) break; &#125; if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) &#123; edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;;EdmonsKarp wss;struct _Edge &#123; int u, v, w; bool operator&lt;(const _Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;_Edge&gt; edges;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edges.push_back(&#123;u, v, w&#125;); &#125; sort(edges.begin(), edges.end()); int ans = 0; for (auto &amp;e : edges) &#123; wss.init(n); for (auto &amp;tmp : edges) &#123; if (tmp.w &gt;= e.w) break; wss.AddEdge(tmp.u, tmp.v, 1); &#125; ans += wss.MaxFlow(e.u, e.v); &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj3925]]></title>
    <url>%2F2018%2F10%2F17%2Fbzoj3925%2F</url>
    <content type="text"><![CDATA[题意给定一个n点m边的无向图，没有重边和自环，每条边的权值为[0,1]之间的随机变量。设S是使n个点连通的一个边集，求S中最大边的期望权值。 $n \leq 10, m \leq \frac{n(n-1)}{2}$ 分析结论：对于$n$个$[0,1]$之间的随机变量$x_1,x_2,…,x_n$，第$k$小的那个的期望值是$\frac{k}{(n+1)}$。 证明稍后给出。 大致思路： 我们需要算的其实是：恰好选择k条边 使得图连通 恰好： 选k-1条边时不连通，选了第k条才连通。 那如何算呢？ 设$con[S][i]$表示在集合$S$中选$i$条边，使得$S$连通的方案数。（不一定是恰好选$i$边连通） $disc[S][i]$表示在集合$S$中选$i$条边，使得$S$不连通的方案数。 $edges[S]$表示集合$S$中的边数。 那么有关系：$con[S][i] + disc[S][i] = C(edges[S], i)$ 重点来了： 如何计算恰好选$i$条边时连通呢？ $$ans[S][i] = con[S][i] - con[S][i-1]$$ 那么$ans[S][i]$ 就是在集合$S$中选$i$条边，使得$S$恰好连通的方案数. 那么最终的答案就是 $$\sum \frac{ans[S][i]}{C(edges[S], i)} \times \frac{i}{m+1} $$ 如何计算$con[S][i]$ ? $con[S][i] = C(edges[S], i) - disc[S][i]$ 如何计算$disc[S][i]$ ? 我们可以在集合$S$中找一个标志点$p$，那么$S$就可以分为两部分：一部分是包含$p$的集合$A$，另一部分是不包含$p$的集合$B$。 我们设包含$p$的集合是连通的，而另一个结合是无所谓的。 那么$$disc[S][j + k] = \sum con[A][j] \times C(edges[B], k)$$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 1 &lt;&lt; 11;const int maxm = 46;ll con[maxn][maxm], disc[maxn][maxm], edges[maxn], C[maxm][maxm];int G[15][15];void init() &#123; C[0][0] = 1; for (int i = 1; i &lt; maxm; i++) &#123; C[i][0] = C[i][i] = 1; for (int j = 1; j &lt; i; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("2.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); init(); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); --u, --v; G[u][v] = G[v][u] = 1; &#125; int S = 1 &lt;&lt; n; for (int i = 0; i &lt; S; i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j)) for (int k = j + 1; k &lt; n; k++) if (i &amp; (1 &lt;&lt; k)) edges[i] += G[j][k]; for (int i = 1, s; i &lt; S; i++) &#123; if (__builtin_popcount(i) == 1) &#123; // 集合里只有一个点 con[i][0] = 1; continue; &#125; s = i &amp; (-i); for (int sub = i &amp; (i - 1); sub; sub = (sub - 1) &amp; i) if (sub &amp; s) for (int j = 0; j &lt;= edges[sub]; j++) for (int k = 0; k &lt;= edges[i ^ sub]; k++) disc[i][j + k] += con[sub][j] * C[edges[i ^ sub]][k]; for (int j = 0; j &lt;= edges[i]; j++) con[i][j] = C[edges[i]][j] - disc[i][j]; &#125; double ans = 0; for (int i = 1; i &lt;= m; i++) ans += 1.0 * con[S - 1][i] / C[edges[S - 1]][i]; ans /= (m + 1); ans = 1.0 * con[S - 1][m] / C[edges[S - 1]][m] - ans; printf("%.6lf\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>子集dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[子集dp]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%AD%90%E9%9B%86dp%2F</url>
    <content type="text"><![CDATA[子集枚举对全集$S$的每个子集$K$,进行子集的枚举 复杂度:$O(3^n)$ 1234567for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; for (int j = i; j; j = (j - 1) &amp; i) &#123; /* j为i的子集 */ &#125;&#125; 证明： 设全集有$n$个元素。 对于一个含有$k$个元素的集合来说，它的方案有$C^k_n$。每个集合的子集有$2^k$ 所以对所有含有$k$个元素的集合，它的总子集数为$C^k_n \times 2^k$ 那么对全集的每个子集进行子集枚举的复杂度为$\sum_{k=1}^{n} C^k_n \times 2^k$ 由二项式定理$(x+y)^n = \sum_{k=0}^{n} x ^ k y ^ {n-k}$ 所以子集枚举的复杂度为$(2+1)^n = 3^n$ 复杂度:$O(n2^n)$123456789for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; if (j &amp; (1 &lt;&lt; i)) &#123; /* j ^ (1 &lt;&lt; i) 为 j 的子集 */ &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>子集dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj2560]]></title>
    <url>%2F2018%2F10%2F16%2Fbzoj2560%2F</url>
    <content type="text"><![CDATA[题意n个不同的点，标号(1~n)，$c[i][j]$:表示$i$与$j$两点之间的不同的边数。 现在问有多少种连边方案可以使得n个点连通？ 答案模$1e^9+7$ 两点之间最多连一条边。 $n \leq 20$ 分析即求无向连通图的个数 大致思路： 设$S$表示一些点的集合，$all[S]$表示当前集合内所有连边的可能性。$dp[S]$表示当前集合内的所有点是一个联通块的连边方案数。 那么用$all[S]$减去$S$中不连通的情况就是$dp[S]$。 那么怎么求$S$中不连通的情况数呢？ 为了防止重复，我们规定$S$中的某个点为标志点，那么剩下的点可以分为两部分：一部分和标志点连通记为$A$，另一部分和标志点不连通记为$B$。 那么$dp[S] = all[S] - dp[A] * all[B]$ 即与标志位连通的集合的方案数和与标志不连通的集合的所有可能情况。 复杂度:$O(3^n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 1 &lt;&lt; 21;const int mod = 1e9 + 7;ll a[20][20], all[maxn], dp[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;a[i][j]); for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; all[i] = 1; for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j)) for (int k = j + 1; k &lt; n; k++) if (i &amp; (1 &lt;&lt; k)) all[i] = all[i] * (a[j][k] + 1) % mod; int s; // 标志点 for (int j = n - 1; j &gt;= 0; j--) if (i &amp; (1 &lt;&lt; j)) &#123; s = j; break; &#125; dp[i] = all[i]; s = i ^ (1 &lt;&lt; s); // 不包含标志点的集合 for (int j = s; j; j = (j - 1) &amp; s) &#123; // 子集枚举 dp[i] = (dp[i] - all[j] * dp[i ^ j] % mod + mod) % mod; &#125; &#125; printf("%lld\n", dp[(1 &lt;&lt; n) - 1]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>子集dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown & Latex 公式]]></title>
    <url>%2F2018%2F10%2F02%2FMarkdown-Latex-%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[大括号$$f(x) = \begin{cases} x_1 = x_{1,0} + \frac{a_2}{(a_1,a_2)}\times t\\ {x_2 = x_{2,0} - \frac{a_1}{(a_1,a_2)}\times t} \end{cases}$$ 1234$$f(x) = \begin&#123;cases&#125; x_1 = x_&#123;1,0&#125; + \frac&#123;a_2&#125;&#123;(a_1,a_2)&#125;\times t\\\\ &#123;x_2 = x_&#123;2,0&#125; - \frac&#123;a_1&#125;&#123;(a_1,a_2)&#125;\times t&#125; \end&#123;cases&#125;$$ 颜色$\color{black}{Hello World!}$$\color{gray}{Hello World!}$$\color{silver}{Hello World!}$$\color{white}{Hello World!}$$\color{maroon}{Hello World!}$$\color{red}{Hello World!}$$\color{yellow}{Hello World!}$$\color{lime}{Hello World!}$$\color{olive}{Hello World!}$$\color{green}{Hello World!}$$\color{teal}{Hello World!}$$\color{aqua}{Hello World!}$$\color{blue}{Hello World!}$$\color{navy}{Hello World!}$$\color{purple}{Hello World!}$$\color{fuchsia}{Hello World!}$12345678910111213141516$\color&#123;black&#125;&#123;Hello World!&#125;$ $\color&#123;gray&#125;&#123;Hello World!&#125;$ $\color&#123;silver&#125;&#123;Hello World!&#125;$ $\color&#123;white&#125;&#123;Hello World!&#125;$ $\color&#123;maroon&#125;&#123;Hello World!&#125;$ $\color&#123;red&#125;&#123;Hello World!&#125;$ $\color&#123;yellow&#125;&#123;Hello World!&#125;$ $\color&#123;lime&#125;&#123;Hello World!&#125;$ $\color&#123;olive&#125;&#123;Hello World!&#125;$ $\color&#123;green&#125;&#123;Hello World!&#125;$ $\color&#123;teal&#125;&#123;Hello World!&#125;$ $\color&#123;aqua&#125;&#123;Hello World!&#125;$ $\color&#123;blue&#125;&#123;Hello World!&#125;$ $\color&#123;navy&#125;&#123;Hello World!&#125;$ $\color&#123;purple&#125;&#123;Hello World!&#125;$ $\color&#123;fuchsia&#125;&#123;Hello World!&#125;$ 矩阵$$ \left[ \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right] \tag{3}$$ 123456789$$ \left[ \begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \end&#123;matrix&#125; \right] \tag&#123;3&#125;$$ $$ \left| \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right| \tag{3}$$$$ \left( \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right) \tag{3}$$]]></content>
      <categories>
        <category>Markdown &amp; Latex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态开点线段树]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思想动态开点线段树与主席树有一点区别。 如果想开n个线段树，每个线段树彼此独立，那么用动态开点线段树就行。相同点： 每次只更新一条链。不同点： 主席树每次更新的时候是从原来树的基础上“牵”出一条新的链， 相当于建了一棵新树。 动态开点线段树并不会保留原来树的信息， 而是在“完善”当前这颗树。例题 题目CF1046A; 有N个机器人，每个机器人有一个位置x, 一个视线半径r, 一个智商值q。 现在询问有多少对机器人可以相互看见，并且智商差的绝对值小于等于K $1 \leq N \leq 1e5, 1 \leq k \leq 20$ 分析如何解决相互可以看见的问题： 将机器人按半径排序，用线段树维护每个机器人的位置。 依次插入机器人，查询其视线范围机器人的数量。 因为是半径大的先插，所以后插的能看见之前插的，那么之前插的也一定能看见后插的。 解决智商差的问题： 因为k只有20， 设当前机器人智商为q， 那么我们只要暴力查[q - k, q + k]智商内的，并且再其视线范围内的即可。 但是我们不能对每个智商都去开一个线段树，所以我们可以选择动态开点或者主席树。 （主席树差一点点就T了） （突然发现并不需要对x坐标进行离散化，当然肯定不能去build） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int maxm = maxn * 40;struct Node &#123; int x, r, q; bool operator&lt;(const Node &amp;A) const &#123; return r &gt; A.r; &#125;&#125;;Node a[maxn];map&lt;int, int&gt; Hashq;ll sum[maxm];int lch[maxm], rch[maxm], root[maxn];int dfn;void update(int &amp;k, int l, int r, int p, int x) &#123; if (!k) k = ++dfn; sum[k] += x; if (l == r) return; int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update(lch[k], l, mid, p, x); if (mid + 1 &lt;= p) update(rch[k], mid + 1, r, p, x);&#125;ll query(int k, int l, int r, int L, int R) &#123; if (!k) return 0; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k]; int mid = l + r &gt;&gt; 1; ll ret = 0; if (L &lt;= mid) ret += query(lch[k], l, mid, L, R); if (mid + 1 &lt;= R) ret += query(rch[k], mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int Max = 1e9 + 1; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;a[i].x, &amp;a[i].r, &amp;a[i].q); sort(a, a + n); // r dfn = 0; int tot = 1; ll ans = 0; for (int i = 0; i &lt; n; i++) &#123; int base = max(0, a[i].q - m); int top = a[i].q + m; int l = max(0, a[i].x - a[i].r); int r = min(a[i].x + a[i].r, Max); for (int j = base; j &lt;= top; j++) &#123; if (Hashq.find(j) == Hashq.end()) continue; ans += query(root[Hashq[j]], 0, Max, l, r); &#125; if (Hashq[a[i].q] == 0) Hashq[a[i].q] = tot++; update(root[Hashq[a[i].q]], 0, Max, a[i].x, 1); &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[依赖背包]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%BE%9D%E8%B5%96%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[出自《背包九讲》 问题每个物品都有依赖关系，如果i依赖于j，那么要买i物品，必须先买j物品。 限制条件： 每个物品最多只能依赖一件物品；没有循环依赖。 称每个有依赖的为附件，没有依赖的为主件。 思想先考虑简化版，即每个附件都没有附件。 那么对于每个主件所在的物品集合里，我们可以先跑一次01背包，得到每个费用可得到的最大价值。然后把每个$(cost, val), c_i \leq cost \leq V $ 看作一个新的物品。这样问题就转化成了分组背包。 再考虑普通版，即每个附件也可能存在附件。 解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分组背包]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[出自《背包九讲》 问题有$N$件物品和一个容量为$V$的背包。第$i$件物品的体积是$c_i$,价值是$w_i$。这些物品被划分为$K$组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。 思想$dp[i][j]$:表示前i组，容量为j，的最大价值 那么对于每组来说，就有选一件或者不选两种决策。 时间复杂度$O(VN)$12345for k = 1 : K for j = V : 0 for item in k if(j &gt;= c[item]) dp[j] = max(dp[j], dp[j - c[item]] + w[item]);]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[混合背包]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[问题有$N$种物品和一个容量为$V$的背包， 每种物品，有的只有一件，有的有多件，有的有无限件。 求最大价值。 思想多重背包可以通过拆分变成01背包，那么最后问题实际上就是01背包和无限背包的混合。 1234567for i = 1 : n if i 为01背包 for j = V : c[i] dp[j] = max(dp[j], dp[j-c[i]] + w[i]); if i 为无限背包 for j = c[i] : V dp[j] = max(dp[j], dp[j-c[i]] + w[i]);]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多重背包]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[出自《背包九讲》 问题有$N$种物品和一个容量为$V$的背包，第$i$种物品有$m_i$件可用，每种物品的体积是$c_i$,价值是$w_i$。 求解最大价值 思想通过拆分每种物品，使其变成01背包。 假如某种物品有$k$件， 那么可以拆分成:$2^0, 2^1, 2^2… 2^t, k - 2^t$这么多种新的物品。 然后做01背包即可。 复杂度$O(NVlog(M))$ 代码123456789101112131415161718192021int _N = 0;for (int i = 1; i &lt;= N; i++) &#123; // 拆分 for (int j = 0;; j++) &#123; if (m[i] &gt; (1 &lt;&lt; j)) &#123; m[i] -= (1 &lt;&lt; j); _c[_N] = (1 &lt;&lt; j) * c[i]; _w[_N] = (1 &lt;&lt; j) * w[i]; _N++; &#125; else break; &#125; _c[_N] = m[i] * c[i]; _w[_N] = m[i] * w[i]; _N++;&#125;clr(dp, 0);for (int i = 1; i &lt; _N; i++) &#123; // 01背包 for (int j = V; j &gt;= _c[i]; j++) &#123; dp[j] = max(dp[j], dp[j - _c[i]] + _w[i]); &#125;&#125; 可行性问题若问题变为：是否能填满容量为$V$的背包。 则就变成了可行性问题，是可以$O(VN)$解出的。 $dp[i][j]$表示前$i$种物品，填满容量为$j$的背包后，第$i$种物品的剩余数量 $dp[i][j] = -1$表示不可行 1234567891011121314clr(dp[0], -1);dp[0][0] = 0;for (int i = 1; i &lt;= N; i++) &#123; for (int j = 0; j &lt;= V; j++) &#123; if (dp[i - 1][j] &gt;= 0) dp[i][j] = m[i]; else dp[i][j] = -1; &#125; for (int j = 0; j &lt;= V - c[i]; j++) &#123; if (dp[i][j] &gt; 0) dp[i][j + c[i]] = max(dp[i][j + c[i]], dp[i][j] - 1); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[完全背包]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[出自《背包九讲》 问题有$N$种物品和一个容量为$V$的背包，每种物品都有无限个。放入第$i$种物品的的体积是$c_i$,价值是$w_i$。 求解最大价值是多少 思想它和01背包类似，但又不完全相同。 因为当前的状态，比如$dp[i][j]$ 表示前$i$个物品，容量为$j$，的最大价值 它的转移可能是由$dp[i-1][j - k c[i]] + k w[i]$ 转移过来的， 如果去枚举$k$,那么复杂度必定爆炸。 如果我们用一维来表示$dp[j]$ 那么更新$dp[j]$的时候，转移就为$dp[j] = Max(dp[j], dp[j-c[i]]+w[i])$ 而此时$dp[j-c[i]]$是已经被更新过的。 代码123456clr(dp, 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = c[i]; j &lt;= V; j++) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[珂朵莉树-ODT]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91-ODT%2F</url>
    <content type="text"><![CDATA[原文链接 珂朵莉树 ： Old Driver Tree. ODT 是一种基于随机数据的暴力数据结构 主要是应用于维护区间信息。 通过不断地分裂与合并，可证明其均摊复杂度是$log$的 可以解决区间赋值，区间查询等问题。 当然前提是数据随机。 题目cf896C 操作： 区间赋值 区间加 区间第k大 区间幂和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;int a[maxn];int n, m, seed, vmax;ll Pow(ll a, ll b, int p) &#123; ll ret = 1; a %= p; // !!! while (b) &#123; if (b &amp; 1) ret = ret * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return ret;&#125;inline int rnd() &#123; ll ret = seed; seed = ((seed * 7LL) + 13) % mod; return ret;&#125;struct Node &#123; int l, r; mutable ll val; Node(int l = 0, int r = 0, ll val = 0) : l(l), r(r), val(val) &#123;&#125; bool operator&lt;(const Node&amp; A) const &#123; return l &lt; A.l; &#125;&#125;;set&lt;Node&gt; odt;set&lt;Node&gt;::iterator split(int pos) &#123; auto it = odt.lower_bound(Node(pos)); if (it != odt.end() &amp;&amp; it-&gt;l == pos) return it; --it; int L = it-&gt;l, R = it-&gt;r; ll v = it-&gt;val; odt.erase(it); odt.insert(Node(L, pos - 1, v)); return odt.insert(Node(pos, R, v)).first;&#125;void assign(int l, int r, int val) &#123; auto itl = split(l), itr = split(r + 1); odt.erase(itl, itr); odt.insert(Node(l, r, val));&#125;void add(int l, int r, int val) &#123; auto itl = split(l), itr = split(r + 1); for (; itl != itr; itl++) itl-&gt;val += val;&#125;ll Rank(int l, int r, int k) &#123; vector&lt;pair&lt;ll, int&gt;&gt; vp; auto itl = split(l), itr = split(r + 1); vp.clear(); for (; itl != itr; itl++) vp.push_back(mp(itl-&gt;val, itl-&gt;r - itl-&gt;l + 1)); sort(vp.begin(), vp.end()); for (auto&amp; it : vp) &#123; k -= it.second; if (k &lt;= 0) return it.first; &#125;&#125;ll sum(int l, int r, int x, int p) &#123; auto itl = split(l), itr = split(r + 1); ll ret = 0; for (; itl != itr; itl++) ret = (ret + 1LL * (itl-&gt;r - itl-&gt;l + 1) * Pow(itl-&gt;val, x, p) % p) % p; return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d%d%d", &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i = 1; i &lt;= n; i++) &#123; a[i] = (rnd() % vmax) + 1; odt.insert(Node(i, i, a[i])); &#125; odt.insert(Node(n + 1, n + 1, 0)); for (int i = 1, op, l, r, x, y; i &lt;= m; i++) &#123; op = (rnd() % 4) + 1; l = (rnd() % n) + 1; r = (rnd() % n) + 1; if (l &gt; r) swap(l, r); if (op == 3) x = (rnd() % (r - l + 1)) + 1; else x = (rnd() % vmax) + 1; if (op == 4) y = (rnd() % vmax) + 1; // --- if (op == 1) add(l, r, x); else if (op == 2) assign(l, r, x); else if (op == 3) printf("%lld\n", Rank(l, r, x)); else printf("%lld\n", sum(l, r, x, y)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>珂朵莉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU5726-GCD]]></title>
    <url>%2F2018%2F09%2F19%2FHDU5726-GCD%2F</url>
    <content type="text"><![CDATA[题意给一个长度为$N$的序列，每次查询整个序列有多少子段的gcd与$[l,r]$的gcd相同？ $1 \leq N \leq 1e5, 1 \leq a_i \leq 1e9$ 分析区间GCD可以由线段树或者ST表来维护。 整个序列的GCD可以预处理出来， 因为GCD不会很多…. $dp[i]$ 表示到第i个位置并以第i个位置结尾的gcd集合 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];int seg[maxn &lt;&lt; 2];inline void pushup(int rt) &#123; seg[rt] = __gcd(seg[lson], seg[rson]); &#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return seg[rt]; int ret = 0; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) ret = __gcd(ret, query(lson, l, mid, L, R)); if (R &gt;= mid + 1) ret = __gcd(ret, query(rson, mid + 1, r, L, R)); return ret;&#125;map&lt;int, ll&gt; dp[maxn]; // 到i 所组成的gcd的集合和数量int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 0; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), dp[i].clear(); build(1, 1, n); //--- map&lt;int, ll&gt; cnt; for (int i = 1; i &lt;= n; i++) &#123; cnt[a[i]]++; dp[i][a[i]]++; for (auto &amp;v : dp[i - 1]) &#123; int gcd = __gcd(a[i], v.first); cnt[gcd] += v.second; dp[i][gcd] += v.second; &#125; &#125; //--- scanf("%d", &amp;m); int l, r; printf("Case #%d:\n", ++kase); while (m--) &#123; scanf("%d%d", &amp;l, &amp;r); int gcd = query(1, 1, n, l, r); printf("%d %lld\n", gcd, cnt[gcd]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ4053-Couleur权值主席树+启发式合并]]></title>
    <url>%2F2018%2F09%2F18%2FZOJ4053-Couleur%E6%9D%83%E5%80%BC%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题意给一段长度为N的排列$a_i$, 每次删除一个元素（一整段会分为两段），询问所有段中逆序对最多的数量。一直删除到没有元素为止。要求强制在线。 $1 \leq n \leq 1e5, 1 \leq a_i \leq n$ 分析考虑如何维护分裂之后得到的两个新段的逆序对的数量。 假设原始段是$A$，分裂之后的段是$a_1,a_2(a_1 \leq a_2)$ 假设$A$中逆序对的数量是已知的，如果知道$a_1,a_2$其中一段的数量，能否推算出另一段的数量？ $$|a2| = |A| - |a_1| - W$$ 其中$W$是逆序对中的元素分别在两个段的数量。 这个可以通过一个权值主席树来计算。 所以我们只要暴力算出$a_1$中的逆序对数量即可。 复杂度$O(n(logn)^2)$ $pre[i]$: 表示前i个元素的逆序对的个数。 暴力算的时候不要重新建树,利用$pre$和之前建好的权值主席树即可。（否则会爆内存） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;ll a[maxn], p[maxn], pre[maxn];struct SEG &#123; int l, r; ll cnt; bool operator&lt;(const SEG &amp;A) const &#123; return r &lt; A.r; &#125;&#125;;set&lt;SEG&gt; seg; // 当前所有的段multiset&lt;ll&gt; val; // 当前所有段的逆序对的数量ll sum[maxn * 30];int root[maxn * 30];int lch[maxn * 30], rch[maxn * 30];int n, dfn;inline void pushup(int k) &#123; sum[k] = sum[lch[k]] + sum[rch[k]]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; if (l == r) &#123; sum[k] = 0; return; &#125; int mid = l + r &gt;&gt; 1; build(lch[k], l, mid); build(rch[k], mid + 1, r); pushup(k);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old];&#125;void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++dfn; newnode(old, k); if (l == r) &#123; sum[k] += x; return; &#125; int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update(lch[old], lch[k], l, mid, p, x); if (p &gt;= mid + 1) update(rch[old], rch[k], mid + 1, r, p, x); pushup(k);&#125;ll query(int k, int l, int r, int L, int R) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k]; int mid = l + r &gt;&gt; 1; ll ret = 0; if (L &lt;= mid) ret += query(lch[k], l, mid, L, R); if (R &gt;= mid + 1) ret += query(rch[k], mid + 1, r, L, R); return ret;&#125;void work(int l, int k, int r, ll fa_cnt) &#123; if (l == r) return; else if (r - l == 1) &#123; val.insert(0); if (l == k) &#123; seg.insert(&#123;k + 1, r, 0&#125;); val.insert(0); &#125; else &#123; seg.insert(&#123;l, k - 1, 0&#125;); val.insert(0); &#125; &#125; else &#123; if (l == k) &#123; ll cnt = fa_cnt; cnt -= query(root[r], 1, n, 1, a[l] - 1) - query(root[l - 1], 1, n, 1, a[l] - 1); seg.insert(&#123;l + 1, r, cnt&#125;); val.insert(cnt); &#125; else if (r == k) &#123; ll cnt = fa_cnt; cnt -= query(root[r], 1, n, a[r] + 1, n) - query(root[l - 1], 1, n, a[r] + 1, n); seg.insert(&#123;l, r - 1, cnt&#125;); val.insert(cnt); &#125; else &#123; if (k - l &lt; r - k) &#123; ll cnt = pre[k - 1] - pre[l - 1]; for (int i = l; i &lt; k; i++) &#123; cnt -= query(root[l - 1], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;l, k - 1, cnt&#125;); val.insert(cnt); // --- cnt = fa_cnt - cnt; for (int i = l; i &lt;= k; i++) &#123; cnt -= query(root[r], 1, n, 1, a[i] - 1); cnt += query(root[k - 1], 1, n, 1, a[i] - 1); &#125; seg.insert(&#123;k + 1, r, cnt&#125;); val.insert(cnt); &#125; else &#123; ll cnt = pre[r] - pre[k]; for (int i = k + 1; i &lt;= r; i++) &#123; cnt -= query(root[k], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;k + 1, r, cnt&#125;); val.insert(cnt); // --- cnt = fa_cnt - cnt; for (int i = k; i &lt;= r; i++) &#123; cnt -= query(root[k], 1, n, a[i] + 1, n); cnt += query(root[l - 1], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;l, k - 1, cnt&#125;); val.insert(cnt); &#125; &#125; &#125;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", a + i); for (int i = 1; i &lt;= n; i++) scanf("%lld", p + i); ll cnt = 0; val.clear(); seg.clear(); //---- dfn = 0; build(root[0], 1, n); for (int i = 1; i &lt;= n; i++) &#123; update(root[i - 1], root[i], 1, n, a[i], 1); pre[i] = pre[i - 1] + query(root[i], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;1, n, pre[n]&#125;); val.insert(pre[n]); //--- vector&lt;ll&gt; ans; ans.pb(pre[n]); for (int i = 1; i &lt; n; i++) &#123; ll k = p[i] ^ (ans.back()); auto it = seg.lower_bound(&#123;0, k, 0&#125;); // 找到要分裂的段 val.erase(val.find(it-&gt;cnt)); seg.erase(it); int l = it-&gt;l; int r = it-&gt;r; work(l, k, r, it-&gt;cnt); ans.push_back(*(val.rbegin())); &#125; for (int i = 0; i &lt; ans.size(); i++) &#123; if (i) printf(" %lld", ans[i]); else printf("%lld", ans[i]); &#125; puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树成长之路-LV.1]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-LV-1%2F</url>
    <content type="text"><![CDATA[染色相关区间内不同种类的颜色题意给定长度为$N$的序列， $M$次操作，每次可以修改一段区间的颜色，或者查询某段中的颜色的不同种类数。 颜色种类小于64 分析用位来记录当前段所有的颜色。 合并的时候直接用或操作即可。 相关例题 POJ2777 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int n, m, Q;const int maxn = 1e5 + 5;int seg[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2];void pushup(int rt) &#123; seg[rt] = seg[lson] | seg[rson]; &#125;void pushdown(int rt) &#123; if (lazy[rt] == -1) return; seg[lson] = seg[rson] = lazy[rson] = lazy[lson] = lazy[rt]; lazy[rt] = -1;&#125;void build(int rt, int l, int r) &#123; lazy[rt] = -1; if (l == r) &#123; seg[rt] = 1; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R, int c) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; lazy[rt] = seg[rt] = 1 &lt;&lt; (c - 1); return; &#125; pushdown(rt); int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R, c); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R, c); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; return seg[rt]; &#125; pushdown(rt); int ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret |= query(lson, l, mid, L, R); if (mid + 1 &lt;= R) ret |= query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d%d", &amp;n, &amp;m, &amp;Q); char op[2]; build(1, 1, n); for (int i = 0, x, y, z; i &lt; Q; i++) &#123; scanf("%s", op); if (op[0] == 'C') &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (x &gt; y) swap(x, y); update(1, 1, n, x, y, z); &#125; else &#123; scanf("%d%d", &amp;x, &amp;y); if (x &gt; y) swap(x, y); int tmp = query(1, 1, n, x, y); int cnt = 0; for (int i = 0; i &lt; 31; i++) &#123; if (tmp &amp; (1 &lt;&lt; i)) cnt++; &#125; printf("%d\n", cnt); &#125; &#125;&#125; 区间内有多少”段”题意给定长度为$N$的序列， $M$次操作，每次可以修改一段区间的颜色，或者查询区间内有多少段？ 颜色种类数没有限制 分析线段树每个节点维护三个值，区间内段的数量，最左边的颜色，最右边的颜色。 合并的时候如果交点的颜色相同，则数量要减一 矩形面积相关矩形面积并分析将每个矩形的上下两条边取出来。 从下往上扫描。 遇到下边界，则将[l,r)区间覆盖 遇到上边界，则将[l,r)区间撤销 每次查询被覆盖区间的长度。 具体怎么维护呢？1234struct Node&#123; int cnt_cover; // 区间被覆盖次数 double length; // 区间覆盖长度&#125;; 所以如果 cnt_cover &gt; 0 , 则length = 区间长度 cnt_cover == 0 &amp;&amp; l == r, 则length = 0 不然的话 length = 左耳子的length + 右儿子的length 注意 因为维护的是线段，因此区间都是左闭右开的。 具体实现可以参照代码，不同的地方都有注释标记。 维护线段和维护点是不一样的。 假如你要维护[1,2,3] 你查询的时候应该查到2，但实际上你会查到1，[1,2] 和 [3,3], 所以是不一样的。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;map&lt;double, int&gt; Hash;map&lt;int, double&gt; rHash;struct line &#123; double l, r, h; int val; line(double l = 0, double r = 0, double h = 0, int val = 0) : l(l), r(r), h(h), val(val) &#123;&#125; bool operator&lt;(const line &amp;A) const &#123; return h &lt; A.h; &#125;&#125;;struct Node &#123; int cover; double len;&#125;;const int maxn = 1000;Node seg[maxn &lt;&lt; 2];void build(int rt, int l, int r) &#123; seg[rt].cover = seg[rt].len = 0; if (l == r) return; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r);&#125;void pushup(int rt, int l, int r) &#123; if (seg[rt].cover &gt; 0) seg[rt].len = rHash[r + 1] - rHash[l]; // [l,r) else if (l == r) seg[rt].len = 0; else seg[rt].len = seg[lson].len + seg[rson].len;&#125;void update(int rt, int l, int r, int L, int R, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].cover += val; pushup(rt, l, r); return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R, val); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R, val); pushup(rt, l, r);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, kase = 0; while (~scanf("%d", &amp;n)) &#123; if (!n) break; double x1, x2, y1, y2; vector&lt;line&gt; a; set&lt;double&gt; xval; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a.emplace_back(x1, x2, y1, 1); a.emplace_back(x1, x2, y2, -1); xval.insert(x1); xval.insert(x2); &#125; // 离散化 Hash.clear(); rHash.clear(); int cnt = 0; for (auto &amp;v : xval) &#123; Hash[v] = ++cnt; rHash[cnt] = v; &#125; sort(a.begin(), a.end()); build(1, 1, cnt); double ans = 0; for (int i = 0; i &lt; a.size() - 1; i++) &#123; update(1, 1, cnt, Hash[a[i].l], Hash[a[i].r] - 1, a[i].val); //[l,r) ans += (a[i + 1].h - a[i].h) * seg[1].len; &#125; printf("Test case #%d\n", ++kase); printf("Total explored area: %.2lf\n\n", ans); &#125;&#125; 矩形面积交分析维护两个值 $len1$ 表示覆盖次数大于0的区间长度 $len2$ 表示覆盖次数大于1的区间长度 那么$pushup$的时候就要分类讨论了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// ybmj// hdu 1255#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;map&lt;double, int&gt; Hash;map&lt;int, double&gt; rHash;struct Lines &#123; double l, r, h; int val; bool operator&lt;(const Lines &amp;A) const &#123; return h &lt; A.h; &#125;&#125;;struct Node &#123; int cnt; // 覆盖次数 double len1; // 覆盖次数大于0的长度 double len2; // 覆盖次数大于1的长度&#125;;Node seg[maxn &lt;&lt; 2];void build(int rt, int l, int r) &#123; seg[rt].cnt = seg[rt].len1 = seg[rt].len2 = 0; if (l == r) return; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r);&#125;inline void pushup(int rt, int l, int r) &#123; if (seg[rt].cnt &gt; 1) seg[rt].len1 = seg[rt].len2 = rHash[r + 1] - rHash[l]; else if (seg[rt].cnt == 1) &#123; seg[rt].len1 = rHash[r + 1] - rHash[l]; if (l == r) seg[rt].len2 = 0; else seg[rt].len2 = seg[lson].len1 + seg[rson].len1; &#125; else &#123; if (l == r) seg[rt].len1 = seg[rt].len2 = 0; else &#123; seg[rt].len1 = seg[lson].len1 + seg[rson].len1; seg[rt].len2 = seg[lson].len2 + seg[rson].len2; &#125; &#125;&#125;void update(int rt, int l, int r, int L, int R, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].cnt += val; pushup(rt, l, r); return; &#125; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) update(lson, l, mid, L, R, val); if (R &gt;= mid + 1) update(rson, mid + 1, r, L, R, val); pushup(rt, l, r);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); double x1, x2, y1, y2; vector&lt;Lines&gt; line; set&lt;double&gt; X; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y1, &amp;x2, &amp;y2); line.push_back(&#123;x1, x2, y1, 1&#125;); line.push_back(&#123;x1, x2, y2, -1&#125;); X.insert(x1); X.insert(x2); &#125; sort(line.begin(), line.end()); int cnt = 0; Hash.clear(); rHash.clear(); for (auto &amp;v : X) Hash[v] = ++cnt, rHash[cnt] = v; build(1, 1, cnt); double area = 0; for (int i = 0; i &lt; line.size() - 1; i++) &#123; update(1, 1, cnt, Hash[line[i].l], Hash[line[i].r] - 1, line[i].val); area += seg[1].len2 * (line[i + 1].h - line[i].h); &#125; printf("%.2lf\n", area); &#125;&#125; 区间更新的一些骚操作将区间元素都变成其根号题意 区间求和 将区间每个元素都变成其根号分析 因为一个数不断的取根号，很快就变成了1. 因此我们在区间更新的时候，只要这个区间的最大值小于等于1（因为有0），那么就去更新到叶。否则就不需要更新。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// ybmj// bzoj3211#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;struct Node &#123; ll sum; int Max;&#125;;Node seg[maxn &lt;&lt; 2];int a[maxn];inline void pushup(int rt) &#123; seg[rt].Max = max(seg[lson].Max, seg[rson].Max); seg[rt].sum = seg[lson].sum + seg[rson].sum;&#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt].Max = a[l]; seg[rt].sum = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R) &#123; if (seg[rt].Max &lt;= 1) return; if (l == r) &#123; seg[rt].Max = sqrt(seg[rt].Max); seg[rt].sum = sqrt(seg[rt].sum); return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R); pushup(rt);&#125;ll query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].sum; &#125; ll ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret += query(lson, l, mid, L, R); if (mid + 1 &lt;= R) ret += query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); scanf("%d", &amp;m); build(1, 1, n); while (m--) &#123; int x, l, r; scanf("%d%d%d", &amp;x, &amp;l, &amp;r); if (x == 1) &#123; printf("%lld\n", query(1, 1, n, l, r)); &#125; else &#123; update(1, 1, n, l, r); &#125; &#125;&#125; 区间gcd，区间加题意 求区间的gcd 区间加val分析Gcd性质 12gcd(a,b) = gcd(a,b-a);gcd(a,b,c,d) = gcd(a,b-a,c-b,d-c) 维护一个a数组的差分序列，称作b 那么区间[l,r]加v， 实际上就等于$b[l] + v, b[r+1] - v$. 查询[l,r]的gcd，等于 $Gcd(a[l], Gcd(b[l+1] .. b[r]))$ 所以我们要维护原来的a数组，以及差分后的b数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// ybmj// CH 4302#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e5 + 5;ll seg[maxn &lt;&lt; 2];ll a[maxn], b[maxn];inline void pushup(int rt) &#123; seg[rt] = gcd(seg[lson], seg[rson]); &#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt] = b[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update_gcd(int rt, int l, int r, int pos, ll x) &#123; if (l == r) &#123; seg[rt] += x; return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= pos) update_gcd(lson, l, mid, pos, x); else update_gcd(rson, mid + 1, r, pos, x); pushup(rt);&#125;ll query_gcd(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return seg[rt]; ll ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret = __gcd(ret, query_gcd(lson, l, mid, L, R)); if (mid + 1 &lt;= R) ret = __gcd(ret, query_gcd(rson, mid + 1, r, L, R)); return ret;&#125;ll bit[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;ll query(int x) &#123; ll ret = 0; for (int i = x; i &gt; 0; i -= lowb(i)) ret += bit[i]; return ret;&#125;void update(int l, int r, ll val, int n) &#123; for (int i = l; i &lt;= n; i += lowb(i)) bit[i] += val; for (int i = r + 1; i &lt;= n; i += lowb(i)) bit[i] -= val;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld", a + i); for (int i = 1; i &lt;= n; i++) b[i] = a[i] - a[i - 1]; build(1, 1, n); char op[2]; int l, r; ll val; while (m--) &#123; scanf("%s", op); if (op[0] == 'Q') &#123; scanf("%d%d", &amp;l, &amp;r); if (l == r) printf("%lld\n", a[l] + query(l)); else printf("%lld\n", __gcd(a[l] + query(l), abs(query_gcd(1, 1, n, l + 1, r)))); &#125; else &#123; scanf("%d%d%lld", &amp;l, &amp;r, &amp;val); update_gcd(1, 1, n, l, val); if (r &lt; n) update_gcd(1, 1, n, r + 1, -val); update(l, r, val, n); &#125; &#125;&#125; 维护循环节题意You have $N$ integers $A_1,A_2,…,A_N$. You are asked to write a program to receive and execute two kinds of instructions: $C$ $a$ $b$ means performing $A_i=(A_i^2mod2018)$ for all Ai such that $a≤i≤b$. $Q$ $a$ $b$ means query the sum of $A_a,A_{a+1},…,A_b$. Note that the sum is not taken modulo 2018. $1 \leq n, Q \leq 50000$ 分析每个数模2018的最大周期是6. 所以更新6次之后一定进入循环节。 所以对于每个结点，我们要维护一个长度为6的循环节。 如果更新不足6次，则直接暴力更新到叶子结点。 更新到第6次，说明进入循环节，此时维护循环节即可。 需要注意的是在$pushup$的时候要更新 “次数”。 详见代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj// 2018 ACM/ICPC 上海大都会赛H题#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;const int mod = 2018;int a[maxn];int sum[maxn &lt;&lt; 2][6], p[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], cnt[maxn &lt;&lt; 2];inline void pushup(int rt) &#123; cnt[rt] = min(cnt[lson], cnt[rson]); // 记得更新次数 if (cnt[rt] &lt; 5) &#123; sum[rt][0] = sum[lson][p[lson]] + sum[rson][p[rson]]; // 如果cnt[i] &lt; 5, 那么p[i] = 0 return; &#125; p[rt] = 0; for (int i = 0; i &lt; 6; i++) // 更新整个循环节 sum[rt][i] = sum[lson][(p[lson] + i) % 6] + sum[rson][(p[rson] + i) % 6];&#125;inline void pushdown(int rt) &#123; if (!lazy[rt]) return; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; (p[lson] += lazy[rt]) %= 6; (p[rson] += lazy[rt]) %= 6; lazy[rt] = 0;&#125;void build(int rt, int l, int r) &#123; p[rt] = lazy[rt] = cnt[rt] = 0; if (l == r) &#123; sum[rt][0] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R) &#123; if (l == r) &#123; // 进循环节前暴力更新到叶子 cnt[rt]++; if (cnt[rt] &lt; 5) &#123; sum[rt][0] = sum[rt][0] * sum[rt][0] % mod; &#125; else if (cnt[rt] == 5) &#123; sum[rt][0] = sum[rt][0] * sum[rt][0] % mod; for (int i = 1; i &lt; 6; i++) sum[rt][i] = sum[rt][i - 1] * sum[rt][i - 1] % mod; &#125; else (++p[rt]) %= 6; return; &#125; if (L &lt;= l &amp;&amp; R &gt;= r &amp;&amp; cnt[rt] &gt;= 5) &#123; // 进入循环节后才可以直接返回 lazy[rt]++; (++p[rt]) %= 6; return; &#125; pushdown(rt); int mid = l + r &gt;&gt; 1; if (L &lt;= mid) update(lson, l, mid, L, R); if (R &gt;= mid + 1) update(rson, mid + 1, r, L, R); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[rt][p[rt]]; pushdown(rt); int ret = 0; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) ret += query(lson, l, mid, L, R); if (R &gt;= mid + 1) ret += query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); build(1, 1, n); int Q; scanf("%d", &amp;Q); char op[2]; int l, r; printf("Case #%d:\n", kase++); while (Q--) &#123; scanf("%s%d%d", op, &amp;l, &amp;r); if (op[0] == 'Q') printf("%d\n", query(1, 1, n, l, r)); else update(1, 1, n, l, r); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1176]]></title>
    <url>%2F2018%2F09%2F14%2Fbzoj1176%2F</url>
    <content type="text"><![CDATA[题意维护一个W*W的矩阵，初始值均为S.每次操作可以增加某格子的权值,或询问某子矩阵的总权值.修改操作数M&lt;=160000,询问数Q&lt;=10000,W&lt;=2000000. 分析维护矩阵和的基本思想还是不变的，即利用二维前缀和。 困难在于W过大，无法直接开数组。 考虑分治 设$solve(l,r)$ 为只考虑第l个到第r个操作/询问内，所有操作对询问的影响。 那么我们分治步骤即为 将数组按x坐标排序 计算solve(l,r) , 按坐标mid将数组分为两块 $solve(l,mid)$ 计算[l,mid]操作对[mid+1,r]的询问产生的影响 $solve(mid+1,r)$ 将数组还原成按x排序的 那么如何做步骤4呢？ 我们按照x坐标排序，用权值线段树或者权值树状数组来维护y方向的权值。 当然这么写常数比较大。 我们可以在分治之前先解决步骤4， 这样就不需要步骤6了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const int maxm = 2e6 + 5;struct P &#123; int op, x, y, val, id, qid; bool operator&lt;(const P&amp; A) const &#123; return x &lt; A.x; &#125;&#125;;P a[maxn &lt;&lt; 2], tmp[maxn &lt;&lt; 2];int ans[maxn];int BIT[maxm];int n, s, w;inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l, int r) &#123; int ret = 0; for (int i = l - 1; i &gt; 0; i -= lowb(i)) ret -= BIT[i]; for (int i = r; i &gt; 0; i -= lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x, int y) &#123; for (int i = x; i &lt;= w; i += lowb(i)) BIT[i] += y;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = l + r &gt;&gt; 1; int l1 = l, l2 = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (a[i].id &lt;= mid) tmp[l1++] = a[i]; else tmp[l2++] = a[i]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; solve(l, mid); l1 = l; for (int i = mid + 1; i &lt;= r; i++) &#123; while (l1 &lt;= mid &amp;&amp; a[l1].x &lt;= a[i].x) &#123; if (a[l1].op == 1) update(a[l1].y, a[l1].val); l1++; &#125; if (a[i].op == 1) continue; ans[a[i].qid] += a[i].val * query(1, a[i].y); &#125; for (int i = l; i &lt; l1; i++) &#123; if (a[i].op == 1) update(a[i].y, -a[i].val); &#125; solve(mid + 1, r); l1 = l, l2 = mid + 1; int l3 = l; while (l1 &lt;= mid &amp;&amp; l2 &lt;= r) &#123; if (a[l1].x &gt; a[l2].x) tmp[l3++] = a[l2++]; else tmp[l3++] = a[l1++]; &#125; while (l1 &lt;= mid) tmp[l3++] = a[l1++]; while (l2 &lt;= r) tmp[l3++] = a[l2++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d", &amp;s, &amp;w); clr(ans, -1); int op, x1, x2, y1, y2, val; n = 0; int cnt = 0; while (true) &#123; scanf("%d", &amp;op); if (op == 3) break; if (op == 1) &#123; scanf("%d%d%d", &amp;x1, &amp;y1, &amp;val); a[++n] = &#123;op, x1, y1, val, n, -1&#125;; &#125; else &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); ++cnt; ans[cnt] = 0; a[++n] = &#123;op, x2, y2, 1, n, cnt&#125;; a[++n] = &#123;op, x1 - 1, y2, -1, n, cnt&#125;; a[++n] = &#123;op, x2, y1 - 1, -1, n, cnt&#125;; a[++n] = &#123;op, x1 - 1, y1 - 1, 1, n, cnt&#125;; &#125; &#125; sort(a + 1, a + n + 1); solve(1, n); for (int i = 1; i &lt;= cnt; i++) &#123; if (ans[i] == -1) continue; else printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1492-Cash-CDQ分治入门题]]></title>
    <url>%2F2018%2F09%2F05%2Fbzoj1492-Cash-CDQ%E5%88%86%E6%B2%BB%E5%85%A5%E9%97%A8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意股市中有两种金券A和B，每天都会有个成交价格$a_i,b_i$ 每天可以做无限次操作。 操作分为两类： 按当天固定比例$c_i$购买金券。 即每天都会有个比例$c_i$，若要买k元的金卷，那么保证购入的A卷的数量比B卷的数量等于$c_i$ 按任意相同比例卖出金卷，即同时要卖出百分之x的金卷。 如果你一开始有S元，那么请问n天后，最多能获得多少钱？ 拥有的卷的数量为实数。 $1 \leq n \leq 1e5$ 分析$dp[i]$:表示第i天所能获得的最大金钱。 $x[i]$表示第i天最多能获得的A卷数量， $y[i]$表示第i天最多能获得的B卷数量 $$dp[i] = Max(x[j] a[i] + y[j] b[i]), j \in [1,i-1]$$ 如果决策k优于决策j，那么 $$(x[j] - x[k])a[i] &lt; (y[k] - y[j])b[i]$$ 不妨设$x[k] &gt; x[j]$,那么 $$\frac{y[k] - y[j]}{x[k] - x[j]} &gt; -\frac{a[i]}{b[i]}$$ 因此根据斜率优化dp的知识，我们知道需要维护一个$x[i]$递增的，并且斜率递减的队列。 同时由于不等式右边并没有单调性，因此我们需要在队列里二分。 但这个队列有点难维护（貌似还要手写平衡树 （ 我会补的！ ） 因此我们的CDQ分治就要登场啦！ 定义$solve(l,r)$是计算出$[l,r]$的答案(dp值)。 那么我先计算$solve(l,mid)$ 然后用$[l,mid]$的结果算一下对$[mid+1,r]$的贡献 然后再计算$solve(mid+1,r)$ 是不是就是$solve(l,r)$了呢？ （这大概就是cdq分治了 那么$[l,mid]$对$[mid+1,r]$的贡献怎么算呢？ 我们将$[l,mid]$的元素按$x$排序，保证了$x$的递增 然后将$[mid+1,r]$的元素按$-\frac{a[i]}{b[i]}$从小到大排序，这样保证了不等式右边的单调性。 这样的话我们就可以用单调队列优化了！ 维护一个斜率递减的单调队列，$O(nlogn)$即可解决问题。 看了一下网上别人的代码，发现还可以优化。 不需要排序，可以将$O(nlogn)$降为$O(n)$ 一开始就将数组按$-\frac{a[i]}{b[i]}$排序， 然后在$solve(mid+1,r)$解决之后，再将$[l,r]$按$x$从小到大排序。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double eps = 1e-8;const int maxn = 1e5 + 5;struct P &#123; double a, b, r, k, x, y; int id; bool operator&lt;(const P &amp;A) const &#123; return k &gt; A.k; &#125;&#125;;P p[maxn], cpy[maxn];double dp[maxn];int q[maxn];inline double slope(int j, int k) &#123; if (fabs(p[j].x - p[k].x) &lt; eps) &#123; if (p[k].y - p[j].y &gt; 0) return 1e10; else return -1e9; &#125; return (p[j].y - p[k].y) / (p[j].x - p[k].x);&#125;void solve(int l, int r) &#123; if (l == r) &#123; dp[l] = max(dp[l - 1], dp[l]); p[l].y = dp[l] / (p[l].a * p[l].r + p[l].b); p[l].x = p[l].y * p[l].r; return; &#125; int m = l + r &gt;&gt; 1; int l1 = l, l2 = m + 1; for (int i = l; i &lt;= r; i++) &#123; if (p[i].id &lt;= m) cpy[l1++] = p[i]; else cpy[l2++] = p[i]; &#125; for (int i = l; i &lt;= r; i++) p[i] = cpy[i]; solve(l, m); int L = l, R = l - 1; for (int i = l; i &lt;= m; i++) &#123; while (L &lt; R &amp;&amp; slope(q[R - 1], q[R]) &lt; slope(q[R], i)) R--; q[++R] = i; &#125; for (int i = m + 1, id; i &lt;= r; i++) &#123; while (L &lt; R &amp;&amp; slope(q[L], q[L + 1]) &gt; p[i].k) L++; id = q[L]; dp[p[i].id] = max(dp[p[i].id], p[id].x * p[i].a + p[id].y * p[i].b); &#125; solve(m + 1, r); l1 = l, l2 = m + 1; int cur = l; while (l1 &lt;= m &amp;&amp; l2 &lt;= r) &#123; if (p[l1].x &lt; p[l2].x + eps) cpy[cur++] = p[l1++]; else cpy[cur++] = p[l2++]; &#125; while (l1 &lt;= m) cpy[cur++] = p[l1++]; while (l2 &lt;= r) cpy[cur++] = p[l2++]; for (int i = l; i &lt;= r; i++) p[i] = cpy[i];&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; double s; scanf("%d%lf", &amp;n, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf%lf", &amp;p[i].a, &amp;p[i].b, &amp;p[i].r); p[i].id = i; p[i].k = -p[i].a / p[i].b; &#125; sort(p + 1, p + 1 + n); dp[0] = s; solve(1, n); printf("%.3lf\n", dp[n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[staircase nim-楼梯游戏]]></title>
    <url>%2F2018%2F09%2F05%2Fstaircase-nim-%E6%A5%BC%E6%A2%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[定义有一个n阶楼梯，从下到上编号为0~n，游戏开始时有若干硬币任意分布在楼梯上。Alice和Bob轮流操作。每次操作可以选择一阶楼梯上的若干硬币（至少一个），然后移到下一阶楼梯上。最后不能移动的人输。 结论奇数阶楼梯上的石子异或和为零，则先手必胜。 证明首先明确 最后的状态是奇数阶梯上的石子异或和为零。 那么对于奇数阶楼梯上的石子异或和不为零的情况： 先手可以移动若干石子，使得奇数阶梯上的石子异或和为零。 不管后手怎么移动，一定会使得奇数阶梯上的石子异或和不为零。 因此最后一定是先手必胜。 对于奇数阶梯上的石子异或和为零的情况： 不管先手如何移动，都会使得奇数阶梯上的石子异或和不为零。 而后手可以修正，使得奇数阶梯上的石子异或和为零。 因此后手必胜。]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj3675-序列分割]]></title>
    <url>%2F2018%2F09%2F04%2Fbzoj3675-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题意一个长度为n的非负整数序列，要求分割成k+1段，每次分割获得的价值是：分割后两端和的乘积。求获得的最大价值 $1 \leq n \leq 1e5, 1 \leq k \leq 200$ 分析最终答案和分割的次序是没有关系的。 证明可以考虑分割结束后重新合并的过程，发现合并的次序并没有影响，因此分割时的次序也不影响答案。 因为k只有200，所以很容易想到一个$O(nk)$的dp。 $dp[k][n]$表示第k次分割前n个元素可获得的最大价值。 $$dp[k][n] = Max( dp[k-1][j] + pre[j] \times ( pre[n] - pre[j])), j \in [k-1,n-1]$$ 继续化简即可得到一个斜率不等式，而且是可以用单调队列优化的那种噢！ 如果对斜率优化不清楚的话，可以参考我的另一篇博客：优化方法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (random_shuffle(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];ll pre[maxn], dp[2][maxn];inline double slope(int j, int k, int i) &#123; double mj = dp[(i &amp; 1) ^ 1][j] - pre[j] * pre[j]; double mk = dp[(i &amp; 1) ^ 1][k] - pre[k] * pre[k]; if (pre[j] == pre[k]) return (mj - mk) &gt; 0 ? 10000 : -1e9 - 5; return (mj - mk) / (pre[j] - pre[k]);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), pre[i] = pre[i - 1] + a[i]; for (int i = 1; i &lt;= m; i++) &#123; int l = 1, r = 1; vector&lt;int&gt; q(n + 2); q[1] = i - 1; for (int t = i; t &lt;= n; t++) &#123; while (l &lt; r &amp;&amp; slope(q[l], q[l + 1], i) &gt; -pre[t]) l++; int idx = q[l]; dp[i &amp; 1][t] = dp[(i &amp; 1) ^ 1][idx] + pre[idx] * (pre[t] - pre[idx]); while (l &lt; r &amp;&amp; slope(q[r - 1], q[r], i) &lt; slope(q[r], t, i)) r--; q[++r] = t; &#125; &#125; printf("%lld\n", dp[m &amp; 1][n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1010-玩具装箱]]></title>
    <url>%2F2018%2F09%2F03%2Fbzoj1010-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[题意n个玩具，每个玩具长度为$c[i]$，制造一个长度为x的容器需要$(x - L) ^ 2$元，可以将下标连续的玩具放在同一个容器中，两两玩具之间需要加一个长度为1的垫子（容器的头和尾不用）。 问将所有玩具装到容器中的最小价值。 $1 \leq n \leq 50000, 1 \leq L,c[i] \leq 10000000$ 分析$dp[i]$ 表示装前i个玩具需要的最小代价$$dp[i] = Min(dp[j] + (pre[i] - pre[j] + i - j - 1 - L) ^ 2), j \in [1,i-1]$$ 其中$pre[i]$为长度的前缀和。 设$a[i] = pre[i] + i, b = 1 + L$ $M[i][j] = dp[j] + (pre[i] - pre[j] + i - j - 1 - L) ^ 2$ 对于两个决策j和k(j &lt; k)，若k决策优于j决策，则有$M[i][j] &gt; M[i][k]$ 我们来继续化简一下这个式子。 可以得到$$\frac{(dp[j] + a[j]^2) - (dp[k] + a[k])^2}{a[j] - a[k]} &lt; 2a[i] - 2b$$ 设$C[i] = 2a[i] - 2b$，把不等式左边看成一个斜率$slope(j,k)$ 所以我们只要维护一个$slope$单调递增的队列，为什么呢? 如果$slope(q[i-1],q[i]) &gt; slope(q[i],q[i+1])$ ，那么当q[i]比q[i-1]优的时候，q[i+1]一定比q[i]优，所以q[i]就没有存在的必要了。 所以我们需要维护的是一个递增的队列。 假设队列中的i位置的值是决策点， 那么有$$\begin{cases} slope(q[i-1],q[i]) &lt; C[i]\\ slope(q[i],q[i+1]) &gt;= C[i] \end{cases}$$ 一般情况下只要二分这个i值就可以了，但是本题中$C[i]$是单调不降的，所以对于决策j,k(j &lt; k), k优于j决策的话，那么对于$i \in [k+1,n]$都适用，因此j决策就没有存在的必要了，因此我们可以用单调队列进行优化 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;ll pre[maxn], a[maxn], c[maxn], dp[maxn];inline double slope(int i, int k) &#123; return 1.0 * ((dp[i] + a[i] * a[i]) - (dp[k] + a[k] * a[k])) / (a[i] - a[k]);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, L; scanf("%d%d", &amp;n, &amp;L); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]), pre[i] = pre[i - 1] + c[i], a[i] = pre[i] + i; int b = 1 + L; int l = 1, r = 1; vector&lt;int&gt; dq(n + 2); dq[1] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (l &lt; r &amp;&amp; slope(dq[l], dq[l + 1]) &lt; 2 * a[i] - 2 * b) l++; int k = dq[l]; dp[i] = dp[k] + (a[i] - a[k] - b) * (a[i] - a[k] - b); while (l &lt; r &amp;&amp; slope(dq[r], i) &lt; slope(dq[r - 1], dq[r])) r--; dq[++r] = i; &#125; printf("%lld\n", dp[n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj4836-分治FFT]]></title>
    <url>%2F2018%2F08%2F31%2Fbzoj4836-%E5%88%86%E6%B2%BBFFT%2F</url>
    <content type="text"><![CDATA[题意$$x \ opt \ y = \begin{cases} x+y&amp;, &amp;x&lt;y \\ x-y&amp;,&amp;x≥y \end{cases}$$ 现在给定一个长为 n 的数列 a 和一个长为 m 的数列 b ，接下来有 q 次询问。每次询问给定一个数字 c 你需要求出有多少对 (i, j) 使得 $a_i\ opt\ b_j=c$ 分析对于 x+y 的操作，有可能会算到 $x \leq y$的情况，所以我们选择分治 $x \in [l,mid]$ 的情况和$y \in (mid,r]$ 会有贡献 对于x-y的操作，则不会算到x &lt; y的情况， 所以算一遍就可以啦 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;namespace fft &#123;typedef double db;struct cp &#123; db x, y; cp() &#123; x = y = 0; &#125; cp(db x, db y) : x(x), y(y) &#123;&#125;&#125;;inline cp operator+(cp a, cp b) &#123; return cp(a.x + b.x, a.y + b.y); &#125;inline cp operator-(cp a, cp b) &#123; return cp(a.x - b.x, a.y - b.y); &#125;inline cp operator*(cp a, cp b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;inline cp conj(cp a) &#123; return cp(a.x, -a.y); &#125;int base = 1;vector&lt;cp&gt; roots;vector&lt;int&gt; rev;const db PI = acosl(-1.0);void init() &#123; roots.pb(cp(0, 0)); roots.pb(cp(1, 0)); rev.pb(0); rev.pb(1);&#125;void ensure_base(int nbase) &#123; if (nbase &lt;= base) return; rev.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); for (int i = 0; i &lt; (1 &lt;&lt; nbase); i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1)); roots.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); while (base &lt; nbase) &#123; db angle = 2 * PI / (1 &lt;&lt; (base + 1)); for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) &#123; roots[i &lt;&lt; 1] = roots[i]; db angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base)); roots[(i &lt;&lt; 1) + 1] = cp(cos(angle_i), sin(angle_i)); &#125; base++; &#125;&#125;void fft(vector&lt;cp&gt;&amp; a, int n = -1) &#123; if (n == -1) n = a.size(); assert((n &amp; (n - 1)) == 0); int zeros = __builtin_ctz(n); ensure_base(zeros); int shift = base - zeros; for (int i = 0; i &lt; n; i++) if (i &lt; (rev[i] &gt;&gt; shift)) swap(a[i], a[rev[i] &gt;&gt; shift]); for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += 2 * k) for (int j = 0; j &lt; k; j++) &#123; cp z = a[i + j + k] * roots[j + k]; a[i + j + k] = a[i + j] - z; a[i + j] = a[i + j] + z; &#125;&#125;vector&lt;cp&gt; fa, fb;vector&lt;ll&gt; multiply(vector&lt;ll&gt;&amp; a, vector&lt;ll&gt;&amp; b) &#123; int need = a.size() + b.size() - 1; int nbase = 0; while ((1 &lt;&lt; nbase) &lt; need) nbase++; ensure_base(nbase); int sz = 1 &lt;&lt; nbase; if (sz &gt; (int)fa.size()) fa.resize(static_cast&lt;unsigned long&gt;(sz)); for (int i = 0; i &lt; sz; i++) &#123; ll x = (i &lt; (int)a.size() ? a[i] : 0); ll y = (i &lt; (int)b.size() ? b[i] : 0); fa[i] = cp(x, y); &#125; fft(fa, sz); cp r(0, -0.25 / sz); for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) &#123; int j = (sz - i) &amp; (sz - 1); cp z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r; if (i != j) &#123; fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r; &#125; fa[i] = z; &#125; fft(fa, sz); vector&lt;ll&gt; res(static_cast&lt;unsigned long&gt;(need)); for (int i = 0; i &lt; need; i++) &#123; res[i] = fa[i].x + 0.5; &#125; return res;&#125;&#125;; // namespace fftll a[maxn], b[maxn], c[maxn &lt;&lt; 3];const int offset = maxn;void solve(int l, int r) &#123; if (l == r) &#123; c[0] += a[l] * b[r]; return; &#125; int m = l + r &gt;&gt; 1; vector&lt;ll&gt; s1(r - l + 1), s2(r - l + 1); for (int i = 0; i &lt;= m - l; i++) s1[i] = a[i + l]; for (int i = 1; i &lt;= r - m; i++) s2[i] = b[i + m]; vector&lt;ll&gt; ret = fft::multiply(s1, s2); for (int i = 1; i &lt;= r - l; i++) c[i + l + m + offset] += ret[i]; solve(l, m); solve(m + 1, r);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); fft::init(); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); clr(c, 0); clr(a, 0); clr(b, 0); for (int i = 0, x; i &lt; n; i++) &#123; scanf("%d", &amp;x); a[x]++; &#125; for (int i = 0, x; i &lt; m; i++) &#123; scanf("%d", &amp;x); b[x]++; &#125; vector&lt;ll&gt; s1(maxn), s2(maxn + offset); for (int i = 0; i &lt; maxn; i++) s1[i] = a[i]; for (int i = 0; i &lt; maxn; i++) s2[offset - i] = b[i]; vector&lt;ll&gt; ret = fft::multiply(s1, s2); for (int i = 0; i &lt; maxn; i++) c[i + offset] += ret[i + offset]; solve(0, 50000); for (int i = 0, x; i &lt; q; i++) &#123; scanf("%d", &amp;x); printf("%lld\n", c[x + offset]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3527]]></title>
    <url>%2F2018%2F08%2F31%2Fbzoj-3527%2F</url>
    <content type="text"><![CDATA[题意给你一个长度为n的序列$a+i$,让求出$E_i$ $E_i = \sum_{k&lt;i} \frac{a_k}{(i-k)^2} - \sum_{k&gt;i} \frac{a_k}{(i-k)^2}$ n≤100000 分析把$i-k$记做$d$ 设$A[i] = a_i$, $B[d] = \frac{1}{d^2}$ 那么前面那个式子直接卷积就可以了。 后面的式子因为是负数，所以要偏移一下 $A[i + N] = a_i$, $B[-d + N] = \frac{-1}{d^2}$ 然后卷一下就好了。 主要学习一下这个偏移的操作。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];double sum[maxn &lt;&lt; 2];double a[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%lf", a + i); int len = 1; while (len &lt; n * 4) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0), sum[i] = 0; for (int i = 0; i &lt; n; i++) x1[i + n].x = a[i]; for (int i = 1; i &lt; n; i++) x2[i + n].x = 1.0 / (1.0 * i * i); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += x1[i].x; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); for (int i = 0; i &lt; n; i++) x1[i + n].x = a[i]; for (int i = 1; i &lt; n; i++) x2[n - i].x = -1.0 / (1.0 * i * i); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += x1[i].x; for (int i = 0; i &lt; n; i++) &#123; printf("%.3lf\n", sum[i + 2 * n]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三维前缀和]]></title>
    <url>%2F2018%2F08%2F31%2F%E4%B8%89%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819int a[maxn][maxn][maxn];int sum(int x1, int y1, int z1, int x2, int y2, int z2) &#123; return a[x2][y2][z2] - a[x1 - 1][y2][z2] - a[x2][y1 - 1][z2] - a[x2][y2][z1 - 1] + a[x1 - 1][y1 - 1][z2] + a[x1 - 1][y2][z1 - 1] + a[x2][y1 - 1][z1 - 1] - a[x1 - 1][y1 - 1][z1 - 1];&#125;void init(int n) &#123; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i - 1][k][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k - 1][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k][t - 1];&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf528D-Fuzzy Search]]></title>
    <url>%2F2018%2F08%2F28%2Fcf528D-Fuzzy-Search%2F</url>
    <content type="text"><![CDATA[题意给你两个串a,b,和一个数字k, 对于b[i] 它可以匹配 a中[i-k,i+k]任意一个位置的字符（a中每个字符可以重复匹配）。 问b在a中可以有几次匹配？ $1 \leq b \leq a \leq 2e5, 0 \leq k \leq 2e5$ 分析如果 b[i] 可以匹配 a[i-k,i+k], 不妨把a[i-k,i+k]的字符都放到 a[i]这个位置上（前提是ａ中每个字符是可以重复匹配的）。 这样的话问题又变成了传统套路题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int ok[maxn][5];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); map&lt;char, int&gt; id; id['A'] = 1; id['G'] = 2; id['C'] = 3; id['T'] = 4; int len1, len2, k; scanf("%d%d%d%s%s", &amp;len1, &amp;len2, &amp;k, a, b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; deque&lt;int&gt; dq; for (int i = 0; i &lt; k &amp;&amp; i &lt; len1; i++) &#123; dq.push_back(id[a[i]]); sum[id[a[i]]]++; &#125; for (int i = 0; i &lt; len1; i++) &#123; if (i + k &lt; len1) dq.pb(id[a[i + k]]), sum[id[a[i + k]]]++; if (i &gt; k) &#123; sum[dq.front()]--; dq.pop_front(); &#125; for (int j = 1; j &lt; 5; j++) if (sum[j]) ok[i][j]++; &#125; for (int i = 1; i &lt; 5; i++) sum[i] = 0; for (int c = 1; c &lt; 5; c++) &#123; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); for (int i = 0; i &lt; len1; i++) if (ok[i][c]) x1[i] = Complex(1, 0); for (int i = 0; i &lt; len2; i++) if (id[b[i]] == c) x2[len2 - i - 1] = Complex(1, 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += (int)(x1[i].x + 0.5); &#125; ll ans = 0; for (int i = len2 - 1; i &lt; len1; i++) &#123; if (sum[i] == len2) ans++; &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu5885-XM Reserves]]></title>
    <url>%2F2018%2F08%2F27%2Fhdu5885-XM-Reserves%2F</url>
    <content type="text"><![CDATA[题意n*m的矩形，每个点有p(i,j)，你可以选择一个点(x,y)，那么在该点可以得到的价值val为1234rep(i,1,n) rep(j,1,m) &#123; dis=(i,j)与(x,y)欧几里得距离 if(dis&lt;R) val+=p(i,j)/(dis+1)&#125; 要求选取一个点，使val最大，输出val (1≤n,m≤500), (0≤r≤300). 分析FFT建模 首先观察这个式子$$\frac{p(i,j)}{\sqrt{(dx^2+dx^2)} + 1}$$ 它对$(i + dx, j + dy)$有贡献 发现分子分母之间没有联系，所以是可以分开的。 不妨设$A[i][j] = p(i,j)$, $B[dx][dy] = \frac{1}{\sqrt{(dx^2+dx^2)} + 1}$ 所以$C[i+dx][j+dy] = A[i][j] * B[dx][dy]$ 这个卷积式已经够明显了吧。 接下来要做的就是降维。 dx的范围是[-r,r] , dy的范围是[-r,r]. 所以需要进行下标的偏移，行的长度变为 m + 2r, 列的长度变为 n + 2r. 注意限制条件 $dx^2 + dy^2 &lt; R^2$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e6+6;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/* * 进行FFT和IFFT前的反转变换。 * 位置i和 （i二进制反转后位置）互换 * len必须取2的幂 */void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/* * 做FFT * len必须为2^k形式， * on==1时是DFT，on==-1时是IDFT * DFT:系数表示法-&gt;点值表示法 * IDFT:点值表示法-&gt;系数表示法 */void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; double R; while (~scanf("%d%d%lf", &amp;n, &amp;m, &amp;R)) &#123; int r = ceil(R); int M = max(n, m) + 2 * r; int len = 1; while (len &lt; M * M * 2) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); double u; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; m; k++) scanf("%lf", &amp;u), x1[i * M + k] = Complex(u, 0); &#125; for (int i = -r; i &lt;= r; i++) &#123; for (int k = -r; k &lt;= r; k++) &#123; if (i * i + k * k &lt; R * R) x2[(i + r) * M + k + r] = Complex(1.0 / (sqrt(i * i + k * k) + 1), 0); &#125; &#125; fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); double ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; m; k++) &#123; ans = max(ans, x1[(i + r) * M + r + k].x); &#125; &#125; printf("%.3lf\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu4609-3-idiots]]></title>
    <url>%2F2018%2F08%2F27%2Fhdu4609-3-idiots%2F</url>
    <content type="text"><![CDATA[题意给定n个长度为ai的木棍求，任选三个使其能够组成三角形的概率 $(3≤n≤10^5)$. $(1≤a_i≤105)$ 分析长度比较小，考虑$c[i]$表示长度为i的木棒的个数。$d[i + k] = c[i] * c[k]$ 表示两根木棒组合长度为i+k的种数。 这样可以通过枚举第三边，求得答案。 问题是如何求得d数组， 可以观察到这是一个卷积的形式， 所以可以FFT加速一下。 这些方案里需要去除一些不满足要求(ai为最长边)的 （先排序） 另外两条边两条均&gt;ai，ans-=(n-i)*(n-i-1)/2 另外两条边一条&gt;ai，一条&lt;ai,ans-=(n-i)*(i-1) 另外两条边一条=ai，另一条随意,ans-=n-1代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/* * 进行FFT和IFFT前的反转变换。 * 位置i和 （i二进制反转后位置）互换 * len必须取2的幂 */void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/* * 做FFT * len必须为2^k形式， * on==1时是DFT，on==-1时是IDFT * DFT:系数表示法-&gt;点值表示法 * IDFT:点值表示法-&gt;系数表示法 */void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x[maxn &lt;&lt; 2];ll sum[maxn &lt;&lt; 2], c[maxn], a[maxn], pre[maxn &lt;&lt; 2];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); clr(sum,0); for (int i = 0, x; i &lt; n; i++) scanf("%lld", a + i), ++sum[a[i]]; sort(a, a + n); int len1 = a[n-1] + 1; int len = 1; while (len &lt; len1 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for (int i = 0; i &lt; len1; i++) x[i] = Complex(sum[i], 0); for (int i = len1; i &lt; len; i++) x[i] = Complex(0, 0); fft(x, len, 1); for (int i = 0; i &lt; len; i++) x[i] = x[i] * x[i]; fft(x, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = ll(x[i].x + 0.5); &#125; len = a[n-1] * 2; for(int i=0;i&lt;n;i++) sum[a[i] &lt;&lt; 1]--; for(int i=0;i&lt;=len;i++) sum[i] &gt;&gt;= 1; pre[0] = sum[0]; for (int i = 1; i &lt;= len; i++) &#123; pre[i] = pre[i - 1] + sum[i]; &#125; ll ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans += pre[len] - pre[a[i]]; ans -= n - 1; ans -= 1LL * (n - i - 1) * (i); ans -= 1LL * (n - i - 1) * (n - i - 2) / 2; &#125; ll tmp = 1LL * (n) * (n-1) * (n-2) / 6; printf("%.7lf\n",1.0 * ans/tmp); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计蒜客26219-Rock Paper Scissors Lizard Spock]]></title>
    <url>%2F2018%2F08%2F27%2F%E8%AE%A1%E8%92%9C%E5%AE%A226219-Rock-Paper-Scissors-Lizard-Spock%2F</url>
    <content type="text"><![CDATA[题意给两个只包含大写字母的字符串$s1,s2, (1 \leq s2 \leq s1 \leq 10^6)$，以及一些克制关系。 你需要从$s1$中找一子串$t$，使得$t$与$s2$匹配所得分数最大。 匹配的意思是 :12for(i : 0 -&gt; t.size()) if(s2[i] 克制 t[i]) 分数++ 分析FFT解决字符串匹配的套路题 枚举克制关系 比如A克制B， 那么我将$s1$中所有字符为B的位置都设为1，其余为0。 再将$s2$中所有字符为A的位置都设为1，其余为0 然后跑一遍fft，得到的结果就是sum[i] 就是$s1$中以第i个位置结尾的子串与$s2$的在当前克制关系下的分数。 然后枚举克制关系，把所有的分数加起来，最后再扫一遍取最大值即可（注意i的范围是[s2-1, s1-1]) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e6 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn],b[maxn];int sum[maxn];int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); while(~scanf("%s%s",a,b))&#123; map&lt;char,pair&lt;char,char&gt; &gt; hash; hash['R'] = mp('K','P'); hash['L'] = mp('R','S'); hash['K'] = mp('L','P'); hash['P'] = mp('L','S'); hash['S'] = mp('R','K'); int len1 = strlen(a); int len2 = strlen(b); int len = 1; while(len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; for(int i=0;i&lt;len;i++) sum[i] = 0; for(auto &amp;u:hash)&#123; for(int i=0;i&lt;len;i++) x1[i] = Complex(0,0), x2[i] = Complex(0,0); for(int i=0;i&lt;len1;i++) if(a[i] == u.first) x1[len1 - i - 1] = Complex(1,0); for(int i=0;i&lt;len2;i++) if(b[i] == u.second.first || b[i] == u.second.second) x2[i] = Complex(1,0); fft(x1,len,1); fft(x2,len,1); for(int i=0;i&lt;len;i++) x1[i] = x1[i] * x2[i]; fft(x1,len,-1); for(int i=0;i&lt;len;i++) sum[i] += int(x1[i].x + 0.5); &#125; int ans = 0; for(int i=0;i&lt;len;i++) ans = max(ans, sum[i]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu1402 大数相乘]]></title>
    <url>%2F2018%2F08%2F26%2Fhdu1402-%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[题意大数相乘 分析FFT模板题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%s%s", &amp;a, &amp;b)) &#123; int len1 = strlen(a); int len2 = strlen(b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for (int i = 0; i &lt; len1; i++) x1[i] = Complex(a[len1 - 1 - i] - '0', 0); for (int i = len1; i &lt; len; i++) x1[i] = Complex(0, 0); for (int i = 0; i &lt; len2; i++) x2[i] = Complex(b[len2 - 1 - i] - '0', 0); for (int i = len2; i &lt; len; i++) x2[i] = Complex(0, 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = int(x1[i].x + 0.5); &#125; for (int i = 0; i &lt; len; i++) &#123; sum[i + 1] += sum[i] / 10; sum[i] %= 10; &#125; len = len1 + len2 - 1; while (sum[len] == 0 &amp;&amp; len &gt; 0) len--; for (int i = len; i &gt;= 0; i--) printf("%d", sum[i]); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FFT]]></title>
    <url>%2F2018%2F08%2F26%2FFFT%2F</url>
    <content type="text"><![CDATA[FFT离散傅里叶变化主要是用来做信号分析的，ACM中主要用来加速求多项式乘积 学习博客 系数表示法与点值表示法$f(x) = ax^2 + bx^1 + c$ 系数表示法 $f(x) = {a,b,c}$ 点值表示法 $f(x) =[ (x_0,f(x_0)),(x_1,f(x_1)),(x_2, f(x_2)) ]$ (n个未知数的方程可以用n个解求得) DFT : 多项式由系数表示法 转为 点值表示法的过程 IDFT : 多项式由点值表示法 转为 系数表示法的过程 如果我要求一个多项式 $F(x) = f(x) \times g(x)$ 可以用点值表示法来表示 $F(x) = [ (x_0, f(x_0) \times g(x_0)), (x_1,f(x_1) \times g(x_1) )… ]$ 至此如何求一个多项式的乘积我们大概有了思路： 将$f(x)$ 与$g(x)$ 转化为点值表达式， 然后对应项相乘，得到$F(x)$的点值表达式 将$F(x)$转化为系数表达式 DFT怎么将点值表达式转化为系数表达式呢? 这里引入了单位复根，使得不用去计算$x_i$，从而加速了DFT的过程。 只要知道 单位复根的多少次幂都是1即可。由于还不会高斯消元..所以这部分先搁置一下。 分治思想加速DFTFFT快在它利用了分治的思想加速了DFT的过程，即第一步. 对于一个多项式$f(x) = y_0 = a_0 + a_1x +a_2x^2+a_3x^3 + a_4x^4 + a_5x^5$ 然后将奇偶项分开处理 $f(x) = (a_0 + a_2x^2 + a_4x^4) + x(x_1 + a_3x^2 + a_5x^4)$ 设 $G(x) = a_0 + a_2x + a_4x^2$ $H(x) = a_1 + a_3x + a_5x^2$ 那么$f(x) = G(x^2) + xH(x^2)$ 需要注意的是$f(x)$的项数必须为2的幂次，不然在分治的时候会造成奇偶项数不相等. 所以我们需要提前预处理，将$f(x)$的项数扩大到2的幂次，多余的项数补0. IDFT看博客吧.. 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace fft &#123;typedef double db;struct cp &#123; db x, y; cp() &#123; x = y = 0; &#125; cp(db x, db y) : x(x), y(y) &#123;&#125;&#125;;inline cp operator+(cp a, cp b) &#123; return cp(a.x + b.x, a.y + b.y); &#125;inline cp operator-(cp a, cp b) &#123; return cp(a.x - b.x, a.y - b.y); &#125;inline cp operator*(cp a, cp b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;inline cp conj(cp a) &#123; return cp(a.x, -a.y); &#125;int base = 1;vector&lt;cp&gt; roots = &#123;&#123;0, 0&#125;, &#123;1, 0&#125;&#125;;vector&lt;int&gt; rev = &#123;0, 1&#125;;const db PI = acosl(-1.0);void ensure_base(int nbase) &#123; if (nbase &lt;= base) return; rev.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); for (int i = 0; i &lt; (1 &lt;&lt; nbase); i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1)); roots.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); while (base &lt; nbase) &#123; db angle = 2 * PI / (1 &lt;&lt; (base + 1)); for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) &#123; roots[i &lt;&lt; 1] = roots[i]; db angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base)); roots[(i &lt;&lt; 1) + 1] = cp(cos(angle_i), sin(angle_i)); &#125; base++; &#125;&#125;void fft(vector&lt;cp&gt;&amp; a, int n = -1) &#123; if (n == -1) n = a.size(); assert((n &amp; (n - 1)) == 0); int zeros = __builtin_ctz(n); ensure_base(zeros); int shift = base - zeros; for (int i = 0; i &lt; n; i++) if (i &lt; (rev[i] &gt;&gt; shift)) swap(a[i], a[rev[i] &gt;&gt; shift]); for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += 2 * k) for (int j = 0; j &lt; k; j++) &#123; cp z = a[i + j + k] * roots[j + k]; a[i + j + k] = a[i + j] - z; a[i + j] = a[i + j] + z; &#125;&#125;vector&lt;cp&gt; fa, fb;vector&lt;int&gt; multiply(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int need = a.size() + b.size() - 1; int nbase = 0; while ((1 &lt;&lt; nbase) &lt; need) nbase++; ensure_base(nbase); int sz = 1 &lt;&lt; nbase; if (sz &gt; (int)fa.size()) fa.resize(static_cast&lt;unsigned long&gt;(sz)); for (int i = 0; i &lt; sz; i++) &#123; int x = (i &lt; (int)a.size() ? a[i] : 0); int y = (i &lt; (int)b.size() ? b[i] : 0); fa[i] = cp(x, y); &#125; fft(fa, sz); cp r(0, -0.25 / sz); for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) &#123; int j = (sz - i) &amp; (sz - 1); cp z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r; if (i != j) &#123; fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r; &#125; fa[i] = z; &#125; fft(fa, sz); vector&lt;int&gt; res(static_cast&lt;unsigned long&gt;(need)); for (int i = 0; i &lt; need; i++) &#123; res[i] = fa[i].x + 0.5; &#125; return res;&#125;&#125;; // namespace fft 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%s%s", &amp;a, &amp;b)) &#123; int len1 = strlen(a); int len2 = strlen(b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for(int i=0;i&lt;len;i++)&#123; sum[i] = 0; x1[i] = Complex(0, 0); x2[i] = Complex(0, 0); &#125; for (int i = 0; i &lt; len1; i++) x1[i] = Complex(a[i] - '0', 0); for (int i = 0; i &lt; len2; i++) x2[i] = Complex(b[i] - '0', 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = int(x1[i].x + 0.5); &#125; while (sum[len] == 0 &amp;&amp; len &gt; 0) len--; for (int i = 0; i &lt;= len; i++) printf("%d", sum[i]); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分数规划]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[借鉴博客 01分数规划问题有一堆物品，每一个物品有一个收益$ai$，一个代价$bi$，我们要求一个方案使选择的$\frac{\sum a_i}{\sum b_i}$ 最大 思想式子变形后得 $\sum a_i - x \times \sum b_i \geq 0$ 那么可以二分$x$, 然后排序check即可。 最优比率生成树问题图上每条边有两个权值$cost, len$, 求一个生成树，使得$\frac{\sum cost_i}{\sum len_i} \geq x$ 思想二分答案，每条边的边权变为$cost - x \times len$, 跑最小生成树check 最优比率生成环问题图上有点权和边权,求一个回路使得点权和比边权和最大 思想把边权看做花费，点权看做收入。 然后二分答案建图，判正环。 判正环可以转化为权值取负判负环。]]></content>
      <categories>
        <category>ACM</category>
        <category>分数规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018牛客多校赛第五场]]></title>
    <url>%2F2018%2F08%2F03%2F2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%BA%94%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[A-gpa题意有n个课程，每个课程的学分是s[i],相应的绩点是c[i], 现在要去掉k门课，使得$\frac{\sum s[i]c[i]}{\sum s[i]}$ 最大 1≤ n≤ 105 0≤ k &lt; n 1≤ s[i],c[i] ≤ 103 分析分数规划问题 二分答案D，那么对于D有 $\sum si \geq 0$ 浮点数二分这个答案，然后nlogn检查 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const double eps = 1e-6;int c[maxn], s[maxn], id[maxn];int n, k;double ans;bool check(double x) &#123; vector&lt;double&gt; foo(n); for (int i = 0; i &lt; n; i++) foo[i] = s[i] * (c[i] - x); sort(foo.begin(), foo.end(), greater&lt;double&gt;()); double ret = 0; for (int i = 0; i &lt; n - k; i++) &#123; ret += foo[i]; &#125; return ret &gt; 0;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;s[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;c[i]); double l = 0, r = 1e3 + 4; while (fabs(r - l) &gt; eps) &#123; // 这里也可以写成循环50次 double mid = (l + r) / 2; if (check(mid)) &#123; ans = mid; l = mid; &#125; else r = mid; &#125; printf("%.8lf\n", ans);&#125; B-div题意一个数 n 是好的，当且仅当 n^4 在 [n^2+1,n^2+2n] 之间有一个约数给定 m，求&gt;=m 的最小的好的 n 1&lt;=m&lt;=10^(1000) 分析代码123456789101112131415# your code goes herem = int(input())a = [0,2,0]i = 1while(a[i] &lt; m): i = (i + 1) % 3 a[i] = a[(i-1 + 3) % 3] * 6 - a[(i-2+3) % 3]ans = a[i]i = 1a = [0,6,0]while(a[i] &lt; m): i = (i + 1) % 3 a[i] = a[(i-1 + 3) % 3] * 14 - a[(i-2+3) % 3]ans = min(ans,a[i])print(ans) I-vcd题意有 n 个点，一个点集 S 是好的，当且仅当对于他的每个子集 T，存在一个右边无限长的矩形，使得这个矩形包含了 T，但是和 S-T 没有交求这 n 个点里有几个好的点集 1&lt;=n&lt;=10^5 分析对于 |S|=1，他显然是好的 对于 |S|=2，只要两个点的 y 坐标不相同，那么这个集合也是好的 对于 |S|=3，三个点的形状必须是 &lt; 型 对于 |S|&gt;3，不可能任何三个点都是 &lt; 型，所以一定不是好的 主要是对于|S|=3情况的统计 对于一个点(x,y),我们需要知道{(x1,y1) | x1 &gt; x, y1 &gt; y}的个数，和{(x1,y1) | x1 &gt; x, y1 &lt; y}的个数 这两个数相乘就是(x,y)对答案的贡献。 其实这个只要倒着统计，因为倒着统计就可以保证(x1 &gt; x) 这个条件，然后用权值树状数组每次查大于y的数量和小于y的数量。 注意横坐标相等的情况是不合法的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 998244353;struct P &#123; int x, y; bool operator&lt;(const P&amp; A) const &#123; if (x == A.x) return y &lt; A.y; return x &lt; A.x; &#125;&#125;;P p[maxn];int BIT[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l, int r) &#123; int ret = 0; for (int i = l - 1; i &gt; 0; i -= lowb(i)) ret -= BIT[i]; for (int i = r; i &gt; 0; i -= lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x, int y, int n) &#123; for (int i = x; i &lt;= n; i += lowb(i)) BIT[i] += y;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (~scanf("%d", &amp;n)) &#123; vector&lt;int&gt; x(n), y(n), tx(x), ty(n); map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;x[i], &amp;y[i]); tx[i] = x[i]; ty[i] = y[i]; &#125; my_sort_unique(x); my_sort_unique(y); for (int i = 0; i &lt; n; i++) &#123; p[i].x = lower_bound(x.begin(), x.end(), tx[i]) - x.begin() + 1; p[i].y = lower_bound(y.begin(), y.end(), ty[i]) - y.begin() + 1; cnt[p[i].y]++; &#125; ll ans = 0; for (auto&amp; v : cnt) &#123; ans += 1LL * (n - v.second) * v.second; &#125; ans /= 2; ans = (ans + n) % mod; clr(BIT, 0); sort(p, p + n); int last = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; int l = query(1, p[i].y - 1); int r = (n - i - 1 - query(1, p[i].y)); if (i &lt; n - 1 &amp;&amp; p[i].x == p[i + 1].x) last++; else last = 0; ans += 1LL * l * (r - last); ans %= mod; // while (ans &gt;= mod) ans -= mod; update(p[i].y, 1, maxn - 1); &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018hdu多校第四场]]></title>
    <url>%2F2018%2F08%2F02%2F2018hdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[B. Harvest of Apples题意There are n apples on a tree, numbered from 1 to n. Count the number of ways to pick at most m apples. $1 \leq T \leq 1e5, 1 \leq n,m \leq 1e5$ 分析设$S(n,m) = \sum_{i=1}^{m}C(n,i)$ 然后有转移$S(n,m) = 2S(n-1,m) - C(n-1,m) = S(n,m-1) + C(n,m)$ 然后就莫队瞎搞搞… 注意分块排序时候的m要从小到大，不然会有n &lt; m的情况出现。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;int S;struct Node &#123; int n, m, id; ll ans;&#125;;bool cmp(const Node&amp; A, const Node&amp; B) &#123; if (A.n / S == B.n / S) return A.m &lt; B.m; // 注意大小 return A.n / S &lt; B.n / S;&#125;Node a[maxn];ll f[maxn], inv[maxn];ll Pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;void CalFact() &#123; f[0] = 1; for (int i = 1; i &lt; maxn; i++) f[i] = (f[i - 1] * i) % mod; inv[maxn - 1] = Pow(f[maxn - 1], mod - 2); for (int i = maxn - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;&#125;inline ll C(int n, int m) &#123; return f[n] * inv[m] % mod * inv[n - m] % mod; &#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); CalFact(); int n; scanf("%d", &amp;n); S = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].n, &amp;a[i].m); a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); int nn = 1, mm = 0; ll ans = 1; for (int i = 1; i &lt;= n; i++) &#123; while (nn &lt; a[i].n) &#123; ans = (2 * ans % mod - C(nn, mm) + mod) % mod; nn++; &#125; while (nn &gt; a[i].n) &#123; nn--; ans = (ans + C(nn, mm)) * inv[2] % mod; &#125; while (mm &lt; a[i].m) &#123; mm++; ans = (ans + C(nn, mm)) % mod; &#125; while (mm &gt; a[i].m) &#123; ans = (ans - C(nn, mm) + mod) % mod; mm--; &#125; a[i].ans = ans; &#125; sort(a + 1, a + 1 + n, [](const Node&amp; A, const Node&amp; B) &#123; return A.id &lt; B.id; &#125;); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld\n", a[i].ans); &#125;&#125; D. Nothing is Impossible出题人锅了，虽然后面改了题意，但也不想再看了… 贴一发当时AC的代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 105;struct P&#123; int x,y; bool operator &lt; (const P&amp; A) const&#123; return y &lt; A.y; &#125;&#125;;P a[maxn];int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d",&amp;T); while(T--)&#123; ll n, m; scanf("%lld%lld",&amp;n,&amp;m); int ans = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;a[i].x, &amp;a[i].y); if(a[i].y == 0 &amp;&amp; a[i].x != 0) ans++; &#125; sort(a,a+n); ll foo = 1; for(int i=0;i&lt;n;i++)&#123; if(a[i].x == 0 || a[i].y == 0) continue; foo *= (a[i].y + 1); if(foo &gt; m) break; ans++; &#125; printf("%d\n",ans); &#125;&#125; E. Matrix from Arrays题意1234567int cursor = 0;for (int i = 0; ; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; M[j][i - j] = A[cursor]; cursor = (cursor + 1) % L; &#125;&#125; 用上述方法构造一个无限大的矩阵，然后若干个查询，每次查询求子矩阵的和。 分析比赛时是打表发现了规律，即对于L为奇数，那么它纵向和横向都存在循环节，且循环节长度为L。对于L为偶数，同样存在循环节，只不过长度为2L。 然后就可以预处理前缀和，然后计算子矩阵的和。 小技巧是可以把循环节长度统一定为2L,这样就不用分类讨论了。 题解里面推导了一下 $M[i][k] = A[\frac{(1+i+k)(i+k)}{2} + 2 \quad mod \quad L] = M[i+2L][k] = M[i][k+2L]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 150;int A[30];int M[maxn][maxn];ll sum[maxn][maxn];void init(int L) &#123; int sz = 100, p = 0; for (int i = 0; i &lt; sz; i++) &#123; for (int k = 0; k &lt;= i; k++) &#123; M[k][i - k] = A[p]; p = (p + 1) % L; &#125; &#125; for (int i = 1; i &lt;= L * 2; i++) &#123; for (int k = 1; k &lt;= L * 2; k++) &#123; sum[i][k] = M[i - 1][k - 1] + sum[i - 1][k] + sum[i][k - 1] - sum[i - 1][k - 1]; &#125; &#125;&#125;ll solve(int x, int y, int L) &#123; ll ret = 0; ret += sum[L][L] * (x / L) * (y / L); ret += sum[L][y % L] * (x / L); ret += sum[x % L][L] * (y / L); ret += sum[x % L][y % L]; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int L, Q; scanf("%d", &amp;L); for (int i = 0; i &lt; L; i++) scanf("%d", A + i); init(L); L &lt;&lt;= 1; scanf("%d", &amp;Q); int x0, y0, x1, y1; while (Q--) &#123; scanf("%d%d%d%d", &amp;x0, &amp;y0, &amp;x1, &amp;y1); x0++, y0++, x1++, y1++; ll ans = 0; ans += solve(x1, y1, L); ans -= solve(x1, y0 - 1, L); ans -= solve(x0 - 1, y1, L); ans += solve(x0 - 1, y0 - 1, L); printf("%lld\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uva11796-Dog Distance-两点运动时的最短距离与最长距离]]></title>
    <url>%2F2018%2F08%2F02%2Fuva11796-Dog-Distance-%E4%B8%A4%E7%82%B9%E8%BF%90%E5%8A%A8%E6%97%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9C%80%E9%95%BF%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题意甲和乙两条狗分别沿着不同的折线奔跑。两只狗的速度未知，但已知它们同时出发，同时到达，并且都是匀速奔跑。 你的任务是求出甲和乙在奔跑过程中的最远距离和最近距离的差。 分析先将问题简化，甲和乙的路线是一条线段。 因为运动是相对的，所以可以把甲看做静止，这样问题就转化成了点到线段的最短距离与最长距离。 接下来要做的就是模拟整个过程。设现在甲的位置是Pa，刚经过编号为Sa的拐点； 乙同理。 那么我们只需要谁先到达拐点，在这个时间点之前的问题其实就是问题的简化版。 求解完后要分别更新甲和乙的位置，如果正好到达下一个拐点，还要更新Sa或Sb。 时间复杂度O(n) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 100;const double eps = 1e-10;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double DistanceToSegment(Point P, Point A, Point B) &#123; if (A == B) return Length(P - A); Vec v1 = B - A, v2 = P - A, v3 = P - B; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;Point a[maxn], b[maxn];double Min, Max;void update(Point P, Point A, Point B) &#123; Min = min(Min, DistanceToSegment(P, A, B)); Max = max(Max, Length(P - A)); Max = max(Max, Length(P - B));&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int A, B; scanf("%d%d", &amp;A, &amp;B); for (int i = 0; i &lt; A; i++) scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); for (int i = 0; i &lt; B; i++) scanf("%lf%lf", &amp;b[i].x, &amp;b[i].y); double LenA = 0, LenB = 0; for (int i = 0; i &lt; A - 1; i++) LenA += Length(a[i + 1] - a[i]); for (int i = 0; i &lt; B - 1; i++) LenB += Length(b[i + 1] - b[i]); int Sa = 0, Sb = 0; Point Pa = a[0], Pb = b[0]; Min = 1e9, Max = 1e-9; while (Sa &lt; A - 1 &amp;&amp; Sb &lt; B - 1) &#123; double La = Length(a[Sa + 1] - Pa); double Lb = Length(b[Sb + 1] - Pb); double T = min(La / LenA, Lb / LenB); // 速度假设为LenA，LenB Vec Va = (a[Sa + 1] - Pa) / La * T * LenA; // 位移向量 Vec Vb = (b[Sb + 1] - Pb) / Lb * T * LenB; update(Pa, Pb, Pb + Vb - Va); Pa = Pa + Va; Pb = Pb + Vb; if (Pa == a[Sa + 1]) Sa++; if (Pb == b[Sb + 1]) Sb++; &#125; printf("Case %d: %.0f\n", kase++, Max - Min); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uvalive3263-That Nice Euler Circuits-欧拉定理]]></title>
    <url>%2F2018%2F08%2F02%2Fuvalive3263-That-Nice-Euler-Circuits-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[题意平面上有一个包含n个端点的一笔画，第n个端点总是与第一个端点重合，因此图案是一条闭合的折线。线段之间可以相交，但是不会重叠。求这些线段将平面分成几个部分？ 分析欧拉定理：顶点数 + 面数 = 边数 + 2 那么只要求顶点数和边数即可。 需要注意的是： 对于重复的点不能算，比如三线共点 点增加了，边也会增加。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double eps = 1e-10;const int maxn = 305;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;bool OnSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;Point p[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, kase = 1; while (~scanf("%d", &amp;n)) &#123; if (!n) break; set&lt;Point&gt; vtx; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); vtx.insert(p[i]); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; for (int k = i + 1; k &lt; n - 1; k++) &#123; if (SegmentProperIntersection(p[i], p[i + 1], p[k], p[k + 1])) &#123; vtx.insert(GetLineItersection(p[i], p[i + 1] - p[i], p[k], p[k + 1] - p[k])); &#125; &#125; &#125; int e = n - 1; for (auto i : vtx) &#123; for (int k = 0; k &lt; n - 1; k++) &#123; if (OnSegment(i, p[k], p[k + 1])) e++; &#125; &#125; int ans = e + 2 - vtx.size(); printf("Case %d: There are %d pieces.\n", kase++, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uva11178-Morley's Theorem角平分线交点]]></title>
    <url>%2F2018%2F08%2F02%2Fuva11178-Morley-s-Theorem%E8%A7%92%E5%B9%B3%E5%88%86%E7%BA%BF%E4%BA%A4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题意Morley定理：作三角形ABC每个内角的三等分线，相交成三角形DEF，则DEF是等边三角形。 任务是根据A，B，C三点的位置，确定D，E，F的位置。 保证A，B，C面积非0，且按逆时针给出。 分析 求出一个内角 将某条边旋转1/3倍的内角 然后求两直线交点 代码复用要好好学学 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;Vec Rotate(Vec A, double rad) &#123; // 向量绕起点逆时针旋转rad return Vec(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;// 调用前要确保直线P + tv和Q + tw有唯一交点，当且仅当Cross(v,w)!=0Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Point p[5];Point GetP(int a, int b, int c) &#123; Vec v1 = p[c] - p[b]; double ang = Angle(p[a] - p[b], v1); v1 = Rotate(v1, ang / 3); Vec v2 = p[a] - p[c]; ang = Angle(p[b] - p[c], v2); v2 = Rotate(v2, 2 * ang / 3); return GetLineItersection(p[b], v1, p[c], v2);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; for (int i = 0; i &lt; 3; i++) &#123; scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); &#125; Point D, E, F; D = GetP(0, 1, 2); E = GetP(1, 2, 0); F = GetP(2, 0, 1); printf("%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\n", D.x, D.y, E.x, E.y, F.x, F.y); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算几何基础]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础知识极坐标在平面内取一个定点$O$，叫极点，引一条射线$Ox$，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点$M$，用$ρ$表示线段$OM$的长度（有时也用$r$表示），$θ$表示从$Ox$到$OM$的角度，$ρ$叫做点$M$的极径，$θ$叫做点$M$的极角，有序数对$(ρ,θ)$就叫点$M$的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，$M$的极径坐标单位为$1$（长度单位），极角坐标单位为$rad$（或°）。 与直角坐标的变换 $r = \sqrt{y^2 + x^2}$ $\theta = atan2(y,x)$ atan2是已将象限纳入考量的反正切函数,单位是弧度。 三角形余弦公式$c = \sqrt{a^2 + b^2 - 2ab\times cos(C)}$ $cos(C) = \frac{a^2 + b^2 - c^2}{2ab}$ 正弦公式$\frac{a}{sin(A)} = \frac{b}{sin(B)} = \frac{c}{sin(C)} = 2R = D$ 向量的减法$\vec{c} = \vec{a} + (-\vec{b})$ 数量积(点乘)$\vec{a} \cdot \vec{b} = |\vec{a}| \cdot |\vec{b}| \cdot cos(\theta) = a_x \cdot b_x + a_y \cdot b_y$ $0 \leq \theta \leq \pi $ 作用： 可以用来求两向量的夹角。 $\vec{a} \cdot \vec{b} &lt; 0$ 夹角在$[90,180)$度内 $\vec{a} \cdot \vec{b} = 0$ 两向量垂直 $\vec{a} \cdot \vec{b} &gt; 0$ 夹角在$[0,90)$度内 向量积(叉积)简单地说，两个向量$\vec{v}$和$\vec{w}$的叉积等于$\vec{v}$和$\vec{w}$组成的三角形的有向面积的两倍。 如果$\vec{w}$在$\vec{v}$的左边，那么$cross(v,w) &gt; 0$ $|\vec{a} \times \vec{b}| = x_a \times y_b - x_b \times y_a$ $\vec{c} = \vec{a} \times \vec{b}$ $|\vec{c}| = |\vec{a}| \cdot |\vec{b}| \cdot sin(\theta)$ $0 \leq \theta \leq \pi $ 其中$\vec{c}$垂直于$\vec{a},\vec{b}$所组成的平面，满足右手定则。 几何意义： 以$\vec{a},\vec{b}$为棱的平行四边形面积。 那么多边形面积就可以通过叉积求出。 一般意义上，竖直向上的符号为正。 $\vec{a} \times \vec{b} = \left| \begin{array}{ccc}\vec{i} &amp; \vec{j} &amp; \vec{k}\\a_x &amp; a_y &amp; a_z\\b_x &amp; b_y &amp; b_z\\\end{array} \right|= (a_y \cdot b_z - a_z \cdot b_y) \cdot \vec{i} + (-a_x \cdot b_z + a_z \cdot b_x) \cdot \vec{j} + (a_x \cdot b_y - a_y \cdot b_x) \cdot \vec{k}$ 混合积$\vec{a} \cdot (\vec{b} \times \vec{c}) = \left| \begin{array}{ccc}a_x &amp; a_y &amp; a_z\\b_x &amp; b_y &amp; b_z\\c_x &amp; c_y &amp; c_z\\\end{array} \right|$ 证明： 几何意义为： 以$\vec{a},\vec{b},\vec{c}$为棱的平行六面体的体积。 Pick定理设以整数点为顶点的多边形的面积为S，多边形内部的整数点数为N，多边形边界上的整数点为L，则 S = L/2 + N - 1. 重要定理三点共线定理已知O是AB所在直线外一点，若$\vec{OC} = \lambda \cdot \vec{OA} + \mu \cdot \vec{OB}$, 且$\lambda + \mu = 1$，则A，B，C三点共线。 实际判断其实是用： $\vec{AB} \times \vec{AC} = 0 $，则三点共线 重心判断式在$\Delta ABC$中，若$\vec{GA} + \vec{GB} + \vec{GC} = 0$，则G为$\Delta ABC$的重心。 重心： 三边中线的交点。 垂心判断式在$\Delta ABC$中，若$\vec{HA} \cdot \vec{HB} = \vec{HB} \cdot \vec{HC} = \vec{HC} \cdot \vec{HA}$，则H为$\Delta ABC$的垂心。 将三角形分成了面积相等的三块。 外心判断式在$\Delta ABC$中，若$\vec{OA} = \vec{OB} = \vec{OC} $，则O为$\Delta ABC$的外心。 外心： 垂直平分线的交点。 模板详解判断点是否在线段（直线）上其实就是三点共线的问题，解决办法是判断$\vec{AC} \times \vec{AB} = 0$. 但因为是线段，所以要判断横纵坐标的相应位置。 判断两线段是否相交这里有两个实验：第一个是快速排斥实验，通过判断相应矩形是否相交来快速得到两线段是否相交。 但可以发现，这不能包含所有情况，因为两个矩形相交不一定能推出两条线段相交。 因此就有了跨立实验。 跨立，顾名思义，就是一条线所在的直线能够切开另一条线段。 如上面两个图，Q1，Q2所在直线可以跨立P1，P2线段； 但P1，P2所在直线无法跨立Q1，Q2线段， 因此两条线段不相交。 所以判断两条线段相交需要同时满足两条线段互相跨立的条件。 判断点在多边形中射线法： 设要判断的点为P. 以P点为起点，水平向左做一条射线，根据射线与多边形的交点个数来判断P是否在多边形内部。 如果交点个数是奇数的话，说明P点在多边形内部。 但是！ 会有一些特殊情况：比如图(b),若射线与多边形的交点是顶点的话，需要判断。 总的来说，步骤如下： 遍历多边形的每一条边： 如果P在多边形边上，可直接判断。 如果射线与多边形的边重合，那么可以直接忽略。 如果射线和多边形的一边有交点，那么交点数加一。(不包括顶点) 如果交点是顶点，那么如果这个顶点是该线段上纵坐标较大的顶点，则交点数加一。 否则不作数。 判断线段是否在多边形内不会 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#define zero(x) ((fabs(x) &lt; eps ? 1 : 0))#define sgn(x) (fabs(x) &lt; eps ? 0 : ((x) &lt; 0 ? -1 : 1))struct point&#123; double x, y; point(double a = 0, double b = 0) &#123; x = a, y = b; &#125; point operator-(const point&amp; b) const &#123; return point(x - b.x, y - b.y); &#125; point operator+(const point&amp; b) const &#123; return point(x + b.x, y + b.y); &#125; // 两点是否重合 bool operator==(point&amp; b) &#123; return zero(x - b.x) &amp;&amp; zero(y - b.y); &#125; // 点积(以原点为基准) double operator*(const point&amp; b) const &#123; return x * b.x + y * b.y; &#125; // 叉积(以原点为基准) double operator^(const point&amp; b) const &#123; return x * b.y - y * b.x; &#125; // 绕P点逆时针旋转a弧度后的点 point rotate(point b, double a) &#123; double dx, dy; (*this - b).split(dx, dy); double tx = dx * cos(a) - dy * sin(a); double ty = dx * sin(a) + dy * cos(a); return point(tx, ty) + b; &#125; // 点坐标分别赋值到a和b void split(double&amp; a, double&amp; b) &#123; a = x, b = y; &#125;&#125;;struct line&#123; point s, e; line() &#123;&#125; line(point ss, point ee) &#123; s = ss, e = ee; &#125;&#125;;double dist(point a, point b) &#123; return sqrt((a - b) * (a - b)); &#125;// &lt;0, *&gt; 表示重合; &lt;1, *&gt; 表示平行; &lt;2, P&gt; 表示交点是P;pair&lt;int, point&gt; spoint(line l1, line l2)&#123; point res = l1.s; if (sgn((l1.s - l1.e) ^ (l2.s - l2.e)) == 0) return make_pair(sgn((l1.s - l2.e) ^ (l2.s - l2.e)) != 0, res); double t = ((l1.s - l2.s) ^ (l2.s - l2.e)) / ((l1.s - l1.e) ^ (l2.s - l2.e)); res.x += (l1.e.x - l1.s.x) * t; res.y += (l1.e.y - l1.s.y) * t; return make_pair(2, res);&#125;// 快速排斥实验 + 跨立实验bool segxseg(line l1, line l2)&#123; return max(l1.s.x, l1.e.x) &gt;= min(l2.s.x, l2.e.x) &amp;&amp; max(l2.s.x, l2.e.x) &gt;= min(l1.s.x, l1.e.x) &amp;&amp; max(l1.s.y, l1.e.y) &gt;= min(l2.s.y, l2.e.y) &amp;&amp; max(l2.s.y, l2.e.y) &gt;= min(l1.s.y, l1.e.y) &amp;&amp; sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e-l1.e) ^ (l1.s - l1.e)) &lt;= 0 &amp;&amp; sgn((l1.s - l2.e) ^ (l2.s - l2.e)) * sgn((l1.e-l2.e) ^ (l2.s - l2.e)) &lt;= 0;&#125;//l1是直线,l2是线段bool segxline(line l1, line l2)&#123; return sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e - l1.e) ^ (l1.s - l1.e)) &lt;= 0;&#125;point pointtoline(point P, line L)&#123; point res; double t = ((P - L.s) * (L.e - L.s)) / ((L.e - L.s) * (L.e - L.s)); res.x = L.s.x + (L.e.x - L.s.x) * t, res.y = L.s.y + (L.e.y - L.s.y) * t; return dist(P, res);&#125;point pointtosegment(point p, line l)&#123; point res; double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s)); if (t &gt;= 0 &amp;&amp; t &lt;= 1) res.x = l.s.x + (l.e.x - l.s.x) * t, res.y = l.s.y + (l.e.y - l.s.y) * t; else res = dist(p, l.s) &lt; dist(p, l.e) ? l.s : l.e; return res;&#125;bool PointOnSeg(point p, line l)&#123; return sgn((l.s - p) ^ (l.e-p)) == 0 &amp;&amp; sgn((p.x - l.s.x) * (p.x - l.e.x)) &lt;= 0 &amp;&amp; sgn((p.y - l.s.y) * (p.y - l.e.y)) &lt;= 0;&#125;double area(point p[], int n)&#123; double res = 0; for (int i = 0; i &lt; n; i++) res += (p[i] ^ p[(i + 1) % n]) / 2; return fabs(res);&#125;// 点形成一个凸包, 而且按逆时针排序(如果是顺时针把里面的&lt;0改为&gt;0)// 点的编号 : [0,n)// -1 : 点在凸多边形外// 0 : 点在凸多边形边界上// 1 : 点在凸多边形内int PointInConvex(point a, point p[], int n)&#123; for (int i = 0; i &lt; n; i++) if (sgn((p[i] - a) ^ (p[(i + 1) % n] - a)) &lt; 0) return -1; else if (PointOnSeg(a, line(p[i], p[(i + 1) % n]))) return 0; return 1;&#125;// 射线法,poly[]的顶点数要大于等于3,点的编号0~n-1// -1 : 点在多边形外// 0 : 点在多边形边界上// 1 : 点在多边形内int PointInPoly(point p, point poly[], int n)&#123; int cnt; line ray, side; cnt = 0; ray.s = p; ray.e.y = p.y; ray.e.x = -100000000000.0; // -INF,注意取值防止越界 for (int i = 0; i &lt; n; i++) &#123; side.s = poly[i], side.e = poly[(i + 1) % n]; if (PointOnSeg(p, side)) return 0; //如果平行轴则不考虑 if (sgn(side.s.y - side.e.y) == 0) continue; if (PointOnSeg(sid e.s, ray)) cnt += (sgn(side.s.y - side.e.y) &gt; 0); else if (PointOnSeg(side.e, ray)) cnt += (sgn(side.e.y - side.s.y) &gt; 0); else if (segxseg(ray, side)) cnt++; &#125; return cnt % 2 == 1 ? 1 : -1;&#125;// 线段上整数点个数int OnSegment(line l) &#123; return __gcd(fabs(l.s.x - l.e.x), fabs(l.s.y - l.e.y)) + 1; &#125;//多边形边界上整数点个数int OnEdge(point p[], int n)&#123; int i, ret = 0; for (i = 0; i &lt; n; i++) ret += __gcd(fabs(p[i].x - p[(i + 1) % n].x), fabs(p[i].y - p[(i + 1) % n].y)); return ret;&#125;//多边形内部整数点个数int InSide(point p[], int n)&#123; int i, area = 0; for (i = 0; i &lt; n; i++) area += p[(i + 1) % n].y * (p[i].x - p[(i + 2) % n].x); return (fabs(area) - OnEdge(n, p)) / 2 + 1;&#125;point waixin(point a, point b, point c)&#123; double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2; double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2; double d = a1 * b2 - a2 * b1; return point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 刘老师的板子const double eps = 1e-10;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double Area2(Point A, Point B, Point C) &#123; // 平行四边形面积 return Cross(B - A, C - A);&#125;Vec Rotate(Vec A, double rad) &#123; // 向量绕起点逆时针旋转rad return Vec(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;// 向量的单位法线，即左转90度后把长度归一化（要确保A不是零向量）Vec Normal(Vec A) &#123; double L = Length(A); return Vec(-A.y / L, A.x / L);&#125;// 两直线交点，调用前要确保直线P + tv和Q + tw有唯一交点，当且仅当Cross(v,w)!=0Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;// P 到直线AB的距离double DistanceToLine(Point P, Point A, Point B) &#123; Vec v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2) / Length(v1)); // 如果不取绝对值，得到的是有向距离&#125;double DistanceToSegment(Point P, Point A, Point B) &#123; if (A == B) return Length(P - A); Vec v1 = B - A, v2 = P - A, v3 = P - B; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;// 求点与线段距离的交点Point GetLineProjection(Point P, Point A, Point B) &#123; Vec v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125;// 规范相交： 两线段只有一个交点，且不在任何一条线段的断点bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;// 点是否在线段上(不包括端点)bool OnSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;// 多边形的有向面积double PolygonArea(Point* p, int n) &#123; double area = 0; for (int i = 1; i &lt; n - 1; i++) area += Cross(p[i] - p[0], p[i + 1] - p[0]); return area / 2;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018hdu多校第三场]]></title>
    <url>%2F2018%2F07%2F30%2F2018hdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[A. Ascending Rating题意给定一个序列 a[1..n]，对于每个长度为 m 的连续子区间，求出区间 a 的最大值以及从左往右扫描该区间时 a 的最大值的变化次数。 $1 \leq n,m\leq 1e7$ 分析滑动窗口最大值是单调队列的经典问题，但是最大值的变化次数怎么求？ 反着扫，队列的大小就是当前区间的最大值变化次数。 为什么呢？ 因为单调队列维护的是一个递减的数列，队首是当前区间的最大值，那么从尾到首，大小是不断递增的。也就是最大值的变化次数。 所以要反过来扫才能求出结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e7 + 7;int a[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, k, p, q, r, mod; scanf("%d%d%d%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;p, &amp;q, &amp;r, &amp;mod); for (int i = 1; i &lt;= k; i++) scanf("%d", a + i); for (int i = k + 1; i &lt;= n; i++) a[i] = (1LL * a[i - 1] * p + 1LL * q * i + r) % mod; deque&lt;pii&gt; dq; ll A = 0, B = 0; for (int i = n; i &gt;= 1; i--) &#123; while (dq.size() &amp;&amp; dq.front().second - i &gt;= m) dq.pop_front(); while (dq.size() &amp;&amp; a[i] &gt;= dq.back().first) dq.pop_back(); dq.push_back(mp(a[i], i)); if (i &lt;= n - m + 1) &#123; A += dq.front().first ^ i; B += dq.size() ^ i; &#125; &#125; printf("%lld %lld\n", A, B); &#125;&#125; C. Dynamic Graph Matching题意给定一个 n 个点的无向图，m 次加边或者删边操作。 在每次操作后统计有多少个匹配包含 k = 1, 2, …,n/2 条边。 $1\leq n\leq 10, 1 \leq m \leq 3e4$ 分析$dp[i][k]$:表示第i次操作，所覆盖集合为k的种类数. 对于加边操作12345edge (u,v)int S = (1 &lt;&lt; u) &amp; (1 &lt;&lt; v);if((k &amp; S) == S) dp[i][k] = dp[i-1][k] + dp[i-1][k ^ S]; 对于删边操作12if((k &amp; S) == S) dp[i][k] = dp[i-1][k] - dp[i-1][k ^ S]; 这样即使有重边也不用怕 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1111;const int mod = 1e9+7;int dp[2][maxn];int cnt[maxn], ans[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); char s[10]; int all = 1 &lt;&lt; n; for (int i = 0; i &lt; all; i++) &#123; dp[0][i] = dp[1][i] = 0; cnt[i] = __builtin_popcount(i); &#125; dp[0][0] = 1; for (int i = 1, u, v; i &lt;= m; i++) &#123; scanf("%s%d%d", s, &amp;u, &amp;v); u--, v--; int S = (1 &lt;&lt; u) | (1 &lt;&lt; v); if (s[0] == '+') &#123; for (int k = 0; k &lt; all; k++) &#123; dp[i &amp; 1][k] = dp[i &amp; 1 ^ 1][k]; if ((k &amp; S) == S) (dp[i &amp; 1][k] += dp[i &amp; 1 ^ 1][k ^ S]) %= mod; &#125; &#125; else &#123; for (int k = 0; k &lt; all; k++) &#123; dp[i &amp; 1][k] = dp[i &amp; 1 ^ 1][k]; if ((k &amp; S) == S) (dp[i &amp; 1][k] -= dp[i &amp; 1 ^ 1][k ^ S] - mod) %= mod; &#125; &#125; for (int k = 0; k &lt;= n; k++) ans[k] = 0; for (int k = 0; k &lt; all; k++) (ans[cnt[k]] += dp[i &amp; 1][k]) %= mod; for (int k = 2; k &lt;= n; k += 2) &#123; printf("%d%c", ans[k], k &lt; n ? ' ' : '\n'); &#125; &#125; &#125;&#125; D-Euler Function题意问第k小的n，满足$\phi(n)$为合数, $k \leq 1e9$ 分析对于$n = p_1^{k_1}p_2^{k_2}$, $\phi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)$ 可以发现除了1,2,3,4,6以外都是合数。 代码1234567891011121314151617181920212223242526272829303132333435// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int k; scanf("%d", &amp;k); printf("%d\n", k + 4 + (k != 1)); &#125;&#125; F-Grab The Tree题意给定一棵 n 个点的树，每个点有权值。两个人玩游戏，先手需要占领若干不相邻的点，然后后手占领剩下所有点。 每个人的得分为占领的点权异或和，分高的获胜。问最优策略下游戏的结果 分析设sum为所有点权的异或和 若sum不为0，那么先手只要选择最高位为1的那个点，选一个就可以啦，然后就赢了。 如果为0，那一定是平局。 如果当前位为0，那么说明这个点权的出现次数一定为偶数次，那么Q拿奇数次，T也会拿奇数次，Q拿偶数次，T也会拿偶数次，始终是一样的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; ll sum = 0; int n; scanf("%d", &amp;n); for (int i = 0, x; i &lt; n; i++) &#123; scanf("%d", &amp;x); sum ^= x; &#125; for (int i = 0, u, v; i &lt; n - 1; i++) scanf("%d%d", &amp;u, &amp;v); if (!sum) printf("D\n"); else printf("Q\n"); &#125;&#125; L. Visual Cube题意画一个魔方… 分析这种题目，首先要确定关键点的坐标，然后分块作图 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1000;char maze[maxn][maxn];int a, b, c;void solve(pii lt, pii ld, pii rt, pii rd) &#123; for (int i = 1; i &lt;= ld.first; i++) for (int k = 1; k &lt;= rt.second; k++) maze[i][k] = '.'; // center int flag = 1; for (int i = b * 2 + 1; i &lt;= ld.first; i++) &#123; for (int k = 1; k &lt;= a * 2 + 1; k++) &#123; if (flag) &#123; if (k &amp; 1) maze[i][k] = '+'; else maze[i][k] = '-'; &#125; else &#123; if (k &amp; 1) maze[i][k] = '|'; &#125; &#125; flag ^= 1; &#125; // top flag = 1; for (int i = 1; i &lt; b * 2 + 1; i++) &#123; for (int k = b * 2 + 2 - i; k &lt;= rt.second + 1 - i; k++) &#123; if (flag) &#123; if (k &amp; 1) maze[i][k] = '+'; else maze[i][k] = '-'; &#125; else &#123; if (!(k &amp; 1)) maze[i][k] = '/'; &#125; &#125; flag ^= 1; &#125; // right flag = 1; for (int k = rt.second; k &gt;= rt.second - b * 2; k--) &#123; for (int i = rt.second - k + 1; i &lt;= rt.second - k + 1 + 2 * c ; i++) &#123; if (flag) &#123; if (i &amp; 1) maze[i][k] = '+'; else maze[i][k] = '|'; &#125; else &#123; if (!(i &amp; 1)) maze[i][k] = '/'; &#125; &#125; flag ^= 1; &#125; // out for (int i = 1; i &lt;= ld.first; i++) &#123; for (int k = 1; k &lt;= rt.second; k++) printf("%c", maze[i][k]); puts(""); &#125;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); pii lt = &#123;1, 1&#125;; pii ld = &#123;c * 2 + 1 + b * 2, 1&#125;; pii rt = &#123;1, a * 2 + 1 + b * 2&#125;; pii rd = &#123;c * 2 + 1 + b * 2, a * 2 + 1 + b * 2&#125;; solve(lt, ld, rt, rd); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf600E- Lomsat gelral]]></title>
    <url>%2F2018%2F07%2F22%2Fcf600E-Lomsat-gelral%2F</url>
    <content type="text"><![CDATA[题意给一棵树，问每个节点的子树中出现颜色次数最多的颜色和。 分析因为要记录出现次数最多的颜色和，所以要有一个数组(times)来记录每个节点的子树中颜色出现最多的次数 这样的话当前的节点可以直接从其重儿子转移过来， 然后在计算其它儿子的同时进行更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;ll col[maxn], cnt[maxn], sz[maxn], ans[maxn], times[maxn];bool vis[maxn], bigc[maxn];vector&lt;int&gt; G[maxn];ll szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void add(int u, int fa, int x, ll &amp;mx, ll &amp;foo) &#123; cnt[col[u]] += x; if (x != -1) &#123; if (mx &lt; cnt[col[u]]) &#123; mx = cnt[col[u]]; foo = col[u]; &#125; else if (mx == cnt[col[u]]) &#123; foo += col[u]; &#125; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !bigc[v]) add(v, u, x, mx, foo);&#125;void dfs(int u, int fa, bool keep) &#123; ll mx = -1, bc = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) &#123; mx = sz[v]; bc = v; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bc) dfs(v, u, 0); mx = 0; ll foo = 0; if (bc != -1) &#123; dfs(bc, u, 1); bigc[bc] = 1; mx = times[bc]; foo = ans[bc]; &#125; add(u, fa, 1, mx, foo); ans[u] = foo; times[u] = mx; if (bc != -1) bigc[bc] = 0; if (!keep) add(u, fa, -1, mx, foo);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; G[i].clear(); cin &gt;&gt; col[i]; &#125; for (int i = 0, u, v; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].pb(v); G[v].pb(u); &#125; clr(vis, 0); szdfs(1, -1); dfs(1, -1, 0); for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>优雅的暴力</category>
        <category>树上启发式合并(Dsu-on-tree)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dsu-on-tree]]></title>
    <url>%2F2018%2F07%2F22%2FDsu-on-tree-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[简介启发式合并应该比较熟悉，并查集合并的时候为了防止退化，会让高度小的向高度大的合并，这也算一种启发式合并。 树上的启发式合并就是：假设我们现在想知道一棵树上所有节点的子树信息，那么在递归计算的过程中，可以选择保留重儿子的子树上的信息，然后再去重新计算其余儿子的子树信息。这样会使得复杂度由$O(n^2)$降为$O(nlog(n))$ 推荐博客 例题及模板给一棵树，每个节点都有一个颜色，每次查询问某棵子树上颜色为c的节点数。 123456789101112131415161718192021222324252627282930313233343536373839// 推荐使用vector&lt;int&gt; *vec[maxn], G[maxn];int cnt[maxn], sz[maxn], col[maxn];bool vis[maxn], bigc[maxn];int szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void add(int u, int fa, int x) &#123; cnt[col[u]] += x; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !bigc[v]) add(v, u, x);&#125;void dfs(int u, int fa, bool keep) &#123; int mx = -1, bc = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) &#123; mx = sz[v]; bc = v; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bc) dfs(v, u, 0); // run a dfs on small childs and clear them from cnt if (bc != -1) &#123; dfs(bc, u, 1); bigc[bc] = 1; &#125; // bigChild marked as big and not cleared from cnt add(u, fa, 1); // now cnt[c] is the number of vertices in subtree of vertex v that has // color c. You can answer the queries easily. if (bc != -1) bigc[bc] = 0; if (!keep) add(u, fa, -1);&#125; 1234567891011121314151617181920212223242526272829303132333435// 多组数据就不要用了...指针可能还要delet？vector&lt;int&gt; *vec[maxn], G[maxn];int cnt[maxn], sz[maxn], col[maxn];bool vis[maxn];int szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void dfs(int u, int fa, bool keep) &#123; int mx = -1, bigChild = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) mx = sz[v], bigChild = v; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bigChild) dfs(v, u, 0); if (bigChild != -1) dfs(bigChild, u, 1), vec[u] = vec[bigChild]; else vec[u] = new vector&lt;int&gt;(); vec[u]-&gt;push_back(u); cnt[col[u]]++; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bigChild) for (auto x : *vec[v]) &#123; cnt[col[x]]++; vec[u]-&gt;push_back(x); &#125; // now (*cnt[v])[c] is the number of vertices in subtree of vertex v that // has color c. You can answer the queries easily. // note that in this step *vec[v] contains all of the subtree of vertex v. if (keep == 0) for (auto &amp;v : *vec[u]) cnt[col[v]]--;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>优雅的暴力</category>
        <category>树上启发式合并(Dsu-on-tree)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[复杂度: $nlog(n)$ 123456789int S = sqrt(n);struct Node&#123; int l,r,id,ans;&#125;;bool cmp(const Node&amp; A,const Node&amp; B)&#123; if(A.l / S == B.l / S) return A.r &gt; B.r; return A.l / S &lt; B.l / S;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>优雅的暴力</category>
        <category>莫队算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018牛客多校赛第一场]]></title>
    <url>%2F2018%2F07%2F19%2F2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[D题意给两张简单无向图,点数都是n,G1有m1条边,G2有m2条边, 问G2有多少个子图和G1同构. $1 \leq n \leq 8$ 分析判断同构的话可以通过枚举点的映射关系,然后判断是否可行. 因为n只有8,所以可以枚举全排列. 然后对于一些自同构的图要进行一些处理(因为会多算), 另一种方法是对选取的边进行哈希,放到一个set里面,最后set的大小就是答案. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 10;pii G[maxn][maxn];int main() &#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int n, m1, m2; while (cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2) &#123; set&lt;int&gt; SET; vector&lt;int&gt; maps(n); for (int i = 0; i &lt; n; i++) maps[i] = i; clr(G, 0); vector&lt;pii&gt; edges(m1); for (int i = 0, u, v; i &lt; m1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; u--,v--; edges[i] = &#123;u,v&#125;; &#125; for (int i = 0, u, v; i &lt; m2; i++) &#123; cin &gt;&gt; u &gt;&gt; v; u--,v--; G[u][v] = G[v][u] = &#123;1,i&#125;; &#125; do &#123; int hash = 0,u,v; bool flag = true; for(auto &amp;e:edges)&#123; u = maps[e.first]; v = maps[e.second]; if(G[u][v].first == 0)&#123; flag = false; break; &#125; int i = G[u][v].second; hash |= (1 &lt;&lt; i); &#125; if(!flag) continue; SET.insert(hash); &#125; while (next_permutation(maps.begin(), maps.end())); cout &lt;&lt; SET.size() &lt;&lt; endl; &#125;&#125; E题意给一个长度为n的数列，问去掉m个数之后，不同的序列有多少个？ $1 \leq n \leq 1e5, 1 \leq a_i \leq k, 1 \leq k \leq 10, 1 \leq m \leq 10$ 分析网上看了一圈…大家都只贴了个代码，几个有文字的也只是讲了讲做题时的心路历程..这让我们小白如何是好？？ 其实看到这题有三个限制，大致就是一个三维的dp，一算$n \times a_i \times m$差不多够复杂度… $dp[n][i][j]$表示前n个数里删掉i个，剩下的序列里最后一个数是j的种类数。 考虑第i个数删还是不删 不删：$dp[n][i][j] = \sum_{t = 1}^{k} dp[n-1][i][t]$ 删：$dp[n][i+1][j] = dp[n-1][i][j]$ 要注意的是当$a[n] == a[n-1]$时，这是删或不删其实都是一样的，所以只要算其中一种情况即可。 代码里为什么j从0开始，其实j为0的意思就表示序列为空。 如果理解有误还请大佬指正， 如果有别的做法欢迎一起探讨。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int a[maxn];ll dp[2][20][20];int n, m, k;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); clr(dp, 0); dp[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; int u = i &amp; 1; int v = u ^ 1; clr(dp[u], 0); for (int j = 0; j &lt;= m; j++) &#123; for (int t = 0; t &lt;= k; t++) &#123; if (t != a[i]) (dp[u][j + 1][t] += dp[v][j][t]) %= mod; (dp[u][j][a[i]] += dp[v][j][t]) %= mod; &#125; &#125; &#125; ll ans = 0; int u = n &amp; 1; for (int i = 1; i &lt;= k; i++) (ans += dp[u][m][i]) %= mod; printf("%lld\n", ans); &#125;&#125; J题意长度为n的序列,Q个询问(l,r),每次询问$[1,l]\cup [r,n]$ 中有多少不同的数字 $1 \leq n,Q,a_i \leq 1e5$ 分析做法一将区间再复制一份放到尾部,这样就变成了查询$[r,n+l]$中有多少个不同的数字 然后离线树状数组. 可以发现,对于$[1,n]$的一个区间,只要查询的区间是$[i,n], i\in [1,n]$,那么它就有一个”前缀的性质”. 举例说明, 对于区间$[1,2,2,3,5]$来说,只需要记录每个数字最后一次出现的位置即可,若$a[k]$最后一次出现的位置是k,那么就在k位置加一. 上述区间得到的结果是$[1,0,1,1,1]$. 那么对于查询$[i,n]$来说,只要用1的总数减去前i-1个位置中1的个数即可. 当然如果查询的区间右断点不是$n$,那么这个做法不可行. 接下来,我们把查询离线,按右端点从小到大排序,用树状数组来维护即可. 时间复杂度$O(nlog(n))$ 做法二将区间再复制一份放到尾部,这样就变成了查询$[r,n+l]$中有多少个不同的数字 然后主席树,第i个版本维护前i个数中,每个数最后一次出现的位置.(比如某个数最后一次出现的位置是k,那么k位置的value++,这个数上一次最后出现的位置要value–) 这样我再查询区间$[l,r]$有多少不同的数时,只要查询第r个版本时$[l,r]$的和,就是答案. 但是…无情的T了…多交几次也不管用了…可能是写的丑ba 做法三1e5的话就莫队瞎搞搞… 如果超时的话多交几次也许就过了 代码做法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;int a[maxn], last[maxn], first[maxn], bit[maxn];struct Q &#123; int l, r, id, ans;&#125;;Q q[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;void update(int p, int x, int n) &#123; while (p &lt;= n) &#123; bit[p] += x; p += lowb(p); &#125;&#125;int query(int p) &#123; int ret = 0; while (p &gt; 0) &#123; ret += bit[p]; p -= lowb(p); &#125; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), a[i + n] = a[i]; n &lt;&lt;= 1; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;q[i].l, &amp;q[i].r); q[i].l += (n &gt;&gt; 1); swap(q[i].l, q[i].r); q[i].id = i; &#125; sort(q, q + m, [](const Q&amp; A, const Q&amp; B) &#123; return A.r &lt; B.r; &#125;); clr(last, -1); clr(bit, 0); for (int i = 0, k = 1; i &lt; m; i++) &#123; int l = q[i].l; int r = q[i].r; while (k &lt;= r) &#123; if (last[a[k]] != -1) update(last[a[k]], -1, n); update(k, 1, n); last[a[k]] = k; k++; &#125; q[i].ans = query(r) - query(l - 1); &#125; sort(q, q + m, [](const Q&amp; A, const Q&amp; B) &#123; return A.id &lt; B.id; &#125;); for (int i = 0; i &lt; m; i++) printf("%d\n", q[i].ans); &#125;&#125; 做法三1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//ybmj// 如果T了就多交几次#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5+5;int S;int a[maxn],cnt[maxn];struct P&#123; int l,r,id,ans; bool operator &lt; (const P&amp;A) const&#123; if(l / S == A.l / S) return r &gt; A.r; return l / S &lt; A.l / S; &#125;&#125;;P b[maxn]; int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; S = sqrt(n); // 如果T了就改几次 clr(cnt,0); for(int i=0;i&lt;n;i++) &#123; scanf("%d",a+i); &#125; for(int i=0;i&lt;m;i++) scanf("%d%d",&amp;b[i].l,&amp;b[i].r), b[i].id = i; sort(b,b+m); int ans = 0; int l = -1 ,r = n; for(int i=0;i&lt;m;i++)&#123; int L = b[i].l - 1; int R = b[i].r - 1; while(l &lt; L)&#123; l++; ans += cnt[a[l]] == 0; cnt[a[l]]++; &#125; while(l &gt; L)&#123; cnt[a[l]]--; ans -= cnt[a[l]] == 0; l--; &#125; while(r &lt; R)&#123; cnt[a[r]]--; ans -= cnt[a[r]] == 0; r++; &#125; while(r &gt; R)&#123; r--; ans += cnt[a[r]] == 0; cnt[a[r]]++; &#125; b[i].ans = ans; &#125; sort(b,b+m,[](const P&amp;A, const P&amp;B)&#123;return A.id &lt; B.id;&#125;); for(int i=0;i&lt;m;i++) printf("%d\n",b[i].ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉降幂]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%2F</url>
    <content type="text"><![CDATA[公式$n^x \% m = n^{x \% \phi(m) + \phi(m)} \quad \% \quad m \quad (x &gt; \phi(m))$ 迭代的次数不会超过$log(n)$次. 由于$x \geq \phi(m)$, 当$x &lt; \phi(m)$时直接暴力算就可以. 模板123456789101112131415161718192021222324252627282930313233343536#define Mod(x,p) x &lt; p ? x : x % p + p; // 统一用这种取模bool vis[maxn];int prime[maxn], phi[maxn];void init() &#123; // 线性筛预处理欧拉函数 clr(vis, 0); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;ll my_pow(ll a,ll b,ll mod)&#123; ll ret = 1; while(b)&#123; if(b &amp; 1) ret = Mod(ret * a,mod); a = Mod(a * a,mod); b &gt;&gt;= 1; &#125; return Mod(ret,mod);&#125;ll solve(ll base, ll n, int mod)&#123; &#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉降幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛22-E-简单数据结构1]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B22-E-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%2F</url>
    <content type="text"><![CDATA[题意给一个长为n的序列，m次操作，每次操作： $[l,r]$ 加 $x$ 对于$[l,r]$,查询$a[l] ^ {a[l+1] ^ {a[l+2]…}} mod \ P$分析这个欧拉函数的取模好迷啊… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e7+5;ll diff[maxn];#define Mod(x,p) x &lt; p ? x : x % p + pbool vis[maxn];int prime[maxn], phi[maxn];void init() &#123; // 线性筛预处理欧拉函数 clr(vis, 0); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;ll my_pow(ll a,ll b,ll mod)&#123; ll ret = 1; while(b)&#123; if(b &amp; 1) ret = Mod(ret * a,mod); a = Mod(a * a,mod); b &gt;&gt;= 1; &#125; return Mod(ret,mod);&#125;inline ll lowb(ll x) &#123; return x &amp; (-x); &#125;inline void update(int l, int r, ll val, int n) &#123; for (ll i = l; i &lt;= n; i += lowb(i)) diff[i] += val; for (ll i = r + 1; i &lt;= n; i += lowb(i)) diff[i] -= val;&#125;inline ll query(int l, int r, ll p) &#123; ll ret = 0; for (ll i = l; i &gt; 0; i -= lowb(i)) ret += diff[i]; if (l == r || p == 1) return Mod(ret, p); return my_pow(Mod(ret,p), query(l + 1, r, phi[p]), p);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; init(); while (~scanf("%d%d",&amp;n,&amp;m)) &#123; ll foo; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld",&amp;foo); update(i, i, foo, n); &#125; ll l, r, w, p, op; for (int i = 0; i &lt; m; i++) &#123; scanf("%lld",&amp;op); if (op == 1) &#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;w); update(l, r, w, n); &#125; else &#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;p); printf("%lld\n",query(l,r,p) % p); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉降幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义$\phi(n)$: 小于n的正整数中与n互质的个数$(\phi(1) = 1)$ 欧拉函数是积性函数 通式：$\phi(n) = x \prod^{n}_{i=1}(1 - \frac{1}{p_i})$ $p_i$为n的质因子 对于$n = p^k$，p为质数。 $\phi(n) = p^k - p^{k-1} = p^{k-1} (p - 1)$ 因为欧拉函数是积性函数 对于$n = p_1^{k_1}p_2^{k_2}$, $\phi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)$ 性质 若n为质数,则$\phi(n) = n-1$ 一个数的质因子之和为$\frac{\phi(n) \times n}{2}$ 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 求单个Eular函数map&lt;ll, ll&gt; Eular; //记忆化ll eular(ll n) &#123; ll &amp;ret = Eular[n]; if (ret) return ret; ret = n; for (ll i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret -= ret / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;// 线性筛 (同时得到欧拉函数和素数表)const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], phi[maxn];void init() &#123; clr(vis, 0); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;// 打表 (太慢了不要用)const maxn = 1e6 + 5;void getEular() &#123; clr(eular, 0); eular[1] = 1; for (ll i = 2; i &lt; maxn; i++) &#123; if (!eular[i]) for (ll k = i; k &lt; maxn; k += i) &#123; if (!eular[k]) eular[k] = k; eular[k] = eular[k] / i * (i - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划的优化方法]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单调队列优化对于状态是一维,转移也是一维的dp, 可以用单调队列进行优化. $dp[i] = min( A(i) + B(k) ) , k \in [l,i-1]$ 那么可以用一个单调队列来维护$B(k)$, 这样可以把复杂度降到O(n) 斜率优化问题： 设 $f(i) = min( y[k] - s[i] \times x[k]), k \in [1,i-1]$, 现在要求出所有$f(i), i \in [1,n]$ 考虑两个决策j和k，如果j比k优，则 $$y[j] - s[i] \times x[j] &lt; y[k] - s[i] \times x[k]$$ 化简得: $$\frac{y_j - y_k}{x_j - x_k} &lt; s_i$$ 不等式左边是个斜率，我们把它设为$slope(j,k)$ 我们可以维护一个单调递增的队列，为什么呢？ 因为如果$slope(q[i-1],q[i]) &gt; slope(q[i],q[i+1])$，那么当前者成立时，后者必定成立。 即$q[i]$决策优于$q[i-1]$决策时，$q[i+1]$必然优于$q[i]$，因此$q[i]$就没有存在的必要了。 所以我们要维护递增的队列。 那么每次的决策点i，都要满足$$\begin{cases} slope(q[i-1],q[i]) &lt; s[i]\\ slope(q[i],q[i+1]) &gt;= s[i] \end{cases}$$ 一般情况去二分这个i即可。 如果$s[i]$是单调不降的，那么对于决策j和k(j &lt; k)来说，如果决策k优于决策j，那么对于$i \in [k+1,n]$，都存在决策k优于决策j， 因此决策j就可以舍弃了。 这样的话我们可以用单调队列进行优化，可以少个$log$ 如果还是有点模糊的话，请去做一下bzoj1010,然后我的这篇题解用来上述一抹一样的方法进行分析。]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NCPC2017-A-Airport Coffee 单调队列优化dp]]></title>
    <url>%2F2018%2F07%2F15%2FNCPC2017-A-Airport-Coffee-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[题意一个人要走一段长度为l的路,中间有n个咖啡店,给你每个咖啡店的位置. 不喝咖啡时速度为a,喝咖啡时速度为b. 买咖啡不需要时间,买了咖啡之后走t秒后就开始喝咖啡了,每杯咖啡会喝r秒. 最多可以同时拥有一杯咖啡. 问在最短时间内走完这条路需要经过哪些咖啡店? 分析设$dp[i]$为到第i个的咖啡店并买咖啡的最短时间 $$dp[i] = min { dp[k] + cost(i,k) }, k \in [0,i-1]$$ $cost(i,k)$ 有三种情况 $$\begin{cases} (\frac{-pos[k]}{a} + dp[k])+ \frac{pos[i]}{a} \quad {a[i] - a[k] &lt; a \times t }\\ (\frac{b\times t - a\times t - pos[k]}{b} + dp[k]) + \frac{pos[i]}{b} \quad {a\times t \leq a[i] - a[k] \leq a\times t + b\times r}\\ (\frac{a\times r - b\times r - pos[k]}{a} + dp[k]) + \frac{pos[i]}{a} \quad {a\times t + b\times r &lt; a[i] - a[k]} \end{cases} $$ $$\begin{cases} x_1 = x_{1,0} + \frac{a_2}{(a_1,a_2)}\times t\\ {x_2 = x_{2,0} - \frac{a_1}{(a_1,a_2)}\times t} \end{cases}$$ 发现只要维护三个单调队列即可, 但是实际上只需要维护中间那个. 对于第一种情况,他在上一个店里买了咖啡,到当前店的时候还没开始喝,那么他必然在当前店不会再买咖啡 对于第三种情况,因为咖啡作用完之后还需要再走一段距离,所以这段距离应该越近越好 还是写三个单调队列比较稳一点. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e5 + 5;double a[maxn], dp[maxn];int last[maxn];int n;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); double l, A, B, t, r; while (cin &gt;&gt; l &gt;&gt; A &gt;&gt; B &gt;&gt; t &gt;&gt; r) &#123; cin &gt;&gt; n; a[0] = dp[0] = 0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; a[++n] = l; deque&lt;pair&lt;int, double&gt; &gt; dq; // (pos, val) double d = A * t + B * r; for (int i = 1, k = 1; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + (a[i] - a[i - 1]) / A; last[i] = i - 1; while (a[i] - a[k] &gt; d) &#123; double foo = (A * r - B * r - a[k] + a[i]) / A + dp[k]; if (foo &lt; dp[i]) &#123; dp[i] = foo; last[i] = k; &#125; k++; &#125; while (dq.size() &amp;&amp; a[i] - a[dq.front().first] &gt; d) dq.pop_front(); if (dq.size()) &#123; pair&lt;int,double&gt; u = dq.front(); if (u.second + a[i] / B &lt; dp[i]) &#123; dp[i] = u.second + a[i] / B; last[i] = u.first; &#125; &#125; double bar = dp[i] + (t * B - t * A - a[i]) / B; while (dq.size() &amp;&amp; dq.back().second &gt; bar) dq.pop_back(); dq.push_back(mp(i, bar)); &#125; vector&lt;int&gt; ans; for (int i = last[n]; i &gt; 0; i = last[i]) &#123; ans.pb(i - 1); &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for (int i = ans.size() - 1; i &gt;= 0; i--) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf981e Addition on Segments]]></title>
    <url>%2F2018%2F07%2F15%2Fcf981e-Addition-on-Segments%2F</url>
    <content type="text"><![CDATA[题意给你一个长度为n的全为0的序列,接下来有m个区间加的操作,你可以从这m个操作中任取一些操作实施,然后会得到一个区间最大值. 问区间最大值在1到n的可能的情况有多少个? $1 \leq n ,q \leq 10^4 $ 分析我们可以枚举位置i的值是最大值, 这样对于不包括i的操作就可以舍去. 然后看i有多少种取值是在1到n之间的. 对于区间加的操作我们可以用线段树的lazy来维护, 这样我们在查询i的值时那些不包括i的操作就会被舍去. 然后就是对每个点的lazy进行01背包,即每个区间操作取或不取. (每个节点的lazy不只是一个值,因为可能有多个区间覆盖一个点的情况) 因为最大值的区间在1到n,所以我们可用bitset进行优化,最后复杂度为$O(n^2logn / 64)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4 + 5;vector&lt;int&gt; lazy[maxn &lt;&lt; 2];bitset&lt;maxn&gt; dp[100], ans;void update(int l, int r, int rt, int L, int R, int x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; lazy[rt].pb(x); return; &#125; int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, lson, L, R, x); if (m &lt; R) update(m + 1, r, rson, L, R, x);&#125;void query(int l, int r, int rt, int k) &#123; dp[k] = dp[k - 1]; for (auto &amp;v : lazy[rt]) dp[k] |= dp[k] &lt;&lt; v; if (l == r) &#123; ans |= dp[k]; return; &#125; int m = l + r &gt;&gt; 1; query(l, m, lson, k + 1); query(m + 1, r, rson, k + 1);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); bitset&lt;maxn&gt; bt, foo; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i &lt; 2 * n + 5; i++) &#123; lazy[i].clear(); &#125; int l, r, x; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; update(1, n, 1, l, r, x); &#125; dp[0].set(0); ans.reset(); query(1, n, 1, 1); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt += ans[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if (ans[i] == 1) cout &lt;&lt; i &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛22-C 简单瞎搞题]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B22-C-%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意一共有n个数，第i个数是$x_i$,$x_i$可以取$[l_i , r_i]$中任意的一个值。 设$S = \sum x_i^2$, 求S种类数 $1 \leq n, l_i, r_i \leq 100$ 分析计算可知S最大为1e6, 所以我们可以用1e6个二进制位来记录每个数是否出现过. 然后暴力所有的区间. 复杂度(1e10 / w) …. 代码123456789101112131415161718192021222324252627282930313233343536373839//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6+5;bitset&lt;maxn&gt; b[2];int main()&#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; b[0].set(0); for(int i=1;i&lt;=n;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; b[i &amp; 1].reset(); for(int k=l;k&lt;=r;k++)&#123; b[i &amp; 1] |= b[i &amp; 1 ^ 1] &lt;&lt; (k*k); &#125; &#125; cout &lt;&lt; b[n&amp;1].count() &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bitset]]></title>
    <url>%2F2018%2F07%2F14%2FBitset%2F</url>
    <content type="text"><![CDATA[12bitset&lt;N&gt; bt;//复杂度据说是 N / w(计算机字长) 主要用来优化类01背包问题 成员函数]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调队列]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[求滑动窗口最大值 双端队列模拟即可 12345678deque&lt;pii&gt; dq; // (pos, val)for(int i=1;i&lt;=n;i++)&#123; while(dq.size() &amp;&amp; 队首过期) dq.pop_front(); while(dq.size() &amp;&amp; 加入当前元素后队列不单调) dq.pop_back(); dq.push_back(当前元素) 队首进行决策&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>单调队列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2018.7 大鱼吃小鱼]]></title>
    <url>%2F2018%2F07%2F12%2FEOJ-Monthly-2018-7-%E5%A4%A7%E9%B1%BC%E5%90%83%E5%B0%8F%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[题意有n条鱼 任意时刻只能吃大小小于等于自己的鱼。 任何时刻都要保证鱼的大小是正整数。 当吃了第 i 条鱼之后自己的大小 x 会变为 $x+a_i$。 初始鱼的大小至少需要多大才能吃完这 n 条鱼? 吃的顺序可以任意。 分析二分最后答案,然后先吃掉所有$a_i &gt;= 0$的鱼 对于$a_i&lt;0$的鱼, 有两种方法: 考虑吃掉i之前,$x\geq w_i$,吃掉i之后,$x \geq w_i + a_i$, 要使体型尽可能的大,所以按$a+w$排序即可. 先把所有鱼都吃掉,然后看如果$x \geq w_i + a_i$, 那么就减去$a_i$,也是按$a+w$排序即可.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const ll INF = 1e18;const int NINF = 0xc0c0c0c0;struct P &#123; ll w, a;&#125;;vector&lt;P&gt; foo, bar;const int maxn = 1e6 + 5;bool vis[maxn];bool ok(ll x) &#123; for (auto &amp;v : foo) if (x &gt;= v.w) x += v.a; else return false; for (auto &amp;v : bar) &#123; if (x &gt;= v.w) x -= v.a; else return false; &#125; if (x &lt;= 0) return false; return true;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; int u, v; foo.clear(); bar.clear(); temp.clear(); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; if (v &gt;= 0) &#123; foo.push_back(&#123;u, v&#125;); &#125; else &#123; bar.push_back(&#123;u, -v&#125;); // temp.push_back(&#123;u, -v&#125;); &#125; &#125; for (int i = 0; i &lt; bar.size(); i++) bar[i].id = i; // for (int i = 0; i &lt; temp.size(); i++) temp[i].id = i; sort(foo.begin(), foo.end(), cmp1); sort(bar.begin(), bar.end(), cmp2); // sort(temp.begin(), temp.end(), cmp3); ll l = 1, r = 1e18; ll ans; while (l &lt;= r) &#123; ll mid = l + r &gt;&gt; 1; if (ok(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2018.7 对称与科学美 异或和为0的区间数量]]></title>
    <url>%2F2018%2F07%2F12%2FEOJ-Monthly-2018-7-%E5%AF%B9%E7%A7%B0%E4%B8%8E%E7%A7%91%E5%AD%A6%E7%BE%8E-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题意给一个数列，问有多少连续子数列，符合对称与科学美，也就是每个数字的出现次数均为偶数。 题目 分析满足题意的区间，其异或和为0，反之不一定成立。 所以我们可以对每个相同的数字重新随机一个新的数字，然后再计算答案 多次随机，在所有答案中取最小的即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 4e5;map&lt;ll, ll&gt; cnt;ll back[maxn], a[maxn];vector&lt;ll&gt; G[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; srand(time(0)); while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; ll ans = 1e18; for (int i = 1; i &lt;= 10; i++) &#123; ll t = rand(); for (int k = 1; k &lt;= n; k++) a[k] *= t; cnt.clear(); ll x = 0; ll foo = 0; for (int k = 1; k &lt;= n; k++) &#123; x ^= a[k]; foo += cnt[x] + (x == 0); cnt[x]++; &#125; ans = min(ans, foo); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三分查找]]></title>
    <url>%2F2018%2F07%2F12%2F%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[求单峰区间的极值 整数三分123456789101112// 求极大值int find(int l, int r) &#123; while (l &lt; r - 1) &#123; int m1 = l + r &gt;&gt; 1; int m2 = m1 + r &gt;&gt; 1; if (work(m1) &gt; work(m2)) r = m2; else l = m1; &#125; return work(l) &gt; work(r) ? l : r;&#125; 浮点三分123456789101112131415// 求极小值double find(double l, double r) &#123; double m1, m2; while (r - l &gt;= eps) &#123; m1 = l + (r - l) / 3; m2 = r - (r - l) / 3; // m1 = l + r &gt;&gt; 1; // m2 = m1 + r &gt;&gt; 1; if (work(m1) &gt; work(m2)) l = m1; else r = m2; &#125; return (m1 + m2) / 2;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[染色]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题意给定一棵有n个节点的无根树和m个操作，操作有2类： 1、将节点a到节点b路径上所有点都染成颜色c； 2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段）， 如“112221”由3段组成：“11”、“222”和“1”。 请你写一个程序依次完成这m个操作。 分析轻重链剖分后线段树区间合并 注意 线段树查询的时候，递归查询左右两个子段时，如果交界处颜色相等，答案要减一 在树链上查询的时候，如果链首的父亲和链首颜色相同，答案要减一 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];struct Node &#123; int l, r, cnt;&#125;;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; Node seg[maxn &lt;&lt; 2]; int lazy[maxn &lt;&lt; 2]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; void pushup(int rt) &#123; seg[rt].cnt = seg[lson].cnt + seg[rson].cnt; seg[rt].l = seg[lson].l; seg[rt].r = seg[rson].r; if (seg[lson].r == seg[rson].l) seg[rt].cnt--; &#125; void build(int l, int r, int rt) &#123; lazy[rt] = -1; if (l == r) &#123; seg[rt].l = seg[rt].r = a[rk[l]]; seg[rt].cnt = 1; return; &#125; int m = l + r &gt;&gt; 1; build(l, m, lson); build(m + 1, r, rson); pushup(rt); &#125; void pushdown(int rt) &#123; if (lazy[rt] == -1) return; int c = lazy[rt]; seg[lson].l = seg[rson].l = c; seg[lson].r = seg[rson].r = c; seg[lson].cnt = seg[rson].cnt = 1; lazy[lson] = lazy[rson] = c; lazy[rt] = -1; &#125; void update(int l, int r, int L, int R, int rt, int c) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].l = seg[rt].r = c; seg[rt].cnt = 1; lazy[rt] = c; return; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, L, R, lson, c); if (R &gt; m) update(m + 1, r, L, R, rson, c); pushup(rt); &#125; void update_path(int u, int v, int c) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, n, id[top[u]], id[u], 1, c); u = par[top[u]]; &#125; // if (u == v) return; if (dep[u] &gt; dep[v]) swap(u, v); update(1, n, id[u], id[v], 1, c); &#125; int query_c(int l, int r, int x, int rt) &#123; if (l == r) return seg[rt].l; pushdown(rt); int m = l + r &gt;&gt; 1; if (x &lt;= m) return query_c(l, m, x, lson); if (x &gt; m) return query_c(m + 1, r, x, rson); &#125; int query(int l, int r, int L, int R, int rt) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].cnt; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; int ret = 0; if (R &lt;= m) &#123; ret += query(l, m, L, R, lson); &#125; else if (L &gt; m) &#123; ret += query(m + 1, r, L, R, rson); &#125; else &#123; ret += query(m + 1, r, L, R, rson) + query(l, m, L, R, lson); if(seg[lson].r == seg[rson].l) ret--; &#125; // if (L &lt;= m) ret += query(l, m, L, R, lson); // if (R &gt; m) ret += query(m + 1, r, L, R, rson); return ret; &#125; int query_path(int u, int v) &#123; int ret = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret += query(1, n, id[top[u]], id[u], 1); int fac = query_c(1, n, id[par[top[u]]], 1); int c = query_c(1, n, id[top[u]], 1); if (fac == c) ret--; u = par[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v); ret += query(1, n, id[u], id[v], 1); return ret; &#125;&#125;;HLD hld;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int u, v, c; hld.init(n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; hld.addedge(u, v); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); hld.build(1, n, 1); string op; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == "C") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; hld.update_path(u, v, c); &#125; else &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; hld.query_path(u, v) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tree POJ - 3237 边权模板题]]></title>
    <url>%2F2018%2F07%2F10%2FTree-POJ-3237-%E8%BE%B9%E6%9D%83%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意三种操作： 改变某条边的权值 将a到b点链上的所有边的权值都取反 查询a到b点链上的所有边的权值最大值 分析将边权下放到点权，注意查询和修改的时候不能动最后的LCA（因为它的权值是属于它与它父亲的边 轻重链剖分后线段树维护即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];struct Node &#123; int Min, Max;&#125;;struct Edge &#123; int u, v, w;&#125;;vector&lt;Edge&gt; edges;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; Node seg[maxn &lt;&lt; 2]; int lazy[maxn &lt;&lt; 2]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; int pushup(int rt) &#123; seg[rt].Min = min(seg[lson].Min, seg[rson].Min); seg[rt].Max = max(seg[lson].Max, seg[rson].Max); &#125; void build(int l, int r, int rt) &#123; lazy[rt] = 0; if (l == r) &#123; seg[rt].Min = seg[rt].Max = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(l, m, lson); build(m + 1, r, rson); pushup(rt); &#125; void pushdown(int rt) &#123; if (!lazy[rt]) return; swap(seg[lson].Max, seg[lson].Min); seg[lson].Max *= -1; seg[lson].Min *= -1; swap(seg[rson].Max, seg[rson].Min); seg[rson].Max *= -1; seg[rson].Min *= -1; lazy[lson] ^= 1; lazy[rson] ^= 1; lazy[rt] = 0; &#125; void update(int l, int r, int L, int R, int rt, int op, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; if (!op) &#123; seg[rt].Max = seg[rt].Min = val; &#125; else &#123; swap(seg[rt].Max, seg[rt].Min); seg[rt].Max *= -1; seg[rt].Min *= -1; lazy[rt] ^= 1; &#125; return; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, L, R, lson, op, val); if (R &gt; m) update(m + 1, r, L, R, rson, op, val); pushup(rt); &#125; void update_path(int u, int v, int op) &#123; if (!op) &#123; update(1, n, id[u], id[u], 1, op, v); return; &#125; if (dep[u] &gt; dep[v]) swap(u, v); while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, n, id[top[u]], id[u], 1, op, -1); u = par[top[u]]; &#125; if(u == v) return; if (dep[u] &gt; dep[v]) swap(u, v); update(1, n, id[u] + 1, id[v], 1, op, -1); &#125; int query(int l, int r, int L, int R, int rt) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].Max; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; int ret = NINF; if (L &lt;= m) ret = max(ret,query(l, m, L, R, lson)); if (R &gt; m) ret = max(ret,query(m + 1, r, L, R, rson)); return ret; &#125; int query_path(int u, int v) &#123; int ret = NINF; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret = max(ret, query(1, n, id[top[u]], id[u], 1)); u = par[top[u]]; &#125; if(u == v) return ret; if (dep[u] &gt; dep[v]) swap(u, v); ret = max(ret, query(1, n, id[u] + 1, id[v], 1)); return ret; &#125;&#125;;HLD hld;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n, u, v, w; cin &gt;&gt; n; hld.init(n); edges.clear(); for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.addedge(u, v); edges.push_back(&#123;u, v, w&#125;); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); for (int i = 0; i &lt; edges.size(); i++) &#123; int &amp;u = edges[i].u; int &amp;v = edges[i].v; w = edges[i].w; if (hld.dep[u] &gt; hld.dep[v]) swap(u, v); a[hld.id[v]] = w; &#125; hld.build(1, n, 1); string op; while (cin &gt;&gt; op) &#123; if (op == "DONE") break; if (op == "QUERY") &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; hld.query_path(u, v) &lt;&lt; endl; &#125; else if (op == "CHANGE") &#123; cin &gt;&gt; u &gt;&gt; w; hld.update_path(edges[u - 1].v, w, 0); &#125; else &#123; cin &gt;&gt; u &gt;&gt; v; hld.update_path(u, v, 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Aragorn's Story HDU-3966 点权模板题]]></title>
    <url>%2F2018%2F07%2F10%2FAragorn-s-Story-HDU-3966-%E7%82%B9%E6%9D%83%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意三种操作： c1 到 c2 链上都增加k c1 到 c2 链上都减少k 查询c1 到c2 链上的和 分析轻重链剖分后用树状数组维护即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4+5;int a[maxn];struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); clr(diff, 0); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (auto &amp;v : G[u]) &#123; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (auto &amp;v : G[u]) &#123; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; void update_path(int u, int v, int val) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(id[top[u]], id[u], val); u = par[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v); update(id[u], id[v], val); &#125; int diff[maxn]; int lowb(int x) &#123; return x &amp; (-x); &#125; int query(int x) &#123; int ret = 0; for (int i = x; i &gt; 0; i -= lowb(i)) &#123; ret += diff[i]; continue; &#125; return ret; &#125; void update(int l, int r, int val) &#123; for (int i = l; i &lt;= n; i += lowb(i)) diff[i] += val; for (int i = r + 1; i &lt;= n; i += lowb(i)) diff[i] -= val; &#125;&#125;;HLD hld;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m, q; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123; hld.init(n + 5); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int u, v, w; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; hld.addedge(u, v); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); for (int i = 1; i &lt;= n; i++) hld.update(hld.id[i], hld.id[i], a[i]); string op; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; op; if (op == "I") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.update_path(u, v, w); &#125; else if (op == "D") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.update_path(u, v, -w); &#125; else &#123; cin &gt;&gt; u; cout &lt;&lt; hld.query(hld.id[u]) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HLD]]></title>
    <url>%2F2018%2F07%2F03%2FHLD%2F</url>
    <content type="text"><![CDATA[感谢 大神博客 HLDHLD: Heavy-Light Decomposition 轻重链剖分 将一棵树转化为若干链拼接而成的区间.然后在这个区间上就可以使用一些数据结构来操作. 复杂度: 因为是轻重链剖分,所以跳跃的复杂度不会超过$log(n)$次 其实树链剖分并不是一个复杂的算法或者数据结构，只是能把一棵树拆成链来处理而已，换一种说法，树链剖分只是xxx数据结构/算法在树上的推广，或者说，树链剖分只是把树hash到了几段连续的区间上。 因为这东西本身没有功能，具体功能都是靠具体数据结构实现的，所以复杂度就是$O(logn * ??)$。如果套上了线段树，就是$O(log^2 n)$. 如果套上了树套树，那就是$O(log^3 n)$.如果你用树链剖分和树套树写区间第k大，那就是$O(log^4 n)$. ——出自大神博客 讲解重儿子：父亲节点的所有儿子中子树结点数目最多的结点； 轻儿子：父亲节点中除了重儿子以外的儿子； 重边：父亲结点和重儿子连成的边； 轻边：父亲节点和轻儿子连成的边； 重链：由多条重边连接而成的路径； 轻链：由多条轻边连接而成的路径； par[u] 保存结点u的父亲节点 dep[u] 保存结点u的深度值 sz[u] 保存以u为根的子树节点个数 son[u] 保存重儿子 rk[u] 保存当前dfs标号在树中所对应的节点 top[u] 保存当前节点所在链的顶端节点 id[u] 保存树中每个节点剖分以后的新编号（DFS的执行顺序） 上图中，红点为top点， 粗边为重边。 注意 数据结构维护的是树链剖分后的序列（id序列） 当题目中给的是边权时，要将边权下放变成点权（下放给深度大的点） 查询的时候要注意最后公共的lca是不算进去的，因为的权值是它与它父亲的边权。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const int maxn = 100;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn],rk[maxn]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u,int v)&#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u,int fa,int d)&#123; dep[u] = d; par[u] = fa; sz[u] = 1; for(auto &amp;v:G[u])&#123; if(v == fa) continue; dfs(v,u,d+1); sz[u] += sz[v]; if(son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u,int t)&#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if(son[u] == -1) return ; link(son[u],t); for(auto &amp;v:G[u])&#123; if(v != son[u] &amp;&amp; v != par[u]) link(v,v); &#125; &#125; void update(int u,int v,int w) &#123;&#125; // 数据结构 int query(int u,int v) &#123;&#125; // 数据结构 void update_path(int u,int v,int w)&#123; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); update(id[top[u]],id[u],w); u = par[top[u]]; &#125; // if(u == v) return; // 边权变点权 if(dep[u] &gt; dep[v]) swap(u,v); update(id[u],id[v],w); // update(id[u] + 1,id[v],w); // 边权变点权 &#125; int query_path(int u,int v)&#123; int ret = 0; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); ret += query(id[top[u]],id[u]); u = par[top[u]]; &#125; // if(u == v) return ret; // 边权变点权 if(dep[u] &gt; dep[v]) swap(u,v); ret += query(id[u],id[v]); // ret += query(id[u] + 1,id[v]); // 边权变点权 return ret; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LCA-ST]]></title>
    <url>%2F2018%2F07%2F03%2FLCA-ST%2F</url>
    <content type="text"><![CDATA[ST这是一种在线计算LCA的算法，时间复杂度为： 预处理nlogn, 查询logn 思想将树型转化为区间形式，然后再RMQ所查区间内深度最小的点，即为lca 这种遍历方式需要两倍的存储空间 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 100;vector&lt;int&gt; G[maxn];int deep[maxn * 2]; // deep[u]: u的深度int trav[maxn * 2]; // 遍历之后的数组int fir[maxn]; // fir[u]: u点在trav中出现的第一个位置的下标int dp[maxn][maxn]; // RMQ 记录的是最小深度的下标int tot;void init() &#123; tot = 0; clr(fir, 0);&#125;void dfs(int u, int fa, int h) &#123; trav[++tot] = u; fir[u] = tot; deep[tot] = h; for (auto &amp;v : G[u]) &#123; if (v != fa &amp;&amp; !fir[v]) &#123; dfs(v, u, h + 1); trav[++tot] = u; deep[tot] = h; &#125; &#125;&#125;void ST(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = i; for (int k = 1; (1 &lt;&lt; k) &lt;= n; k++) &#123; for (int i = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; i++) &#123; int foo = dp[i][k-1]; int bar = dp[i + (1 &lt;&lt; (k-1))][k-1]; if(deep[foo] &lt; deep[bar]) dp[i][k] = foo; else dp[i][k] = bar; &#125; &#125;&#125;int RMQ(int l,int r)&#123; int k = 0; while( (1 &lt;&lt; (k+1)) &lt;= r - l + 1) k++; int pos = min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); return trav[pos];&#125;int LCA(int u,int v)&#123; u = fir[u]; v = fir[v]; if(u &gt; v) swap(u,v); return RMQ(u,v);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最近公共祖先LCA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DFS序]]></title>
    <url>%2F2018%2F07%2F03%2FDFS%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[DFS序123456789101112131415// u 的子树区间 [in[u], out[u]]// 下标从1开始const int maxn = 100;vector&lt;int&gt; G[maxn];int in[maxn], out[maxn];int dfn;void init() &#123; dfn = 0; &#125;void dfs(int u, int fa) &#123; in[u] = ++dfn; for (auto &amp;v : G[u]) &#123; if (v != fa) dfs(v, u); &#125; out[u] = dfn;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>DFS序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RMQ]]></title>
    <url>%2F2018%2F07%2F03%2FRMQ%2F</url>
    <content type="text"><![CDATA[RMQRMQ: Range Minimum Query 范围最小值 一维RMQ$dp[i][k]$: 表示从i位置开始，长度为$2^k$的一段元素中的最小值。 $dp[i][k] = min(dp[i][k-1], dp[i + (1 &lt;&lt; (k-1))][k-1])$ 查询区间$[l,r]$的时候要先找到第一个k,使得$2^{k+1} &gt; r - l + 1$ 那么答案就是$min(dp[l][k],dp[r - (1 &lt;&lt; k) + 1][k])$ 时间复杂度为： 预处理nlogn, 查询logn 模板123456789101112131415161718// nlog(n) 预处理， log(n) 查询// 起始下标为1const int maxn = 100;int dp[maxn][maxn];int a[maxn];void rmq_init(int n) &#123; for (int i = 0; i &lt; n; i++) dp[i][0] = a[i]; for (int k = 1; (1 &lt;&lt; k) - 1 &lt; n; k++) &#123; for (int i = 0; i + (1 &lt;&lt; k) - 1 &lt; n; i++) &#123; dp[i][k] = min(dp[i][k - 1], dp[i + (1 &lt;&lt; (k - 1))][k - 1]); &#125; &#125;&#125;int rmq(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; 二维RMQ$dp[r][c][i][k]$: 表示$(r,c)$为左上角,$(r + 2^{i} - 1, c + 2^{k} - 1)$为右下角的矩阵中的最小值 123456789101112131415161718192021222324252627282930313233343536373839// 预处理 n*m*log(n)*log(m)， 查询 log(nm) // 起始下标为1const int maxn = 100;int dp[maxn][maxn][maxn][maxn];int a[maxn][maxn];void rmq_init(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int k = 1; k &lt;= m; k++) &#123; dp[i][k][0][0] = a[i][k]; &#125; &#125; for (int i = 0; (1 &lt;&lt; i) &lt;= n; i++) &#123; for (int k = 0; (1 &lt;&lt; k) &lt;= m; k++) &#123; if (!i &amp;&amp; !k) continue; for (int r = 1; r + (1 &lt;&lt; i) - 1 &lt;= n; r++) &#123; for (int c = 1; c + (1 &lt;&lt; k) - 1 &lt;= m; c++) &#123; if (!k) dp[r][c][i][k] = min(dp[r][c][i - 1][k], dp[r + (1 &lt;&lt; (i - 1))][c][i - 1][k]); else dp[r][c][i][k] = min(dp[r][c][i][k - 1], dp[r][c + (1 &lt;&lt; (k - 1))][i][k - 1]); &#125; &#125; &#125; &#125;&#125;int rmq(int x1, int y1,int x2,int y2) &#123; int kx = 0 , ky = 0; while((1 &lt;&lt; (kx+1)) &lt;= x2 - x1 + 1) kx++; while((1 &lt;&lt; (ky+1)) &lt;= y2 - y1 + 1) ky++; int m1 = dp[x1][y1][kx][ky]; int m2 = dp[x2 - (1 &lt;&lt; kx) + 1][y1][kx][ky]; int m3 = dp[x1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; int m4 = dp[x2 - (1 &lt;&lt; kx) + 1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; return min(m1,min(m2,min(m3,m4)));&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>RMQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[割点与割边]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%89%B2%E7%82%B9%E4%B8%8E%E5%89%B2%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[注意对每个割点或者割边来说，判定定理可能不止一次成立，所以不要边判定边输出。 割点$pre[u]:$ 代表进入u点的时间 $low[u]:$ 为u及其后代所能回到的最早的祖先的pre值 若这个u点是割点，那么$low[v] &gt;= pre[u]$ (v是u的孩子) 注意根的特判 模板12345678910111213141516171819vector&lt;int&gt; G[maxn];int pre[maxn];bool iscut[maxn];int dfn;int dfs(int u, int fa) &#123; int lowu = pre[u] = ++dfn; int child = 0; for (auto &amp;v : G[u]) &#123; if (!pre[v]) &#123; child++; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &gt;= pre[u]) iscut[u] = true; &#125; else if (pre[v] &lt; pre[u] &amp;&amp; v != fa) lowu = min(lowu, pre[v]); &#125; if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = false; return lowu;&#125; 割边当$low[v] &gt; pre[u]$时，(u,v)是桥 同时为了防止重边，需要记录(u,fa)的数量，若大于1说明有重边，则要设置low[u] = pre[fa]. 模板123456789101112131415161718192021222324vector&lt;pii&gt; G[maxn]; // first: 下一个点， second: 该边的编号int pre[maxn];bool iscut[N]; // N: 边数int dfn;int dfs(int u,int fa)&#123; int lowu; lowu = pre[u] = ++dfn; // int father = 0; for(auto &amp;V:G[u])&#123; int v = V.first; int id = V.second; // 边的编号 // if(v == fa) father++; if(!pre[v])&#123; int lowv = dfs(v,u); lowu = min(lowv,lowu); if(lowv &gt; pre[u]) iscut[id] = true; &#125; else if(pre[v] &lt; pre[u] &amp;&amp; v != fa) lowu = min(lowu,pre[v]); &#125; // if(father &gt; 1) return pre[fa]; return lowu;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>割点与割边</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf602d Lipshitz Sequence]]></title>
    <url>%2F2018%2F06%2F29%2Fcf602d-Lipshitz-Sequence%2F</url>
    <content type="text"><![CDATA[来源: cf 602d 分析相邻两个元素的L(h)是最大的。 单调栈预处理每个区间所覆盖的区间即可。 注意要[l,r) 左开右闭，否则会重复计算元素 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];int L[maxn], R[maxn];void init(int n) &#123; stack&lt;pii&gt; st; for (int i = 1; i &lt; n; i++) &#123; while (st.size() &amp;&amp; (abs(a[i] - a[i - 1])) &gt;= st.top().second) st.pop(); if (st.empty()) L[i] = 0; else L[i] = st.top().first; st.push(mp(i, abs(a[i] - a[i - 1]))); &#125; while (!st.empty()) st.pop(); for (int i = n - 1; i &gt; 0; i--) &#123; while (st.size() &amp;&amp; (abs(a[i] - a[i - 1])) &gt; st.top().second) st.pop(); if (st.empty()) R[i] = n - 1; else R[i] = st.top().first - 1; st.push(mp(i, abs(a[i] - a[i - 1]))); &#125;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, q; while (cin &gt;&gt; n &gt;&gt; q) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; init(n); int l, r; ll ans; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ans = 0; for (int k = l; k &lt; r; k++) &#123; int ri = min(R[k], r-1); int li = max(L[k], l-1); ans += 1LL * (ri - k + 1) * (k - li) * abs(a[k] - a[k - 1]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>单调栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu4348 To the moon 主席树区间修改区间查询]]></title>
    <url>%2F2018%2F06%2F28%2Fhdu4348-To-the-moon-%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题意要支持区间修改，区间查询，版本回退 分析因为要维护多个版本，这正是主席树做的事情。 难点在区间修改怎么做 普通的线段树做区间修改都会设置lazy标志，然后在更新和查询的时候会下放。 在主席树中同样也要设置lazy标志，但是不会下放。 因为主席树是动态开点的，下放的时候子节点都还没被被创建… 那么如果lazy标志不下放，在查询的时候就要把祖先们的lazy标志都加上。 特别要注意的是pushup的时候也要带上自身的lazy， 因为sum[i] 记录的是整个区间更新之后的值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int root[maxn], a[maxn];int lch[maxn &lt;&lt; 5], rch[maxn &lt;&lt; 5];ll sum[maxn &lt;&lt; 5], lazy[maxn &lt;&lt; 5];int idx;inline void pushup(int rt, int len) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]] + 1LL * len * lazy[rt]; // !&#125;void build(int &amp;k, int l, int r) &#123; k = ++idx; lazy[k] = 0; if (l == r) &#123; sum[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k, r - l + 1);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old]; lazy[k] = lazy[old];&#125;void update(int old, int &amp;k, int l, int r, int L, int R, int x) &#123; k = ++idx; newnode(old, k); if (L &lt;= l &amp;&amp; R &gt;= r) &#123; sum[k] += x * (r - l + 1); lazy[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (m &gt;= L) update(lch[old], lch[k], l, m, L, R, x); if (m &lt; R) update(rch[old], rch[k], m + 1, r, L, R, x); pushup(k, r - l + 1);&#125;ll query(int k, int l, int r, int L, int R, ll x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k] + 1LL * (r - l + 1) * x; // ! int m = l + r &gt;&gt; 1; x += lazy[k]; // ! ll ret = 0; if (m &gt;= L) ret += query(lch[k], l, m, L, R, x); if (m &lt; R) ret += query(rch[k], m + 1, r, L, R, x); return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; int kase = 0; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (kase) cout &lt;&lt; '\n'; kase++; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; idx = 0; build(root[0], 1, n); char op; int l, r, t; ll x; int dfn = 0; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == 'Q') &#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(root[dfn], 1, n, l, r, 0) &lt;&lt; endl; &#125; else if (op == 'C') &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; update(root[dfn], root[dfn + 1], 1, n, l, r, x); dfn++; &#125; else if (op == 'H') &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; t; cout &lt;&lt; query(root[t], 1, n, l, r, 0) &lt;&lt; endl; &#125; else &#123; cin &gt;&gt; dfn; idx = root[dfn + 1] - root[0]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kth number]]></title>
    <url>%2F2018%2F06%2F28%2FKth-number%2F</url>
    <content type="text"><![CDATA[题意求区间第k大 （不带修改 分析一般的权值线段树只能够求全局第k大 （还不如直接排序 怎么求区间第k大呢？ 还是权值线段树的思想 初始版本全是0， 第一个版本加入$a_1$,第二个版本加入$a_2$… 那么我要求$[a_i,a_k]$区间的第k大的话，我只需要在查询的时候用第k个版本减去第(i-1)个版本即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int root[maxn];int lch[maxn &lt;&lt; 5], rch[maxn &lt;&lt; 5], sum[maxn &lt;&lt; 5];int idx;vector&lt;int&gt; a, b;inline int getid(int x) &#123; return lower_bound(b.begin(), b.end(), x) - b.begin() + 1;&#125;// /*// inline void pushup(int rt) &#123; sum[rt] += sum[lson] + sum[rson]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++idx; sum[k] = 0; if (l == r) return; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); // pushup(k);&#125;// */void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++idx; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old] + x; if (l == r) return; int m = l + r &gt;&gt; 1; if (p &lt;= m) update(lch[old], lch[k], l, m, p, x); else update(rch[old], rch[k], m + 1, r, p, x);&#125;int query(int l, int r, int L, int R, int k) &#123; if (l == r) return l; int m = l + r &gt;&gt; 1; int cnt = sum[lch[R]] - sum[lch[L]]; if (k &lt;= cnt) return query(l, m, lch[L], lch[R], k); else return query(m+1,r,rch[L],rch[R],k - cnt);&#125;int main() &#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("2.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; a.resize(n + 5); b.resize(n + 5); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; b.resize(distance(b.begin(), unique(b.begin(), b.end()))); sort(b.begin(), b.end()); idx = 0; build(root[0], 1, b.size()); for (int i = 1; i &lt;= n; i++) &#123; update(root[i - 1], root[i], 1, b.size(), getid(a[i-1]), 1); &#125; int l, r, k; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; b[query(1, b.size(),root[l-1], root[r], k)-1] &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[主席树]]></title>
    <url>%2F2018%2F06%2F27%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树也称可持久化线段树，即支持版本回退。 对于单点更新的线段树，每次更新操作实际上只会更新一条链，即logn个点。 如果将一次更新看做一个新的版本，那么每一个版本只会增加logn个节点。 这样我们就不需要每次重新建一棵线段树，直接利用那些没有更改的点就好。 因此，我们只需要记录每个版本的根节点即可完成历史查询的操作。 当然，这里的版本回退可以有多种理解。 它实际上是一种限制条件。 像普通线段树求带修改的区间和，那么想知道第几次修改后的某一区间和，就需要可持久化线段树了。 像普通权值线段树求只能求全局第k大，想求区间第k大的话就需要可持久化线段树来解决”区间”这个限制了。 再说一下关于空间的问题 因为每次更新都会增加logn个节点，所以开多大空间就要看有多少个版本了。假设版本数为Q, 那 maxn + Q * logQ 应该够了 再说一下关于区间更新的问题 区间更新中，lazy标记是不会下放的。 （留给读者自行思考 sum[k] 维护的是其所覆盖区间的和（加上lazy之后的 但因为查询是自顶向下的，所以query的时候要记得加上每一层的懒惰标记。 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int maxn = 100;const int N = maxn + Qlog(n);int root[maxn]; // 记录每个版本的根节点int sum[N], lch[N], rch[N];int dfn = 0;// 单点修改，区间查询inline void pushup(int rt) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; if (l == r) &#123; sum[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k);&#125;void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old];&#125;void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++dfn; newnode(old, k); if (l == r) &#123; sum[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (p &lt;= m) update(lch[old], lch[k], l, m, p, x); if (p &gt; m) update(rch[old], rch[k], m + 1, r, p, x); pushup(k);&#125;int query(int k, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R); if(m &lt; R) ret += query(rch[k],m+1,r,L,R); return ret;&#125;// 区间更新 区间查询int lazy[N];inline void pushup(int rt, int len) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]] + len * lazy[sum];&#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; lazy[k] = 0; if (l == r) &#123; cin &gt;&gt; sum[k]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k, r - l + 1);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old]; lazy[k] = lazy[old];&#125;void update(int old, int &amp;k, int l, int r, int L, int R, int x) &#123; k = ++dfn; newnode(old, k); if (L &lt;= l &amp;&amp; R &gt;= r) &#123; sum[k] += x * (r - l + 1); lazy[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (m &gt;= L) update(lch[old], lch[k], l, m, L, R, x); if (m &lt; R) update(rch[old], rch[k], m + 1, r, L, R, x); pushup(k, r - l + 1);&#125;int query(int k, int l, int r, int L, int R, int x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k] + x * (r - l + 1); x += lazy[k]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R,x); if(m &lt; R) ret += query(rch[k],m+1,r,L,R,x); return ret;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求逆序对]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题意求区间逆序对 分析权值树状数组 + 离散化 倒着插，每次查询比当前数字小的数的数量的即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e3 + 6;vector&lt;int&gt; a, b;int BIT[maxn];inline int getid(int x) &#123; return lower_bound(b.begin(), b.end(), x) - b.begin() + 1;&#125;inline int lowb(int x) &#123; return x &amp; (-x); &#125;void add(int x) &#123; while (x &lt; b.size()) &#123; BIT[x]++; x += lowb(x); &#125;&#125;int sum(int x) &#123; int ret = 0; while (x &gt; 0) &#123; ret += BIT[x]; x -= lowb(x); &#125; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; a.resize(n + 5); b.resize(n + 5); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; b.resize(distance(b.begin(), unique(b.begin(), b.end()))); sort(b.begin(), b.end()); int ans = 0; clr(BIT, 0); for (int i = n - 1; i &gt;= 0; i--) &#123; ans += sum(getid(a[i]) - 1); add(getid(a[i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SG函数]]></title>
    <url>%2F2018%2F06%2F23%2FSG%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是SG函数我们考虑Nim游戏，其实是有若干个子游戏组合而成的（每一堆石子看做一个子游戏 然后得到了结论：将每一堆石子的数量异或起来，若为零，则先手必败。 再考虑一般情况，某些博弈游戏也可以分解为若干个子游戏，那么Nim游戏的结论是否具有一般性呢？ 那么每个子游戏的”石子数”就是该子游戏SG函数的值。 将每个子游戏的SG函数的值异或起来，如果为0，则先手必败。 SG函数定义SG(x) = mex{SG(y) | y 是 x的后继} 其中mex表示第一个集合中没有的自然数 联系Nim博弈 SG(x) = mex{x-1, x-2 … 0} = x 就是该堆的石子数 一般 SG(0) = 0 即为必败状态， SG(x) != 0, 即为必胜状态 模板1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 100;int f[N];int SG[maxn]; //int S[maxn]; // x 的后继状态void getSG(int n) &#123; SG[0] = 0; // clr(SG,0); for (int i = 1; i &lt; maxn; i++) &#123; clr(S, 0); for (int k = 0; f[k] &lt;= i &amp;&amp; k &lt; n; k++) S[SG[i - f[k]]] = 1; for (int k = 0;; k++) &#123; if (!S[k]) &#123; SG[i] = k; break; &#125; &#125; &#125;&#125;// 单点SG查询void init()&#123; clr(SG,-1);&#125;int getSG(int n, int foo) &#123; if (SG[foo] != -1) return SG[foo]; // int S[N] = &#123;0&#125;; set&lt;int&gt; S; for (int k = 0; f[k] &lt;= foo &amp;&amp; k &lt; n; k++) &#123; int bar = getSG(n, foo - f[k]); S.insert(bar); // S[bar] = 1; &#125; for (int k = 0;; k++) &#123; if (S.find(k) == S.end()) &#123; return SG[foo] = k; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三大博弈游戏]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%B8%89%E5%A4%A7%E5%8D%9A%E5%BC%88%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[参考：ACM BOOK 巴什博弈问题只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。 分析 如果 n=m+1 ，那么由于一次最多只能取 m 个，所以，无论先手拿走多少个，后手都能够一次拿走剩余的物品，后者取胜。 如果 n=(m+1)∗r+s ，(r为任意自然数， s≤m ),先手要拿走s个物品，如果后手拿走 k(k≤m) 个，那么先手再拿走 m+1−k 个，结果剩下 (m+1)∗(r−1) 个，以后保持这样的取法，那么先取者肯定获胜。我们得到如下结论:要保持给对手留下 (m+1) 的倍数，就能最后获胜。 拓展如果我们规定最后取光者输，那么又会如何呢？ (n−1) % (m+1)==0 则后手胜利 先手会重新决定策略，所以不是简单的相反的。 例如 n=15，m=3 后手 先手 剩余 0 2 13 1 3 9 2 2 5 3 1 1 1 0 0 先手胜利 输的人最后必定只抓走一个，如果&gt;1个，则必定会留一个给对手 威佐夫博弈问题有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 分析我们用$(a_k,b_k)$,$(a_k≤b_k,k=0,1,2,…,n)$表示两堆物品的数量并称其为局势，如果甲面对 （0，0） ，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是： （0，0） 、 （1，2） 、 （3，5） 、 （4，7） 、 （6，10） 、 （8，13） 、 （9，15） 、 （11，18） 、 （12，20） 。 可以看出： $a_0=b_0=0$ , $a_k$ 是未在前面出现过的最小自然数,而$b_k=a_k+k$ 。 满足$a_k=k\times (1+\sqrt 5)/2,b_k=a_k+k$后手必胜，否则先手必胜。 Nim博弈问题有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。 分析假设n堆石子，每堆石子的数量为$a_i$ 若$a_1\bigoplus a_2…\bigoplus a_n = 0$ 则先手必败 证明： 若$a_1\bigoplus a_2…\bigoplus a_n \neq 0$ 那么一定可以通过从其中一堆拿一定数量的石子使得$a_1\bigoplus a_2…\bigoplus a_n = 0$ 若$a_1\bigoplus a_2…\bigoplus a_n = 0$,则不管怎么拿，拿完之后$a_1\bigoplus a_2…\bigoplus a_n \neq 0$ 若想不明白可以考虑 数字的每一位]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu3938 Portal]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu3938-Portal%2F</url>
    <content type="text"><![CDATA[来源：题目 题意给你一张无向图，求有多少条路径使得路径上的花费小于L，这里路径上的花费是这样规定的，a、b两点之间的多条路径中的最长的边最小值 分析将所有边按权值排序，从权值最小的边开始取。 如果两点不在同一个集合，则合并（相当于使两个集合的点都可以互达） 答案加 sum[u] * sum[v] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4 + 5;int par[maxn];struct Edge &#123; int u, v, w; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;struct Query &#123; int l, id, ans; bool operator&lt;(const Query &amp;A) const &#123; return id &lt; A.id; &#125;&#125;;Query q[maxn];vector&lt;Edge&gt; edges;int sum[maxn];bool cmpl(const Query A, const Query B) &#123; return A.l &lt; B.l; &#125;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n, m, Q; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q) &#123; int u, v, w, L; edges.clear(); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.push_back(Edge&#123;u, v, w&#125;); &#125; for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; q[i].l; q[i].id = i; q[i].ans = 0; &#125; for (int i = 1; i &lt;= n; i++) par[i] = i, sum[i] = 1; sort(edges.begin(), edges.end()); sort(q, q + Q, cmpl); int foo = 0; for (int i = 0; i &lt; Q; i++) &#123; while (foo &lt; m &amp;&amp; edges[foo].w &lt;= q[i].l) &#123; int u = find(edges[foo].u); int v = find(edges[foo].v); if (u != v) &#123; par[u] = v; q[i].ans += sum[u] * sum[v]; sum[v] += sum[u]; &#125; ++foo; &#125; if (i) q[i].ans += q[i - 1].ans; &#125; sort(q, q + Q); for (int i = 0; i &lt; Q; i++) cout &lt;&lt; q[i].ans &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu3234 Exclusive-OR]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu3234-Exclusive-OR%2F</url>
    <content type="text"><![CDATA[分析带权并查集 添加一个n点，使其值为0，这样任何值异或它都是本身。 然后注意查询的时候，先除去根节点是n的。 然后对于有相同根节点的节点，如果它的数量是奇数那么一定无法确定，偶数则可以确定。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e4 + 5;int par[maxn], val[maxn];int a[30];bool flag;int n;inline int find(int x) &#123; if (x == par[x]) return x; int fa = par[x]; par[x] = find(par[x]); val[x] ^= val[fa]; return par[x];&#125;inline void merge(int u, int v, int x, int i) &#123; int fu = find(u); int fv = find(v); if (fu == fv) &#123; if ((val[u] ^ val[v]) != x) &#123; // cout &lt;&lt; val[u] &lt;&lt; ' ' &lt;&lt; val[v] &lt;&lt; ' ' &lt;&lt; (val[u] ^ val[v]) &lt;&lt; endl; // cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl; flag = true; cout &lt;&lt; "The first " &lt;&lt; i &lt;&lt; " facts are conflicting." &lt;&lt; endl; &#125; &#125; else &#123; if (fu == n) swap(fu, fv); val[fu] = val[u] ^ val[v] ^ x; par[fu] = fv; &#125;&#125;void query(int m) &#123; vector&lt;int&gt; fas; vector&lt;int&gt; sons[30]; int ret = 0; for (int i = 0; i &lt; m; i++) &#123; int fa = find(a[i]); if (fa == n) ret ^= val[a[i]]; else &#123; int k = 0; for (k = 0; k &lt; fas.size(); k++) &#123; if (fas[k] == fa) &#123; break; &#125; &#125; if (k == fas.size()) fas.pb(fa); sons[k].pb(a[i]); &#125; &#125; for (int i = 0; i &lt; fas.size(); i++) &#123; if (sons[i].size() &amp; 1) &#123; cout &lt;&lt; "I don't know." &lt;&lt; endl; return; &#125; for (int k = 0; k &lt; sons[i].size(); k++) &#123; ret ^= val[sons[i][k]]; &#125; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int kase = 1; int Q; while (cin &gt;&gt; n &gt;&gt; Q) &#123; flag = false; if (!n &amp;&amp; !Q) break; cout &lt;&lt; "Case " &lt;&lt; kase++ &lt;&lt; ":" &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) par[i] = i, val[i] = 0; int idx = 0; string line; char op; for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; line; if (line == "I") &#123; idx++; int k = 0; while (cin &gt;&gt; a[k++]) &#123; if (cin.get() == '\n') &#123; break; &#125; &#125; if(flag) continue; if (k == 2) merge(a[0], n, a[1], idx); else merge(a[0], a[1], a[2], idx); &#125; else&#123; int k ; cin &gt;&gt; k; for(int i=0;i&lt;k;i++) cin &gt;&gt; a[i]; if(flag) continue; query(k); &#125; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zoj3261 Connections in Galaxy War 删边]]></title>
    <url>%2F2018%2F06%2F23%2Fzoj3261-Connections-in-Galaxy-War-%E5%88%A0%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[删边模板题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// ybmj// #include &lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;struct P &#123; string op; int u, v;&#125;;P ops[maxn];int par[maxn], w[maxn];pii a[maxn];set&lt;pii&gt; del;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;inline void merge(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return; if (w[u] &gt; w[v]) par[v] = u; else if (w[u] == w[v]) &#123; if (u &gt; v) par[u] = v; else par[v] = u; &#125; else par[u] = v;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, m, Q; int kase = 0; while (cin &gt;&gt; n) &#123; if(kase) cout &lt;&lt; '\n'; kase++; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i]; par[i] = i; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a[i].first &gt;&gt; a[i].second; if(a[i].first &gt; a[i].second) swap(a[i].first,a[i].second); &#125; cin &gt;&gt; Q; del.clear(); for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; ops[i].op; if (ops[i].op == "destroy") &#123; cin &gt;&gt; ops[i].u &gt;&gt; ops[i].v; if(ops[i].u &gt; ops[i].v) swap(ops[i].u, ops[i].v); del.insert(mp(ops[i].u, ops[i].v)); &#125; else cin &gt;&gt; ops[i].u; &#125; for (int i = 0; i &lt; m; i++) &#123; if (del.find(a[i]) != del.end()) continue; // cout &lt;&lt; a[i].first &lt;&lt; ' ' &lt;&lt; a[i].second &lt;&lt; endl; merge(a[i].first, a[i].second); &#125; vector&lt;int&gt; ans; int u, v; for (int i = Q - 1; i &gt;= 0; i--) &#123; if (ops[i].op == "query") &#123; u = ops[i].u; int fa = find(u); if (w[fa] &gt; w[u]) ans.pb(fa); else ans.pb(-1); &#125; else &#123; u = ops[i].u; v = ops[i].v; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; merge(u, v); &#125; &#125; for(int i=ans.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; ans[i] &lt;&lt; '\n'; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu2473 Junk-Mail Filter 删点]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu2473-Junk-Mail-Filter-%E5%88%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[来源：题目 删点模板题 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 1e9 + 7;const int maxn = 2e6 + 5;int par[maxn];bool vis[maxn];int idx;inline int find(int u)&#123; return u == par[u] ? u : par[u] = find(par[u]);&#125;void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; par[u] = v; &#125;&#125;void del(int u) &#123; par[u] = idx++; &#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n, m; int kase = 1; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for(int i=0;i&lt;n;i++) par[i] = i+n; for(int i=n;i&lt;n+m+n+5;i++) par[i] = i; idx = 2*n; char op; int u, v; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == 'M') &#123; cin &gt;&gt; u &gt;&gt; v; merge(u, v); &#125; else &#123; cin &gt;&gt; u; del(u); &#125; &#125; clr(vis,0); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; int x = find(i); if(!vis[x])&#123; vis[x] = true; ++ans; &#125; &#125; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[带权并查集带权指 子节点与父节点之间存在限制条件， 如子节点在父节点左边的x米处 接下来面临的两个难点： 路径压缩时权值的变化 两棵树合并时权值的变化 1234567int find(int x)&#123; if(x == par[x]) return x; int fa = par[x]; par[x] = find(par[x]); val[x] += val[fa]; return par[x];&#125; 如图，合并时新建边的权值应该为多少呢？ 这个具体题目具体计算。 这里我们要合并2,4节点，即2节点在4节点左边8米处。 那么 8 = 2 + ? - 3 -&gt; ? = 9 删点因为并查集是一个树形结构，所以你很难在很低的时间复杂度内，删除一个点，并且维护原来的关系不变。 这里我们对每个节点初始的时候连到一个相应的虚父节点，比如1节点就连到1+n节点。 这样每次合并都用其父节点进行合并。 删除某个节点的时候直接将该节点指向一个新节点即可。 12345678910int idx;void init(int n)&#123; for(int i=0;i&lt;n;i++) par[i] = i+n; for(int i=n;i&lt;n+N;i++) par[i] = i; idx = 2 * n; &#125;void del(int x)&#123; par[x] = idx++;&#125; 删边将所有操作离线。 我们先把最后的状态建出来，然后逆着查询，这样原来的删边操作就变成了加边操作。]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPFA]]></title>
    <url>%2F2018%2F06%2F22%2FSPFA%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243vector&lt;pii&gt; G[maxn];bool inq[maxn];int cnt[maxn]; // 记录入队次数int d[maxn];inline void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;inline void addedge(int u,int v,int w)&#123; G[u].pb(mp(v,w)); // G[v].pb(mp(u,w));&#125;bool spfa(int s,int n)&#123; for(int i=0;i&lt;=n;i++) &#123; d[i] = INF; inq[i] = 0; cnt[i] = 0; &#125; d[s] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = true; cnt[s]++; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = false; for(auto V : G[u])&#123; int v = V.first; int w = V.second; if(d[v] &gt; d[u] + w)&#123; // 求最长路的话改成 &lt; d[v] = d[u] + w; if(!inq[v])&#123; inq[v] = true; cnt[v]++; q.push(v); if(cnt[v] &gt;= n) return false; &#125; &#125; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贝壳找房函数最值]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题意来源：计算之道2018复赛g 贝壳找房的攻城狮最近在研究一次函数 $f(x) = ax + b$。 现在有$n$个一次函数，$f_i(x) = a_ix+b_i$ 容易发现，一次函数嵌套一次函数，还是一次函数。 $\displaystyle f_{i}(f_{j}(x)) = a_{i} ( a_{j}x + b_{j}) + b_{i}$ 给定$x$，并且对于所有的$f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。 分析考虑两个函数的互相嵌套$ax + b$ 和 $cx+d$ $acx + ad + b$ 和 $acx + cb + d$ 所以只要按$ad + b$和$cb + d$排序即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4+5;struct P&#123; int u,v; bool operator&lt;(const P &amp;A) const&#123; int a = u * A.v + v; int b = A.u * v + A.v; return a &lt; b; &#125;&#125;;P a[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,x; cin &gt;&gt; n &gt;&gt; x; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i].u; &#125; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i].v; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; x = x * a[i].u + a[i].v; x %= 10; &#125; cout &lt;&lt; x &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贝壳找房魔法师顾问]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E9%AD%94%E6%B3%95%E5%B8%88%E9%A1%BE%E9%97%AE%2F</url>
    <content type="text"><![CDATA[题意来源:计算之道2018复赛d 贝壳找房在遥远的传奇境外，找到了一个强大的魔法师顾问。他有 22 串数量相同的法力水晶，每个法力水晶可能有不同的颜色。为了方便起见，可以将每串法力水晶视为一个长度不大于$10^5$ ，字符集不大于 $10^5$ 的字符串。现在魔法师想要通过一系列魔法使得这两个字符串相同。每种魔法形如 $(u,\ v),\ u,\ v \le 10^5$ ，可以将一个字符$u$改成一个字符 $v$，并且可以使用无限次。出于种种原因，魔法师会强行指定这两个串能否进行修改。 若失败输出 -1，否则输出最少使用的魔法的种类数。 输入格式一个正整数$n(n \le 10^5)$ 表示每个字符串的长度。 接下来两行每行首先输入一个单词（”Variable”或”Constant”），”Variable”表示这个字符串能进行修改，”Constant”表示这个字符串不能进行修改，然后n个正整数表示一个字符集不大于$10^5$ 的字符串。 分析对于CC：直接比较即可。 对于VV：问题可以转化为给一张无向图，最少用几条边可以保持原图的联通性（可以新建） 每一个连通分量里面选n-1条边即可。 对于CV(VC)：问题转化为给一张有向图，最少用几条边可以保持原图的连通性（可以新建） 对于每一个联通分量，如果里面不含强连通分量，则选n-1条边即可 如果里面含有强连通分量，则最少需要n条边 可以使这张图变为强连通。 对每个联通分量用拓扑排序判环。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;string a[2][maxn];string b[2] = &#123;"Constant", "Variable"&#125;;map&lt;string, int&gt; maps;int par[maxn];vector&lt;int&gt; G[maxn], GG[maxn];bool vis[maxn];int in[maxn];inline int find(int x) &#123; return par[x] &lt; 0 ? x : par[x] = find(par[x]); &#125;void dfs(int id, int u) &#123; GG[id].pb(u); vis[u] = true; for (auto &amp;v : G[u]) &#123; if (!vis[v]) &#123; dfs(id, v); &#125; &#125;&#125;int topo(int id) &#123; queue&lt;int&gt; q; int cnt = 0; for (auto &amp;v : GG[id]) &#123; if (!in[v]) &#123; q.push(v); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); cnt++; for (auto &amp;v : G[u]) &#123; if (in[v] &gt; 0) &#123; in[v]--; if (!in[v]) q.push(v); &#125; &#125; &#125; if (cnt == GG[id].size()) return GG[id].size() - 1; else return GG[id].size();&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; string s[2]; for (int i = 0; i &lt; 2; i++) &#123; cin &gt;&gt; s[i]; for (int k = 0; k &lt; n; k++) cin &gt;&gt; a[i][k]; &#125; bool flag = true; if (s[0] == b[0] &amp;&amp; s[1] == b[0]) &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] != a[1][i]) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else if (s[0] == b[1] &amp;&amp; s[1] == b[1]) &#123; for (int i = 0; i &lt; maxn; i++) par[i] = -1; maps.clear(); int idx = 1; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] == a[1][i]) continue; int u = maps[a[0][i]] == 0 ? maps[a[0][i]] = idx++ : maps[a[0][i]]; int v = maps[a[1][i]] == 0 ? maps[a[1][i]] = idx++ : maps[a[1][i]]; u = find(u); v = find(v); if (u != v) &#123; par[v] += par[u]; par[u] = v; &#125; &#125; ll ans = 0; for (int i = 1; i &lt; idx; i++) &#123; if (par[i] &lt; -1) &#123; ans += -par[i] - 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; maxn; i++) par[i] = -1; for (int i = 0; i &lt; maxn; i++) G[i].clear(), GG[i].clear(); clr(in, 0); clr(vis, 0); maps.clear(); int idx = 1; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] == a[1][i]) continue; int u = maps[a[0][i]] == 0 ? maps[a[0][i]] = idx++ : maps[a[0][i]]; int v = maps[a[1][i]] == 0 ? maps[a[1][i]] = idx++ : maps[a[1][i]]; G[u].pb(v); in[v]++; u = find(u); v = find(v); if(u != v) par[v] = u; &#125; int id = 0; map&lt;int,int&gt; rt; for(int i=1;i&lt;idx;i++)&#123; if(par[i] &lt; 0)&#123; rt[i] = id++; &#125; &#125; ll ans = 0; for (int i = 1; i &lt; idx; i++) &#123; int u = find(i); GG[rt[u]].pb(i); &#125; for (int i = 0; i &lt; id; i++) &#123; ans += topo(i); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[01背包]]></title>
    <url>%2F2018%2F06%2F16%2F01%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[出自《背包九讲》 问题有$N$个物品和一个容量为$V$的背包。放入第$i$件物品体积是$c_i$,得到价值$w_i$。 求解将那些物品装入背包可使得价值总和最大。 思想$dp[i][j]$: 表示前$i$件物品中选若干件，放入容量为$j$的背包中，可获得的最大价值。 考虑第i件物品放或不放，那么转移就是： $$dp[i][j] = Max(dp[i-1][j], dp[i-1][j-c_i] + w_i)$$ 优化1因为我们发现当前状态只和上一个状态相关，因此第一维实际上只要存2个数即可。 优化2我们通过转移的顺序发现，如果我们倒过来进行转移，只需要一维即可。 初始化问题如果是恰好装满， 那么$dp[0][i]$都要初始化为0， 而其他都要初始化为负无穷。 如果是不必装满，那么$dp[0][i]$要初始化为0， 转移的时候改一改即可。 变形容量和价值换一换，$dp[i][j]$:表示前i件物品，价值为j的最小容量。 一样做。 可达性背包问$N$个物品，容量为$V$的背包，可以组成的价值的种类数。 需要用$bitset$优化。 $bitset$ 中的每一位表示这个价值是否能达到。 12345678910111213141516bitset&lt;maxn&gt; bt[2][maxn];for (int j = 0; j &lt;= V; j++) &#123; bt[0][j].reset(); bt[1][j].reset();&#125;for (int i = 1; i &lt;= N; i++) &#123; int id = i &amp; 1; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) bt[id][j] = bt[id ^ 1][j]; else bt[id][j] |= bt[id ^ 1][j - c[i]].set(w[i]); &#125;&#125;cout &lt;&lt; bt[N &amp; 1][V].count() &lt;&lt; endl; 代码12345678910111213141516171819202122232425262728293031323334353637383940// 恰好装满clr(dp,0xc0); // 初始化负无穷clr(dp[0],0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = c[i]; j &lt;= V; j++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); &#125;&#125;// 不必装满clr(dp[0], 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); &#125;&#125;// 优化1clr(dp[0], 0);for (int i = 1; i &lt;= N; i++) &#123; int id = i &amp; 1; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) dp[id][j] = dp[id ^ 1][j]; else dp[id][j] = max(dp[id ^ 1][j], dp[id ^ 1][j - c[i]] + w[i]); &#125;&#125;cout &lt;&lt; dp[N &amp; 1][V] &lt;&lt; endl;// 优化2clr(dp, 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = V; j &gt;= c[i]; j++) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125;&#125;cout &lt;&lt; dp[V] &lt;&lt; endl; 从n中类型的东西挑m个(可选同种) (组合数学)123456789for(int i=1;i&lt;=n;i++)&#123; dp[i][1] = i; dp[0][i] = 0;&#125;for(int i=1;i&lt;=n;i++)&#123; for(int k=2;k&lt;=m;k++)&#123; dp[i][k] = dp[i-1][k] + dp[i][k-1]; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>背包相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kuro and GCD and XOR ans SUM]]></title>
    <url>%2F2018%2F05%2F18%2FKuro-and-GCD-and-XOR-ans-SUM%2F</url>
    <content type="text"><![CDATA[题意来源:cf979D q次询问，每次询问有两种操作： 向数组中插入一个u $(1 \leq u \leq 10^5)$ 给定x,k,s, 要从数组中找一个数v，使得其满足：$k \mid GCD(x, v)$, $x + v \leq s$, $x \oplus v$ $1 \leq x, k, s \leq 10^{5}$ 分析01字典树 + 暴力 首先考虑$x \oplus v$: 即在一个数组中找到一个数与给定的数的异或值最大， 这个经典的问题可以用01字典树解决。 再考虑$k \mid GCD(x, v)$: 可以推出 $k \mid x , k \mid v$, 我们可以对1~1e5中每个数建一棵字典树，然后将所有能被k整除的数插入到k的字典树中。 然后我们只要在这棵树上找与x异或最大的数即可。 最后考虑$x + v \leq s$: 对于字典树的每个节点，去维护一个最小的v值，如果要查询的x + val[root] &gt; s 肯定是不行的 字典树的内存设置： 一共要插1e5个数,他们总共的因子个数不超过$nlog(n)$,每个数的二进制长度为20,所以maxnode = 1e5 log(1e5) * 20 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int maxnode = 2e7 + 5;const int types = 2;bool vis[maxn];struct Trie &#123; int root[maxn]; int ch[maxnode][types]; int val[maxnode]; int sz; void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; root[i] = i; val[i] = INF; clr(ch[i], 0); &#125; sz = maxn; &#125; void insert(int x, int key) &#123; int u = root[x]; val[u] = min(val[u], key); for (int i = 18; i &gt;= 0; i--) &#123; int v = (key &gt;&gt; i) &amp; 1; if (ch[u][v] == 0) &#123; clr(ch[sz], 0); val[sz] = INF; ch[u][v] = sz++; &#125; u = ch[u][v]; val[u] = min(val[u], key); &#125; // assert(sz &lt; maxnode); &#125; int query(int x, int key, int s) &#123; int u = root[x]; if (val[u] &gt; s) return -1; int ret = 0; for (int i = 18; i &gt;= 0; i--) &#123; int v = (key &gt;&gt; i) &amp; 1; if (ch[u][v ^ 1] != 0 &amp;&amp; val[ch[u][v ^ 1]] &lt;= s) &#123; ret += ((v ^ 1) &lt;&lt; i); u = ch[u][v ^ 1]; &#125; else &#123; ret += (v &lt;&lt; i); u = ch[u][v]; &#125; &#125; return ret; &#125;&#125;;Trie trie;vector&lt;int&gt; f[maxn];void init() &#123; for (int i = 0; i &lt; maxn; i++) f[i].clear(); for(int i=1;i&lt;maxn;i++)&#123; for(int k = i;k &lt; maxn;k+=i)&#123; f[k].pb(i); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; trie.init(); clr(vis, 0); init(); for (int i = 0; i &lt; n; i++) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int u; cin &gt;&gt; u; if (vis[u]) continue; vis[u] = true; for (auto i : f[u]) &#123; trie.insert(i, u); &#125; &#125; else &#123; int x, k, s; cin &gt;&gt; x &gt;&gt; k &gt;&gt; s; if (x % k != 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue; &#125; cout &lt;&lt; trie.query(k, x, s - x) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2018%2F05%2F15%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树定义 左右子树的高度之差的绝对值不超过１ 左右子树都是平衡二叉树 可以自平衡的二叉搜索树，使得每次查找一个值的复杂度都是$O(log_2n)$ 具体实现有： 红黑树, AVL, Treap, Splay, SBT, kd-tree. Zig顺时针旋转 Zag逆时针旋转 AVL平衡因子(balance factor)：当前节点左子树高度与右子树高度的差 限制条件： 其中各节点平衡因子的绝对值均不超过１ 一般规定：空树高度取-1,单节点子树（叶节点）高度取0. ###]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>平衡二叉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[（ 蓝书上的图比较形象！ lowbit(x) 可以理解为BIT[x]所管辖范围的长度 一般就用来做带修改的前缀和。 像什么区间最值是无法做的。 1234567891011121314151617181920212223242526// 数组下标必须从1开始// 单点更新区间查询int BIT[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l,int r)&#123; int ret = 0; for(int i=l-1;i&gt;0;i-=lowb(i)) ret -= BIT[i]; for(int i=r;i&gt;0;i-=lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x,int y,int n)&#123; for(int i=x;i&lt;=n;i+=lowb(i)) BIT[i] += y;&#125;//区间更新单点查询int diff[maxn];inline int lowb(int x) &#123;return x &amp;(-x);&#125;inline int query(int x)&#123; int ret = 0; for(int i=x;i&gt;0;i-=lowb(i)) ret += diff[i]; return ret;&#125;inline void update(int l,int r,int val,int n)&#123; for(int i=l;i&lt;=n;i+=lowb(i)) diff[i] += val; for(int i=r+1;i&lt;=n;i+=lowb(i)) diff[i] -= val; &#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[离散化]]></title>
    <url>%2F2018%2F05%2F09%2F%E7%A6%BB%E6%95%A3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1234567891011// c++11vector&lt;int&gt; a,b;for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i]; b[i] = a[i];&#125;b.resize(distance(b.begin(),unique(b.begin(),b.end())));inline int getid(int x)&#123; return lower_bound(b.begin(),b.end(),x) - b.begin() + 1;&#125; 12345678for(int i=0;i&lt;n;i++)&#123; A[i] = B[i];&#125;sort(B,B+n);int size = unique(B,B+n) - B;for(int i=0;i&lt;n;++)&#123; A[i] = lower_bound(B,B+size,A[i]) - B + 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Perfect Groups]]></title>
    <url>%2F2018%2F05%2F09%2FPerfect-Groups%2F</url>
    <content type="text"><![CDATA[题意来源:cd980D 给定一个长度为n的数组，对于它的每个子段，最少需要分几组，使得每组中的元素，两两乘积都为完全平方数？ $1 \leq n \leq 5000$ 分析首先我们考虑如何判断两个数的乘积是否为完全平方数？ 很显然$O(\sqrt n)$是不行滴。 我们对每个数进行质因数分解，将其所有的平方因子全部去掉，这样只需要判断两数是否相等即可判断其乘积是否为完全平方数。 然后对于区间[i,k]中所有相等的数字可以分到一组，那么区间[i,k]的答案就是不同的数字的数量 暴力枚举所有子段即可。 需要注意的是0可以代替任何数。 而且若一个子段里全是0，那么其值应为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4; int a[maxn],b[maxn],lastpos[maxn],cnt[maxn];map&lt;int,int&gt; last;inline void work(int idx)&#123; int x = a[idx]; int flag = x &gt; 0 ? 1 : -1; x *= flag; for(int i=2;i&lt;=sqrt(x);i++)&#123; while(x &amp;&amp; x % (i*i) == 0) x /= i*i; &#125; a[idx] = x * flag;&#125;int init(int n)&#123; last.clear(); for(int i=1;i&lt;=n;i++)&#123; work(i); &#125; for(int i=1;i&lt;=n;i++)&#123; b[i] = a[i]; &#125; sort(b+1,b+1+n); int sz = unique(b+1,b+1+n) - b - 1; bool flag = false; int ret = -1; for(int i=1;i&lt;=n;i++)&#123; if(a[i] == 0) flag = true; a[i] = lower_bound(b+1,b+1+sz,a[i]) - b ; if(flag &amp;&amp; ret == -1) ret = a[i]; lastpos[i] = last[a[i]]; last[a[i]] = i; &#125; return ret;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; int zero = init(n); clr(cnt,0); for(int i=1;i&lt;=n;i++)&#123; int val = 0; for(int k=i;k&lt;=n;k++)&#123; if(lastpos[k] &lt; i &amp;&amp; a[k] != zero)&#123; val = val + 1; &#125; cnt[val]++; &#125; &#125; cnt[1] += cnt[0]; for(int i=1;i&lt;=n;i++) cout &lt;&lt; cnt[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cards Game]]></title>
    <url>%2F2018%2F05%2F09%2FCards-Game%2F</url>
    <content type="text"><![CDATA[题意有n堆牌，每一堆牌有m张，alice只可以每一堆牌的最上面的一张，bob只可以取每一堆牌最下面的一张，每张牌都有一个权值。 两人都采取最优策略，问最后alice和bob各取了多少? $1≤n,m≤100$ 分析这有个性质，对于偶数张的牌堆，alice和bob一定是各取一半，对于奇数张的牌堆，最中间那张从大到小排序后alice和bob按顺序拿 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 105;int a[maxn];vector&lt;int&gt; mid;int main()&#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; mid.clear(); int alice = 0, bob = 0; for(int i=0;i&lt;n;i++)&#123; int m; cin &gt;&gt; m; for(int k=0;k&lt;m;k++)&#123; cin &gt;&gt; a[k]; if(k&lt;m/2)alice += a[k]; else bob += a[k]; &#125; if(m &amp; 1)&#123; bob -= a[m/2]; mid.pb(a[m/2]); &#125; &#125; sort(mid.begin(),mid.end(),greater&lt;int&gt;()); for(int i=0;i&lt;mid.size();i++)&#123; if(i &amp; 1) bob += mid[i]; else alice += mid[i]; &#125; cout &lt;&lt; alice &lt;&lt; ' ' &lt;&lt; bob &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beautiful Land]]></title>
    <url>%2F2018%2F05%2F09%2FBeautiful-Land%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛F 超大容量01背包 分析dp[i][k] 表示前i个物品组成价值为k的最小容量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4+5;int c[105],v[105];int dp[105][maxn]; // dp[i][k] 前i个物品组成价值为k的最小容量 int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,C; cin &gt;&gt; n &gt;&gt; C; int sum = 0; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; c[i] &gt;&gt; v[i]; sum += v[i]; &#125; clr(dp[0],0x3f); dp[0][0] = 0; for(int i=1;i&lt;=n;i++)&#123; for(int k=0;k&lt;=sum;k++)&#123; if(k &gt;= v[i])&#123; dp[i][k] = min(dp[i-1][k-v[i]] + c[i],dp[i-1][k]); &#125; else dp[i][k] = dp[i-1][k]; &#125; &#125; int ans = 0; for(int i=0;i&lt;=sum;i++)&#123; if(dp[n][i] &lt;= C)&#123; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[A Simple Problem]]></title>
    <url>%2F2018%2F05%2F09%2FA-Simple-Problem%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛E 给你两个数组，问你从第一个数组中存在多少个子段与第二个数组同构？ 同构的意思是两个数组的结构相同： aabb 和 ccdd同构$1 \leq n \leq 2 \times 10^5$ $1 \leq m \leq 10^5$ 分析KMP 根据这个同构的特点，我们只需要记录上一个和当前数字相同的距离即可。如果没有则记为-1. 如：121 2 0 2 0 1 -&gt; -1 -1 -1 2 2 51 2 1 2 -&gt; -1 -1 2 2 然后跑kmp 注意这里的kmp要魔改一下下 如果距离大于m的要当做-1看待 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;int s[maxn], p[maxn];int last[15];struct MP&#123; int back[maxn]; void getfail(int m)&#123; int i,k; k = back[0] = -1; i = 0; while(i &lt; m)&#123; while(k != -1 &amp;&amp; ((p[i] &gt; k) ? (p[k] != -1) : (p[i] != p[k]))) k = back[k]; back[++i] = ++k; &#125; &#125; int match(int n,int m)&#123; int i = 0,k = 0; int ret = 0; getfail(m); while(i &lt; n)&#123; while(k != -1 &amp;&amp; ((s[i] &gt; k) ? (p[k] != -1) : (s[i] != p[k]))) k = back[k]; ++i;++k; if(k &gt;= m)&#123; ret++; k = back[k]; &#125; &#125; return ret; &#125;&#125;;MP kmp;void init(int n, int m) &#123; clr(last, -1); for (int i = 0; i &lt; n; i++) &#123; int temp = s[i]; if (last[s[i]] == -1) s[i] = -1; else s[i] = i - last[s[i]]; last[temp] = i; &#125; clr(last, -1); for (int i = 0; i &lt; m; i++) &#123; int temp = p[i]; if (last[p[i]] == -1) p[i] = -1; else p[i] = i - last[p[i]] ; last[temp] = i; &#125;&#125;void debug(int n, int m) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 0; i &lt; m; i++) cout &lt;&lt; p[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;int main() &#123; /*j#ifndef freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif*/ std::ios::sync_with_stdio(false); int n, k; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; s[i]; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i]; init(n, m); // debug(n, m); int ans = kmp.match(n, m); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trees on Sale]]></title>
    <url>%2F2018%2F05%2F08%2FTrees-on-Sale%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛B 给定N，K $(1 \leq N \leq 10^5, 1 \leq K \leq 10^{12})$ 我是一个花店老板，我每次营业之前都会将花打包起来，每一束最少有一枝花。 已知每日都会有N个人来买花，每个人最多一次买K枝花，问我最少需要包几束花。 可以将若干束花合成一束，但不能把一束拆开。 分析假如N个人都买一枝花，那么我们需要N束只含一枝花的。 假如N个人都买两枝花，那么我们可以利用之前的N束花， 所以我们只需要 N - N/2 假如N个人都买三枝花，那么我们可以利用之前的N + N2 束花， 所以我们只需要N - (N + N 2) / 3 但是这样下去是O(K)的，不行。 我们可以发现这么一个通式： 第i枝花需要: max(0, N - (preSum) / i) 所以我们可以通过 preSum / i + 1,来跳到下一个需要计算的。 代码123456789101112131415161718192021222324252627282930313233343536//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0; int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); ll n,k; while(cin &gt;&gt; n &gt;&gt; k)&#123; ll sum = 0; ll ans = 0; ll i = 1; while(i &lt;= k)&#123; ll cnt = n - sum / i; sum += cnt * i; ans += cnt; i = sum / n + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beauty of Trees]]></title>
    <url>%2F2018%2F05%2F08%2FBeauty-of-Trees%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛A 给你m个询问，每次询问包括一个区间，以及这个区间的异或和。 现在问你哪几个询问是错的。 $1≤M≤10^5$ $10^5≤l_i ≤r_i≤10^5$ 分析逻辑判断 带权并查集 对于每个l,r ： 若l和r不在一个集合中，则合并两个集合。 若l和r在同一个集合中，则先将l和r进行路径压缩，然后进行权值验证。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5+5;int par[maxn],val[maxn]; int find(int x)&#123; if(par[x] == x) return x; int rt = find(par[x]); // ! val[x] = val[x] ^ val[par[x]]; return par[x] = rt;&#125;void merge(int l,int r,int w)&#123; int pl = find(l); int pr = find(r); if(pl != pr)&#123; val[pr] = val[l] ^ w ^ val[r]; // ! par[pr] = pl; &#125;&#125;bool same(int l,int r)&#123; return find(l) == find(r);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int n,m; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i=0;i&lt;=n;i++) par[i] = i; clr(val,0); bool flag = true; for(int i=0;i&lt;m;i++)&#123; int l,r,w; cin &gt;&gt; l &gt;&gt; r &gt;&gt; w; l--; if(!same(l,r)) merge(l,r,w); else if((val[r] ^ val[l]) != w)&#123; flag = false; cout &lt;&lt; i + 1 &lt;&lt; endl; &#125; &#125; if(flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125; &#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经纬度]]></title>
    <url>%2F2018%2F05%2F05%2F%E7%BB%8F%E7%BA%AC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题意来源:牛客练习赛17D 给定地球的两个经纬度坐标，问这两个点的球面距离和直线距离的差。假设地球为球体，半径为6371009米。 分析球面上任意两点间弧长公式： 设所求点A ，纬度β1 ，经度α1 ；点B ，纬度β2 ，经度α2。则距离S=R·arc cos[cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2]，其中R为球体半径。 直线距离可以用 $S = R\times \theta$ $L = 2 \times R \times sin(\theta/2)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double pi = acos(-1); int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; double R = 6371009; while(T--)&#123; double lat1,lng1,lat2,lng2; cin &gt;&gt; lat1 &gt;&gt; lng1 &gt;&gt; lat2 &gt;&gt; lng2; lat1 = lat1 / 180 * pi; lng1 = lng1 / 180 * pi; lat2 = lat2 / 180 * pi; lng2 = lng2 / 180 * pi; double lh = R * acos(cos(lat1)*cos(lat2)*cos(lng2-lng1) + sin(lat1)*sin(lat2)); // cout &lt;&lt; lh &lt;&lt; endl; double theta = lh / R; theta /= 2; // cout &lt;&lt; theta &lt;&lt; endl; double l = R * sin(theta) * 2; cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; lh - l &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[好位置]]></title>
    <url>%2F2018%2F05%2F05%2F%E5%A5%BD%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[题意来源:牛客练习赛17B 给出两个串s和x 定义s中的某一位i为好的位置，当且仅当存在s的子序列 满足y=x且存在j使得i=kj成立。 问s中是否所有的位置都是好的位置。 输入描述: 一行两个字符串s，x,这两个串均由小写字母构成。 1 &lt;= |s|, |x| &lt;= 200000 输出描述: Yes表示是。 No表示不是。 分析dp[i] 表示以s[i]结尾的最长匹配长度。 然后可以发现这个dp数组满足一个性质,所有的上升子序列长度都为x.size() 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5+5;int dp[maxn];int last[200]; int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); string s,x; while(cin &gt;&gt; s &gt;&gt; x)&#123; int now = 0; dp[0] = 0; clr(last,-1); bool flag= true; for(int i=1;i&lt;=s.size();i++)&#123; if(now &lt; x.size() &amp;&amp; s[i - 1] == x[now])&#123; now ++ ; dp[i] = dp[i-1] + 1; last[s[i-1] - 'a'] = dp[i]; &#125; else&#123; dp[i] = last[s[i-1] - 'a']; if(dp[i] == -1)&#123; flag = false; break; &#125; &#125; &#125; if(!flag)&#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; int val = 0; for(int i=1;i&lt;=s.size();i++)&#123; if(dp[i] &lt; val) val = dp[i]; else if(dp[i] == val + 1) val++; &#125; if(val == x.size()) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[算法导论 学习博客 求最大值$$\begin{cases} B - A \leq c \\ C - A \leq b \\ C - B \leq a \\ \end{cases}$$ 这样求A到C的最大值就是 求min{a+c, b}, 即建图跑最短路。 求最小值$$\begin{cases} B - A \geq c \\ C - A \geq b \\ C - B \geq a \\ \end{cases}$$ 这样求A到C的最小值就是 求max{a+c,b}, 即建图跑最长路。 不等式的标准化如果题目中既有小于等于的关系也有大于等于的关系怎么办? 根据题目来，如果要求最大值，就要将所有的大于等于号改为小于等于号，求最小值同理 解的存在性无解： 出现了负环无穷多解： 图不连通]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2018%2F05%2F03%2FLIS%2F</url>
    <content type="text"><![CDATA[题意来源:zoj4028 构造一个长度为n的序列，满足以下条件： f[i] 表示以第i个元素结尾的最长上升子序列的长度。 l[i],r[i] 表示第i个元素的范围。 $1 \le n \le 10^5$ 分析差分约束 设d[i]表示第i个位置的元素。 $l[i] \leq d[i] \leq r[i] = l[i] \leq d[i] - d[0] \leq r[i]$ -&gt; $d[0] - d[i] \leq -l[i]$ -&gt; $d[i] - d[0] \leq r[i]$ 添加附加源 d[0] = 0 对于i &lt; k,如果 $f[k] == f[i]$, 则有 $d[k] - d[i] \leq 0$ 对于i &lt; k,如果 $f[k] = f[i] + 1$, 则有$d[k] - d[i] \geq 1$ -&gt; $d[i] - d[k] \leq -1$ 然后跑最短路即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int f[maxn], l[maxn], r[maxn], loc[maxn];vector&lt;pii&gt; G[maxn];bool vis[maxn];int inq[maxn]; // 记录入队次数ll d[maxn];inline void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;inline void addedge(int u,int v,int w)&#123; G[u].pb(mp(v,w)); // G[v].pb(mp(u,w));&#125;bool spfa(int s,int n)&#123; for(int i=0;i&lt;=n;i++) &#123; d[i] = INF; inq[i] = 0; vis[i] = 0; &#125; d[s] = 0; queue&lt;int&gt; q; q.push(s); vis[s] = true; inq[s]++; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(auto &amp;V : G[u])&#123; int v = V.first; ll w = V.second; if(d[v] &gt; d[u] + w)&#123; d[v] = d[u] + w; if(!vis[v])&#123; vis[v] = true; inq[v]++; q.push(v); if(inq[v] &gt;= n) return false; &#125; &#125; &#125; &#125; return true;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; clr(loc, -1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; f[i]; &#125; init(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; l[i] &gt;&gt; r[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; addedge(0, i, r[i]); addedge(i, 0, -l[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (loc[f[i] - 1] != -1) &#123; int u = loc[f[i] - 1]; addedge(i, u, -1); &#125; if (loc[f[i]] != -1) &#123; int u = loc[f[i]]; addedge(u, i, 0); &#125; loc[f[i]] = i; &#125; spfa(0,n); for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) cout &lt;&lt; d[i]; else cout &lt;&lt; ' ' &lt;&lt; d[i]; &#125; cout &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Resource Distribution]]></title>
    <url>%2F2018%2F05%2F02%2FResource-Distribution%2F</url>
    <content type="text"><![CDATA[题意来源:cd967d 给n个服务器，每个服务器都有一个负载。 现在要组建两个大型服务器S1和S2，要求S1能负载x1，S2能负载x2. 每个大型服务器的负载都会平均分配到每个小服务器上。 每个服务器最多服务一个大型服务器。 问是否有满足条件的分配方案 $2 \leq n \leq 300\,000, 1 \leq x_1, x_2 \leq 10^9$ 分析有一个显而易见的性质：能选大的一定不选小的。 所以在数组排好序后，最后的结果一定是一段包含右端点的连续区间，现在问题就是S1和S2的次序问题，都枚举一下，有一个解就是yes。 一开始想着二分k，但是后来发现这个不满足单调的性质。赛后看了别人代码才明白。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pii pair&lt;int, int&gt;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e5 + 5;pii c[maxn];int x[2];vector&lt;int&gt; ans[2];bool work(int i1,int i2,int n)&#123; int s = -1; for(int i=0;i&lt;n;i++)&#123; if(c[i].first * (i + 1) &gt;= x[i1])&#123; s = i; break; &#125; &#125; if(s == -1) return false; for(int i=s+1;i&lt;n;i++)&#123; if(c[i].first * (i - s) &gt;= x[i2])&#123; for(int k=0;k&lt;=s;k++) ans[i1].pb(c[k].second); for(int k=s+1;k&lt;=i;k++) ans[i2].pb(c[k].second); return true; &#125; &#125; return false;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n &gt;&gt; x[0] &gt;&gt; x[1]) &#123; for(int i=0;i&lt;2;i++) ans[i].clear(); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c[i].first; c[i].second = i + 1; &#125; sort(c, c + n, greater&lt;pii&gt;()); if (work(0, 1, n) || work(1, 0, n)) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; cout &lt;&lt; ans[0].size() &lt;&lt; ' ' &lt;&lt; ans[1].size() &lt;&lt; endl; for (int i = 0; i &lt; 2; i++) &#123; for (auto I : ans[i]) cout &lt;&lt; I &lt;&lt; ' '; cout &lt;&lt; endl; &#125; &#125; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sequence Swapping]]></title>
    <url>%2F2018%2F05%2F02%2FSequence-Swapping%2F</url>
    <content type="text"><![CDATA[题意来源:15届浙江省赛D 给你一个由左右括号组成的字符串，每个位置的括号都对应一个权值。 现在可以做一个操作： 交换相邻位置的括号，若第k个括号是’(‘,并且第k+1个括号是’)’,则获得对应权值相乘的分数。 该操作可做无限次，问得到的最大权值是多少？ 字符串长度 $\leq 10^3$ $-10^3 \le$ 权值 $\le 10^3$ 分析首先需要注意到的是权值有正有负，这样就很难贪心了。 我们可以这么考虑，对于第i个左括号，如果它向右交换k个右括号,那么第i-1个左括号就可往右多交换k个。 根据这个思想就可以想到是个记忆化搜索的过程 $dp[i][k]:$ 表示第i个左括号向右至多交换k个右括号所得到的最大价值。 所以这里有一堆预处理等着你 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pii pair&lt;int,int&gt; typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e3+5;int num[maxn];char ch[maxn];ll dp[maxn][maxn];int pre[maxn][maxn]; // pre[i][k]: 第i个左括号向右交换k个右括号得到的价值int x[maxn]; //x[i] 表示i位置开始的后缀和（右括号的数量vector&lt;pair&lt;int,int&gt; &gt;le; // le[i]: 第i个左括号的位置和他右边右括号的数量vector&lt;pair&lt;int,int&gt; &gt; ri[maxn]; //ri[i]第i个左括号右边 每个右括号的位置和权值ll dfs(int pos,int cnt)&#123; // pos : i, cnt : k if(dp[pos][cnt] != -1) return dp[pos][cnt]; ll ret = 0; int k; if(cnt == 0)&#123; //不能交换和不交换有点区别 if(pos == 0) return 0; k = x[le[pos].first]; ret = dfs(pos-1,ri[pos-1].size() - k); if(ret&lt;0)ret = 0; dp[pos][cnt] = ret; return ret; &#125; for(int i=0;i&lt;=cnt;i++)&#123; if(i == cnt) &#123; k = x[ri[pos][cnt-1].first + 1]; &#125; else &#123; k = x[ri[pos][i].first]; &#125; if(pos == 0)&#123; ret = max(ret,1LL * pre[pos][i] * num[le[pos].first]); &#125; else ret = max(ret,dfs(pos - 1,ri[pos-1].size() - k) + 1LL*pre[pos][i] * num[le[pos].first]); &#125; if(ret &lt; 0) ret = 0; dp[pos][cnt] = ret; return ret;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); scanf("%s",ch); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; x[n] = 0; for(int i=n-1;i&gt;=0;i--)&#123; x[i] = x[i+1] + (ch[i] == ')'); &#125; le.clear(); for(int i=0;i&lt;n;i++)&#123; if(ch[i] == '(')&#123; int cnt = 0; for(int k=i+1;k&lt;n;k++)&#123; if(ch[k] == ')') cnt++; &#125; le.pb(mp(i,cnt)); int pos = le.size() - 1; ri[pos].clear(); for(int k=i+1;k&lt;n;k++)&#123; if(ch[k] == ')')&#123; ri[pos].pb(mp(k,num[k])); &#125; &#125; pre[pos][0] = 0; for(int k=1;k&lt;=ri[pos].size();k++)&#123; pre[pos][k] = pre[pos][k-1] + ri[pos][k-1].second; &#125; &#125; &#125; for(int i=0;i&lt;le.size();i++)&#123; for(int k=0;k&lt;=ri[i].size();k++)&#123; dp[i][k] = -1; &#125; &#125; ll ans; if(le.size() == 0) ans = 0; else ans = dfs(le.size()-1,ri[le.size()-1].size()); printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求值]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/E 来源：牛客网 题目描述 给定n个数字$a_1, a_2, …, a_n$。 定义$f(l, r) = a_l | a_{l+1}| … | a_r$。 现在枚举(1 &lt;= l &lt;= r &lt;= n)，问不同的f值一共有多少个。 输入描述: 第一行一个整数n表示数组大小 (1 &lt;= n &lt;= 100,000)； 第二行n个整数满足0 &lt;= $a_i$ &lt;= 1000,000。 输出描述: 输出一个整数表示不同的f值一共有多少个。 示例1 输入1231 2 0 输出14 示例2输入12101 2 3 4 5 6 1 2 9 10 输出111 分析数组内子串或和不同的数量 $dp[i][k]$ 表示第i位开始，第k数位为1的数字，第一次出现的位置 枚举左端点，对于每个数位，找离左端点最近的开始求或。 vis记录当前值是否出现过 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2000000;int num[100005];bool vis[maxn];int pos[100005][20];int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(vis,0,sizeof(vis)); memset(pos,-1,sizeof(pos)); for(int i=0;i&lt;n;i++) &#123; cin &gt;&gt; num[i]; int x = num[i]; int cnt = 0; while(x)&#123; int temp = x % 2; if(temp) pos[i][cnt] = i; cnt++; x &gt;&gt;= 1; &#125; &#125; for(int i=n-1;i&gt;=0;i--)&#123; for(int k=0;k&lt;20;k++)&#123; if(pos[i][k] != -1) continue; pos[i][k] = pos[i+1][k]; &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int now = num[i]; vector&lt;int&gt; v; for(int k=0;k&lt;20;k++)&#123; if(pos[i][k] != -1) v.push_back(pos[i][k]); &#125; sort(v.begin(),v.end()); if(!vis[now])&#123; vis[now] = 1; ans++; &#125; for(int k=0;k&lt;v.size();k++)&#123; now |= num[v[k]]; if(!vis[now])&#123; vis[now] = 1; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[任意点]]></title>
    <url>%2F2018%2F04%2F27%2F%E4%BB%BB%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/C 来源：牛客网 题目描述 平面上有若干个点，从每个点出发，你可以往东南西北任意方向走，直到碰到另一个点，然后才可以改变方向。 请问至少需要加多少个点，使得点对之间互相可以到达。输入描述: 第一行一个整数n表示点数（ 1 &lt;= n &lt;= 100)。 第二行n行，每行两个整数xi, yi表示坐标（ 1 &lt;= xi, yi &lt;= 1000)。 y轴正方向为北，x轴正方形为东。 输出描述: 输出一个整数表示最少需要加的点的数目。 示例1 输入12322 11 2 输出11 示例2 输入12322 14 1 输出10 分析将那些可以互相到达的点用并查集维护。 最后查看有几个不联通的 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn= 105;int x[maxn],y[maxn];int par[maxn];int find(int i)&#123; return i == par[i] ? i : par[i] = find(par[i]);&#125;void merge(int i,int k)&#123; i = find(i); k = find(k); par[i] = k;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; for(int i=0;i&lt;n;i++) par[i] = i; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int k=i + 1;k&lt;n;k++)&#123; if(x[i] == x[k] || y[i] == y[k])&#123; merge(i,k); &#125; &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; if(find(i) == i) ans++; &#125; cout &lt;&lt; ans - 1&lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漂亮的树]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%BC%82%E4%BA%AE%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/B来源：牛客网 题目描述 街上有n棵树，标号为1…n，第i棵树的高度为$a_i$。 定义这n棵树是漂亮的，当且仅当 对于所有的i，$a_i=a_n-i+1$； 对于1 &lt;= i &lt; n / 2 (不是整除)，$a_i + 1= a_i + 1$； 比如说 “2 3 4 5 5 4 3 2”和“1 2 3 2 1”是漂亮的而“1 3 3 1”和“1 2 3 1”不是 现在请问最少修改几棵树的高度（可以变大也可以变小），使得这些树是漂亮的。 输入描述: 第一行一个整数n表示树的数量（ 1 &lt;= n &lt;= 100,000)。 第二行n个整数表示树的高度（ 1 &lt;= ai &lt;= 100,000)。 输出描述: 输出一个整数表示最少修改树的高度的数目。 示例1 输入1232 2 2 输出11 示例2 输入1241 2 2 1 输出10 分析因为序列里只要一个数字确定，其他数字自然而然就确定了。 所以我们可以记录每位的偏移量，即第i位的偏移量就是num[i] - i.（前n/2个数） 然后我们可以枚举偏移量计算就可以啦。 注意偏移量可能为负数！ 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;const int maxn = 2e5+5;int num[maxn];int dp[2][maxn];int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) cin &gt;&gt; num[i]; for(int i=0;i&lt;n/2;i++)&#123; dp[0][num[i] - i + 100001] ++; dp[1][num[n-i-1]-i + 100001]++; &#125; if(n &amp; 1) dp[0][num[n/2] - n/2 + 100001]++; int ans = INF; for(int i=0;i&lt;maxn;i++)&#123; int temp = n - dp[0][i] - dp[1][i]; ans = min(ans,temp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数根]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%95%B0%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[数根数根(又称数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根。 数根是将一正整数的各个位数相加(即横向相加)，若加完后的值大于等于10的话，则继续将各位数进行横向相加直到其值小于十为止，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。 [1] 推论设x在模k意义下的数根为d(x) 则 d(x) = x % (k-1)]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>树根</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vscode配置-cpp]]></title>
    <url>%2F2018%2F04%2F27%2Fvscode%2F</url>
    <content type="text"><![CDATA[My snippet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: // "Print to console": &#123; // "prefix": "log", // "body": [ // "console.log('$1');", // "$2" // ], // "description": "Log output to console" // &#125; "print to console":&#123; "prefix": "inc", "body": [ "//ybmj", "#include&lt;bits/stdc++.h&gt;", "using namespace std;", "#define lson (rt &lt;&lt; 1)", "#define rson (rt &lt;&lt; 1 | 1)", "#define lson_len (len - (len &gt;&gt; 1))", "#define rson_len (len &gt;&gt; 1)", "#define pb(x) push_back(x)", "#define clr(a, x) memset(a, x, sizeof(a))", "#define mp(x, y) make_pair(x, y)", "typedef long long ll;", "typedef pair&lt;int,int&gt; pii;", "typedef pair&lt;ll,ll&gt; pll;", "const int INF = 0x3f3f3f3f;", "const int NINF = 0xc0c0c0c0;", "", "int main()&#123;", "\t/*", "\t#ifndef ONLINE_JUDGE", "\tfreopen(\"1.in\",\"r\",stdin);", "\tfreopen(\"1.out\",\"w\",stdout);", "\t#endif", "\t*/", "\tstd::ios::sync_with_stdio(false);", "", "&#125;" ] &#125;&#125; launch.json12345678910111213141516171819202122232425262728&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/a.out", "args": [], "stopAtEntry": false, "cwd": "$&#123;fileDirname&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build" &#125; ]&#125; tasks.json1234567891011121314151617181920212223242526272829303132333435&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "command": "g++", "args": [ // Ask msbuild to generate full paths for file names. "-g", "-std=c++11", "$&#123;file&#125;" ], "group": &#123; "kind": "build", "isDefault": true &#125;, // Use the standard MS compiler pattern to detect errors, warnings and infos "problemMatcher": &#123; "owner": "cpp", "fileLocation":"absolute", "pattern":&#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125;, &#125; &#125; ]&#125; 字体Windows : 字体： Source Code Pro 渲染器： MacType]]></content>
      <categories>
        <category>工作环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈密顿图]]></title>
    <url>%2F2018%2F04%2F24%2F%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[哈密顿图哈密顿通路: 设G=&lt;V,E&gt;为一图(无向的或有向的),G中经过每个顶点一次且仅一次的通路 哈密顿回路: G中经过每个顶点一次且仅一次的回路 哈密顿图: 若G中存在哈密顿回路,则称G为哈密顿图 充分条件定理一设G是$n(n \geq 3)$阶无向简单图,若对于G中每一对不相邻的顶点u,v,均有$$d(u) + d(v) \geq n-1$$ 则G中存在哈密顿通路,又若$$d(u) + d(v) \geq n$$ 则G中存在哈密顿回路,即G为哈密顿图. 其中$d(v_i) = d^+(v_i) + d^-(v_i)$ 推论: 设G是$n(n \geq 3)$阶无向简单图,若 $\delta(G) \geq \frac{n}{2} $ 则G是哈密顿图. 定理二在$n(n\geq 2)$阶有向图D = &lt;V,E&gt;中,如果略去所有有向边的方向,所得无向图中含生成子图$K_n$,则D中存在哈密顿通路 必要条件设无向图G = &lt;V,E&gt;为哈密顿图,$V_1$是$V$的任意真子集,则$$p(G-V_1) \leq |V_1|$$ 其中,$p(G-V_1)$为从G中删除$V_1$后所得图的连通分支数. 推论: 有割点的图一定不是哈密顿图]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>哈密顿图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[插值查找]]></title>
    <url>%2F2018%2F04%2F24%2F%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[插值查找插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$$pos = low+\frac{val-num[low]}{num[high]-num[low]}(high-low) $$ 需要注意的是： $val &gt; num[low]$ $val &gt; num[high]$ 这两种情况要判一下下 时间复杂度 这个O(loglogN)的复杂度是平均期望复杂度，而不是最坏情况复杂度。 需要假设数据在某个范围内均匀分布。 代码12345678910111213141516int Search(int val) &#123; int l = 0, r = 100; int ans = -1; while (l &lt;= r) &#123; if (val &lt; num[l] || val - num[l] &gt; r - l) break; int m = l + (val - num[l]) * (r - l) / (a[r] - a[l]); if (ok(m)) &#123; ans = m; l = m + 1; &#125; else r = m - 1; &#125; if (ans == -1) cout &lt;&lt; "Find nothing" &lt;&lt; endl; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>查找算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合约数]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%90%88%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意来源:shuoj507 给定一棵n个节点的树，并且根节点的编号为p，第i个节点有属性值$val_i$, 定义F(i): 在以i为根的子树中，属性值是$val_i$的合约数的节点个数。 y 是 x 的合约数是指 y 是合数且 y 是 x 的约数。 小埃想知道$\sum^n_{i = 1}i⋅F(i)对1000000007$取模后的结果。 1≤n≤20000, 1≤p≤n 1≤vali≤10000 ，1≤i≤n. 分析这题考察对递归性质的理解 当我走到某一结点u，我可以在O(sqrt(val[u]))的时间内找到目前所有是val[u]合约数的个数。 当我回溯到u的时候，再一次统计val[u]合约数的个数，二者相减即可得到u子树中，val[u]合约数的个数。 时间复杂度$O(n \times sqrt(val))$; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2e4 + 5;const int mod = 1e9 + 7;vector&lt;int&gt; G[maxn];int val[maxn];int num[maxn];bool vis[maxn];ll ans;void make_prime() &#123; clr(vis, 0); vis[0] = vis[1] = 1; for (ll i = 2; i &lt;= 10000; i++) &#123; if (!vis[i]) for (ll k = 2; i * k &lt;= 10000; k++) &#123; vis[i * k] = 1; &#125; &#125;&#125;void dfs(int u, int fa) &#123; ll temp = 0; for (int i = 1; i &lt; (int)sqrt(val[u]) + 1; i++) &#123; if (val[u] % i == 0) &#123; if (i != 1 &amp;&amp; vis[i]) temp += num[i]; if (i != val[u] / i &amp;&amp; (val[u] / i) != 1 &amp;&amp; vis[val[u] / i]) temp += num[val[u] / i]; &#125; &#125; for (auto v : G[u]) &#123; if (v != fa) &#123; dfs(v, u); &#125; &#125; num[val[u]]++; for (int i = 1; i &lt; (int)sqrt(val[u]) + 1; i++) &#123; if (val[u] % i == 0) &#123; if (i != 1 &amp;&amp; vis[i]) temp -= num[i]; if (i != val[u] / i &amp;&amp; (val[u] / i) != 1 &amp;&amp; vis[val[u] / i]) &#123; temp -= num[val[u] / i]; &#125; &#125; &#125; if (temp &gt; 0) assert(false); ans = (ans + (-temp) * u % mod) % mod;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); make_prime(); int T; cin &gt;&gt; T; while (T--) &#123; int n, p; cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i++) G[i].clear(); clr(num, 0); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].pb(v); G[v].pb(u); &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; ans = 0; dfs(p, -1); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ultmaster 的小迷妹们]]></title>
    <url>%2F2018%2F04%2F23%2Fultmaster-%E7%9A%84%E5%B0%8F%E8%BF%B7%E5%A6%B9%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[题意来源:eoj2018.4.A 给你一个$n\times n$的正方形，和若干$x\times y$的长方形，问你是否能拼成一个更大的正方形。 $n,x,y (1≤n,x,y≤10^9)$ 分析我们可以把小正方形放到中心位置。 可以发现整个大的正方形可以分成四个对称的部分（除去中心的小正方形） 可以得到$\frac{n + k_1x}{y} = k_2$ 或者 $\frac{n + k_2y}{x} = k_1$ 即$k_2y - k_1x = n$ 或者 $k_1x - k_2y = n$ x，y要取正数解。即只要这个二元一次方程有解即可。 代码1234567891011121314151617181920212223242526272829303132333435// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int gcd(int a, int b) &#123; if (b) while ((a %= b) &amp;&amp; (b %= a)) ; return a + b;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, x, y; while (cin &gt;&gt; n &gt;&gt; x &gt;&gt; y) &#123; int a = min(x, y); int b = max(x, y); if (n % gcd(a, b) == 0) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Destruction of a Tree]]></title>
    <url>%2F2018%2F04%2F18%2FDestruction-of-a-Tree%2F</url>
    <content type="text"><![CDATA[题意来源：cf964d 一棵树，可以删去偶度点，问是否能删除掉整棵树？ 如果可以则输出删除顺序（spj） $(1 ≤ n ≤ 2·10^5)$ 分析递归 最近写不出来题目了，简单的递归瞎搞都写不来了。 对每个点，判断其度的奇偶（通过对未删除的边进行计数），若是偶数点则删除以该点为根的整棵子树。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2e5 + 5;vector&lt;int&gt; G[maxn];vector&lt;int&gt; ans;bool vis[maxn];void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u);&#125;void remove(int u, int fa) &#123; if (vis[u]) return; vis[u] = true; ans.pb(u); for (auto v : G[u]) &#123; if (v == fa) continue; remove(v, u); &#125;&#125;void dfs(int u, int fa) &#123; int deg = fa == -1 ? 0 : 1; for (auto v : G[u]) &#123; if (v == fa) continue; dfs(v, u); if (!vis[v]) deg ^= 1; &#125; if (!deg) remove(u, fa);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); clr(vis, 0); ans.clear(); for (int i = 1; i &lt;= n; i++) &#123; int v; cin &gt;&gt; v; if (v != 0) addedge(i, v); &#125; dfs(1, -1); if (ans.size() != n) cout &lt;&lt; "NO" &lt;&lt; endl; else &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alternating Sum]]></title>
    <url>%2F2018%2F04%2F18%2FAlternating-Sum%2F</url>
    <content type="text"><![CDATA[题意来源：cf 964C You are given two integers a and b. Moreover, you are given a sequence $s_0,s_1,…,s_n.$ All values in s are integers 1 or −1. It’s known that sequence is k-periodic and k divides n+1.In other words, for each k≤i≤n it’s satisfied that $s_i=s_i−k.$ Find out the non-negative remainder of division of $\sum^n_{i = 0}s_ia^{n-1}b^i$ by $10^9+9$ Note that the modulo is unusual! $(1 \leq n \leq 10^{9}, 1 \leq a, b \leq 10^{9}, 1 \leq k \leq 10^{5})$ 分析等比数列求和 每个位置的元素，经过一个周期就会变成原来的$a^{-k}b^k$倍，所以可以用等比数列求和。 没有看到题目中说$(n+1) \% k == 0$，所以我的做法是对任何n都适用的。 需要注意的是如何需要判断公比为1的特殊情况（当时直接认为a等于b时才会出现公比为1的情况，事实上因为它不断地在模，所以即使不相等，模完之后也可能相等） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9 + 9;ll n, a, b, k;ll my_pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;ll work(int i) &#123; ll m = (n - i) / k + 1; // ll m = (n + 1) / k; ll ret = 0; ll temp = my_pow(b, k) * my_pow(my_pow(a, k), mod - 2) % mod; if (temp == 1) return m * my_pow(a, n - i) % mod * my_pow(b, i) % mod; // wa temp = (1 - temp + mod) % mod; ret = (ret + my_pow(a, n - i) * my_pow(b, i) % mod) % mod; ll idx = n - i - m * k; if (idx &gt;= 0) ret = (ret - my_pow(b, m * k + i) * my_pow(a, idx) % mod + mod) % mod; else ret = (ret - my_pow(b, m * k + i) * my_pow(my_pow(a, -idx), mod - 2) % mod + mod) % mod; ret = ret * my_pow(temp, mod - 2) % mod; return ret;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k) &#123; string line; cin &gt;&gt; line; ll ans = 0; for (int i = 0; i &lt; line.size() &amp;&amp; i &lt;= n; i++) &#123; if (line[i] == '+') &#123; ans = (ans + work(i)) % mod; &#125; else &#123; ans = (ans - work(i) + mod) % mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[序列变换]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BA%8F%E5%88%97%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj508 描述 给定两个长度为n的序列，$a_i,b_i(1≤i≤n)$, 通过3种魔法使得序列a变换为序列b，也就是$a_i=b_i(1≤i≤n)$. 魔法1： 交换$a_i$和$a_j$，i≠j 首先通过若干次的魔法1将序列a变换成序列c 魔法2： 对1个数乘2或者加1 魔法3： 对1个数除以2或者减1，如果是奇数，则不能除以2 若$c_i&gt;b_i$, 则只能对$c_i$实施魔法3，若$c_i&lt;b_i$, 则只能对$c_i$实施魔法2. 例如$c_i=6, b_i=4$, 则可以通过对ci实施2次减1操作(魔法3)将$c_i$变为$b_i$, 但不可以对$c_i$除以2再加1将$c_i$变为$b_i$，因为$c_i&gt;b_i$, 所以不能对$c_i$实施加1操作(魔法2). 小埃想通过最少的操作次数使得序列a变成序列b， 操作次数是指使用的魔法次数。 输入 输入测试组数T，每组数据，第一行输入n，1≤n≤9,紧接着输入两行，每行n个整数，前一行为$a_1,a_2,…,a_n$,后一行为$b_1,b_2,…,b_n$.其中$1≤a_i,b_i≤10^8,1≤i≤n.$ 输出 每组数据输出一个整数，表示最少的操作次数 分析由于n只有9，因为9! = 3e5, 所以这是个可以暴力的数据（枚举所有全排列） 对于魔法一： 将序列a1通过交换变成序列a2，最小花费的步数？ 第一个要注意的是如何进行全排列，如果直接对a中元素全排列，这样在求魔法一时非常困难，因为没有办法快速找到当前元素本来的位置。 所以我们通过对下标进行全排列。 idx[i]： 表示重新排列后在i位置上的元素，其在a数组中的下标。 这样对于第i位元素，我就知道它原来的位置是idx[i]。 从i开始搜，如果idx[i]未访问过，就继续搜下去。 这样最后就得到一个环，假设里面有n个元素，这样说明他的交换次数是n-1。 这个做法对于数列元素都不相同的题目可以做。 如果数列元素有重复，那么这么做出来的结果不一定对。 这道题可以是以为它有一个全排列。 魔法二三： 预处理a中每一个数变成b中每一个数所需要的次数。 这里有一个小技巧，因为将一个大数变成一个小数是可以贪心的！ 但是将一个小数变成一个大数是不能贪心的！ 但是！ 大数变小数 和 小数变大数是对称的！！ 做完了 难点在于： 对下标进行全排列 计算通过交换元素使得两数组相同的最小步数 大数变小数的过程与小数变大数的过程是对称的 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 10;int maps[maxn][maxn];int a[maxn], b[maxn], idx[maxn];bool vis[maxn];int n;int dfs(int pos) &#123; vis[pos] = true; // if(a[idx[pos]] == b[pos]) return 0; if (!vis[idx[pos]]) &#123; return dfs(idx[pos]) + 1; &#125; else return 0;&#125;int work() &#123; int ret = 0; clr(vis, 0); for (int i = 0; i &lt; n; i++) if (!vis[i]) ret += dfs(i); for (int i = 0; i &lt; n; i++) &#123; ret += maps[idx[i]][i]; &#125; return ret;&#125;int cal(int x, int y) &#123; if (x == y) return 0; if (x &lt; y) swap(x, y); int ret = 0; while (x &gt; y) &#123; while ((x &amp; 1) == 0 &amp;&amp; (x &gt;&gt; 1) &gt;= y) &#123; x &gt;&gt;= 1; ret++; &#125; if (x &gt; y &amp;&amp; (x &gt;&gt; 1) &lt; y) &#123; ret += x - y; break; &#125; if (x &gt; y) &#123; x--; ret++; &#125; &#125; return ret;&#125;int main() &#123; /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif*/ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); // cin &gt;&gt; T; while (T--) &#123; scanf("%d", &amp;n); // cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", a + i); // cin &gt;&gt; a[i]; idx[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", b + i); // cin &gt;&gt; b[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; n; k++) &#123; maps[i][k] = cal(a[i], b[k]); &#125; &#125; int ans = INF; do &#123; ans = min(ans, work()); &#125; while (next_permutation(idx, idx + n)); printf("%d\n", ans); // cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1+2=3?]]></title>
    <url>%2F2018%2F04%2F16%2F1-2-3%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj511 x⊕2x=3x 求满足上述条件的第N个数字。（保证最后结果在longlong范围内） $N≤10^{12}$ 分析数位dp + 二分二分最后答案，然后数位dp去找小于等于二分答案的满足要求的数的数量。 数位dp + 模拟满足上述条件的数字，其二进制表示下，一定是没有“11”出现的。 所以我们可以小小的数位dp一下。 $dp[i][k]$ 表示数位长度为i的，最高位（第i位）为k的，满足条件的数的数量。 接下来就是超级无敌爆炸讨厌的模拟过程。 先找最高位的1在哪里，这里需要预处理前缀和. 然后从最高位的1后面开始枚举，如果前一位为1，那么当前位必为0，直接转移就可以。如果前一位为0，那么当前位可以为0，也可以为1。 所以先看看当前位为0的话总共会有多少种情况，如果大于等于n，则当前位为0，否则当前位为1，并且要减去这个情况的数量。然后继续找下一位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[65][2]; // dp[i][k] i长度的数字，最高位为k，一共有多少中满足条件情况。int num[100];ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return !lead; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 1; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (i &amp;&amp; sta) continue; ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, i); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;ll solve(ll n) &#123; int pos = 0; while (n) &#123; num[pos++] = n % 2; n &gt;&gt;= 1; &#125; return dfs(pos - 1, true, true, 0);&#125;void work(ll n) &#123; ll l = 1, r = 1e18; ll ans; while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (solve(mid) &gt;= n) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); clr(dp, -1); int T; cin &gt;&gt; T; while (T--) &#123; ll n; cin &gt;&gt; n; work(n); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ybmj// I hate this problem!!!#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[65][2]; // dp[i][k] i长度的数字，最高位为k，一共有多少中满足条件情况。ll pre[65]; // pre[i] dp的前缀和，长度最多为i的数字，一共有多少种满足条件的情况ll P[65]; // 预处理2的幂次ll dfs(int pos, bool lead, int sta) &#123; if (pos == -1) return !lead; if (!lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; ll ans = 0; if (lead &amp;&amp; sta == 0) ans += dfs(pos - 1, true, 0); else if (sta == 0 &amp;&amp; pos != 0) &#123; ans += dfs(pos - 1, false, 0); ans += dfs(pos - 1, false, 1); &#125; else if (sta == 1) ans += dfs(pos - 1, false, 0); if (!lead) dp[pos][sta] = ans; return ans;&#125;void work(ll n) &#123; int pos = -1; vector&lt;ll&gt; ans; for (int i = 61; i &gt;= 0; i--) &#123; if (n &gt; pre[i]) &#123; pos = i; n -= pre[i]; ans.pb(1); break; &#125; &#125; for (int i = pos; i &gt;= 0; i--) &#123; if (ans[ans.size() - 1] == 1) &#123; ans.pb(0); &#125; else &#123; if (n &lt;= dp[i][0]) &#123; ans.pb(0); &#125; else &#123; n -= dp[i][0]; ans.pb(1); &#125; &#125; &#125; ll ret = 0; for (int i = ans.size() - 1; i &gt;= 0; i--) &#123; ret += ans[i] * P[ans.size() - 1 - i]; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;void init() &#123; clr(dp, -1); dp[0][0] = 1; dfs(63, true, 1); pre[0] = dp[0][1]; for (int i = 1; i &lt; 62; i++) &#123; pre[i] = pre[i - 1] + dp[i][1]; &#125; P[0] = 1; for (int i = 1; i &lt; 63; i++) &#123; P[i] = P[i - 1] * 2LL; &#125;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); init(); int T; cin &gt;&gt; T; while (T--) &#123; ll n; cin &gt;&gt; n; if (n == 1) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; work(n); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[K序列]]></title>
    <url>%2F2018%2F04%2F16%2FK%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj517 给一个数组a，长度为n，若某个子序列中的和为K的倍数，那么这个序列被称为“K 序列”。现在要你对数组a 求出最长的子序列的长度，满足这个序列是K 序列。 $1≤n≤10^5,1≤a[i]≤10^9, 1≤nK^2≤10^7$ 分析小数据的话用二维dp $dp[i][k]$ 表示前i个元素，和的余数为k，的最长子序列的长度 转移方程：$dp[i][(k + a[i])\% K] = max(dp[i-1][(k+a[i])\%K],dp[i-1][k]+1)$ 但是由于题目数据很大，所以我们需要滚动第一维，所以递推方程变为： $dp[i \&amp; 1][(k + a[i]) \% K]= max(dp[(i \&amp; 1) \bigoplus 1][(k + a[i]) \% K],dp[(i \&amp; 1) \bigoplus 1][k] + 1)$ 一开始想到了二维dp，但是因为对滚动反应不够，所以就放弃了那个想法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 1e5 + 5;int a[maxn];int dp[2][maxn];int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, K; while (cin &gt;&gt; n &gt;&gt; K) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; a[i] %= K; &#125; clr(dp, 0xc0); dp[0][0] = 0; // dp[i][k] 前i个，余数为k，的最长子序列长度 for (int i = 1; i &lt;= n; i++) &#123; for (int k = 0; k &lt; K; k++) &#123; dp[i &amp; 1][(k + a[i]) % K] = max(dp[(i &amp; 1) ^ 1][(k + a[i]) % K], dp[(i &amp; 1) ^ 1][k] + 1); // dp[i][(k + a[i]) % K] = // max(dp[i - 1][(k + a[i]) % K], dp[i - 1][k] + 1); &#125; &#125; /* for (int i = 1; i &lt;= n; i++) &#123; for (int k = 0; k &lt; K; k++) &#123; cout &lt;&lt; dp[i][k] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; */ cout &lt;&lt; dp[n &amp; 1][0] &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Guard Duty (medium)]]></title>
    <url>%2F2018%2F04%2F16%2FGuard-Duty-medium%2F</url>
    <content type="text"><![CDATA[题意来源：cd 958 e2 从一个数组中选Ｋ个不相邻的数，使得和最小。 K, N (2 ≤ 2K ≤ N ≤ 500000, K ≤ 5000) 分析对于小数据，我们可以用ｄｐ做。 $dp[i][k][vis]$ 表示从前ｉ个里面选ｋ个，ｖｉｓ表示第ｉ位有没有选。 转移方程: $$dp[i][k][0] = min(dp[i-1][k][0],dp[i-1][k][1])$$ $$dp[i][k][1] = min(dp[i-1][k-1][0],dp[i-1][k-1][1]) + cost[i]$$ 对于原题中的数据就不能这么做啦。 最朴素的想法是每次取最小的元素，但是这么贪心明显是错误的，因为最小的元素不一定在最终的答案里。 为什么最小的元素不一定在最终的答案里呢？ a[] = {4 ,1, 5, 100}; 我们会先取1，然后再取100,。 但是4 + 5 &lt; 1 + 100 所以我们在贪心的时候，每取一个数，则要把他相应的“补救措施”也放进这个贪心的过程中。 所谓的补救措施就是：不取当前元素，而取其相邻的两个元素。 这里有个性质： 如果4 或 5其中一个在最后的答案里，那么这个答案一定不是最优的，因为我可以将其替换成1，而不影响其它元素的选取。 为什么是两个？ 看上面的例子，当我们取第二个元素时，我们取到了100。 但如果考虑其”补救措施“，那么我们取到的就应该是 4 + 5 - 1. 这里因为有元素的删除，我们采用静态双向链表实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 5e5 + 5;ll a[maxn], d[maxn], pre[maxn], nxt[maxn];bool vis[maxn];int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int k, n; while (cin &gt;&gt; k &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; pq; for (int i = 1; i &lt; n; i++) &#123; d[i] = a[i] - a[i - 1]; pre[i] = i - 1; nxt[i] = i + 1; vis[i] = 0; pq.push(mp(d[i], i)); &#125; d[0] = d[n] = INF; ll ans = 0; for (int i = 0; i &lt; k; i++) &#123; while (true) &#123; if (pq.empty()) break; int i = pq.top().second; pq.pop(); if (vis[i]) continue; ans += d[i]; d[i] = -d[i]; vis[pre[i]] = true; d[i] += d[pre[i]]; pre[i] = pre[pre[i]]; nxt[pre[i]] = i; vis[nxt[i]] = true; d[i] += d[nxt[i]]; nxt[i] = nxt[nxt[i]]; pre[nxt[i]] = i; pq.push(mp(d[i], i)); break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优先队列比较器]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1234567struct cmp &#123; bool operator () (int i, int j) &#123; return a[i] &gt; a[j]; &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;]]></content>
      <categories>
        <category>ACM</category>
        <category>比较器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2018%2F04%2F13%2FTrie%2F</url>
    <content type="text"><![CDATA[介绍功能：主要用于保存字符集合。 优点：可以在$O(len)$ ($len$为要查询单词长度) 时间内查询某个单词是否存在。 缺点：需要大量的储存空间。典型的用空间换时间。 思想：前缀树，顾名思义，通过记录每个单词的前缀来保存单词。 每个值为1的节点，代表这个单词存在。 上图的单词为： al,le,lk,f,fx. 数组开多大合适？ 如果有100个单词，每个单词长度不超过500，且全是小写字母。 那么我们假设每个单词单独是一条链，一共有100条链，每条链长度为500，所以$maxnode = 100\times500$ $types = 26$ 因为有26个字母。 代码：1234567891011121314151617181920212223242526272829//数组版struct Trie &#123; int ch[maxnode][types]; int val[maxnode]; int sz; void init() &#123; memset(ch[0], 0, sizeof(ch[0])); sz = 1; &#125; inline int idx(char x) &#123; return x - 'a'; &#125; void insert(string line, int key) &#123; int u = 0; for (int i = 0; i &lt; line.size(); i++) &#123; int v = idx(line[i]); if (ch[u][v] == 0) &#123; memset(ch[sz], 0, sizeof(ch[sz])); val[sz] = 0; ch[u][v] = sz++; &#125; u = ch[u][v]; &#125; val[u] = key; &#125; void find();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738//左儿子，右兄弟版。 减少储存空间。struct Trie &#123; int head[maxnode]; // the i'th son. int next[maxnode]; // the i'th brother. char ch[maxnode]; int tot[maxnode]; int sz; void init() &#123; ans = 0; tot[0] = head[0] = next[0] = 0; sz = 1; &#125; void insert(string line) &#123; int u = 0, v; tot[0]++; for (int i = 0; i &lt; line.size(); i++) &#123; bool found = false; for (v = head[u]; v != 0; v = next[v]) &#123; if (ch[v] == line[i]) &#123; found = true; break; &#125; &#125; if (!found) &#123; v = sz++; tot[v] = head[v] = 0; ch[v] = line[i]; next[v] = head[u]; head[u] = v; &#125; u = v; tot[u]++; &#125; &#125;&#125;; 题目Remember the Word UVA - 1401 Trie + dp题意给出一个由n个不同单词组成的字典和一个长字符串。把这个字符串分解成若干个单词的连接（单词可以重复使用），有多少种方法？比如：有4个单词a,b,cd,ab,则abcd有两种分解方法: a+b+cd 和 ab+cd. 所有单词总共长度不超过300000。长字符串个数不超过4000. 每个长字符串不超过100。 全是小写字母。 分析对于每个长字符串line,123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990转移方程则为$$dp[i] =\sum(dp[i + prefix(i...L)])$$其中prefix(i..L) 表示从i到末尾这个字符串的每个前缀。若该前缀在字典树中存在则加上相应的dp的值。比如： abcdef设i为3，则prefix(3..5) 是 def,de,d ，为def的前缀。### 代码```cpp// ybmj#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 20071027;const int maxn = 300005;const int sigma_size = 26;const int maxnode = 4005 * 100; //words number * words lengthint dp[maxn];struct Trie&#123; int ch[maxnode][sigma_size]; int val[maxnode]; int sz; void init()&#123; memset(ch[0],0,sizeof(ch[0])); sz = 1; &#125; int idx(char c)&#123; return c - &apos;a&apos;; &#125; void insert(string line,int v)&#123; int u = 0; for(int i=0;i&lt;line.size();i++)&#123; int now = idx(line[i]); if(!ch[u][now])&#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz] = 0; ch[u][now] = sz++; &#125; u = ch[u][now]; &#125; val[u] = v; &#125; int query(const string &amp;line)&#123; memset(dp,0,sizeof(dp)); dp[line.size()] = 1; for(int i=line.size()-1;i &gt;= 0;i --)&#123; int now = 0; for(int k=0;k+i &lt; line.size();k++)&#123; int temp = idx(line[i+k]); if(!ch[now][temp]) break; now = ch[now][temp]; if(val[now])&#123; dp[i] = (dp[i] + dp[i+k+1]) % mod; &#125; &#125; &#125; return dp[0]; &#125;&#125;;Trie trie;int main()&#123; /* #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif */ std::ios::sync_with_stdio(false); string line; int kase = 1; while(cin &gt;&gt; line)&#123; int n; trie.init(); cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; string temp; cin &gt;&gt; temp; trie.insert(temp,1); &#125; int ans = trie.query(line); cout &lt;&lt; &quot;Case &quot; &lt;&lt; kase++ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl; &#125;&#125; “strcmp()” Anyone? UVA - 11732 左兄弟右儿子版题意strcmp比较两个字符串的次数,比如比较than 和 that,需要比较7次才能判断是否相等，比较there 和 the 也需要比较7次（因为结尾有’\0’）。 给定n个字符串，问需要比较总的次数是多少？ 最多4000个字符串，每个串不超过1000个字符。 分析将所有字符串都插入字典树中，对于每个插入的节点，其权值加一。 其余看代码吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 4005;const int maxnode = maxn * 1000;struct Trie &#123; int head[maxnode]; // the i'th son. int next[maxnode]; // the i'th brother. char ch[maxnode]; ll tot[maxnode]; int sz; ll ans; void init() &#123; ans = 0; tot[0] = head[0] = next[0] = 0; sz = 1; &#125; void insert(string line) &#123; int u = 0, v; tot[0]++; for (int i = 0; i &lt; line.size(); i++) &#123; bool found = false; for (v = head[u]; v != 0; v = next[v]) &#123; if (ch[v] == line[i]) &#123; found = true; break; &#125; &#125; if (!found) &#123; v = sz++; tot[v] = head[v] = 0; ch[v] = line[i]; next[v] = head[u]; head[u] = v; &#125; u = v; tot[u]++; &#125; &#125; void debug() &#123; for (int i = 0; i &lt; 7; i++) cout &lt;&lt; tot[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; void query(int u, int depth) &#123; if (head[u] == 0) &#123; ans += tot[u] * (tot[u] - 1) * depth; &#125; else &#123; int sum = 0; for (int v = head[u]; v != 0; v = next[v]) &#123; sum += tot[v] * (tot[u] - tot[v]); &#125; ans += sum / 2 * (2 * depth + 1); for (int v = head[u]; v != 0; v = next[v]) &#123; query(v, depth + 1); &#125; &#125; &#125;&#125;;Trie trie;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; int kase = 1; while (cin &gt;&gt; n) &#123; if (n == 0) break; trie.init(); for (int i = 0; i &lt; n; i++) &#123; string line; cin &gt;&gt; line; line.push_back('!'); //代替'\0' trie.insert(line); &#125; // trie.debug(); trie.query(0, 0); cout &lt;&lt; "Case " &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; trie.ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
        <category>Trie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F04%2F13%2FKMP%2F</url>
    <content type="text"><![CDATA[介绍功能：用来查找指定字符串。（从A串中查找B串） 优点：O(n)的复杂度，比较快。 本质：序列检测器。 思想 如图，进行第一次匹配的时候，在红色地方失配，接下来第二次直接从位置二开始匹配，这就是kmp算法的精髓。 去寻找最长的公共前后缀，一旦失配，直接“后缀变前缀”，从上图来说ababe,最长公共前后缀就是ab,（不考虑e，因为假设在e处失配）。 如图，在3处失配后，直接跳到1位置继续进行匹配。 这个back数组的含义就是：在第i位失配之后，[0, back[i]-1] 已经是成功的匹配了。 只要继续匹配第i位和back[i]即可。 模板123456789101112131415161718192021222324252627struct MP&#123; int back[maxn]; void getfail(string line)&#123; int i,k; k = back[0] = -1; i = 0; while(i &lt; line.size())&#123; while(k != -1 &amp;&amp; line[i] != line[k]) k = back[k]; back[++i] = ++k; &#125; &#125; int match(string T,string P)&#123; int i = 0,k = 0; int ret = 0; getfail(P); while(i &lt; T.size())&#123; while(k != -1 &amp;&amp; T[i] != P[k]) k = back[k]; ++i;++k; if(k &gt;= P.size())&#123; ret++; k = back[k]; &#125; &#125; return ret; &#125;&#125;; 题目Period UVA - 1371 back数组的应用题意给定一个长度为$n(2\leq n \leq 10^6)$的字符串S，求它每个前缀的最短循环节，换句话说，对于每个$i(2\leq i\leq n)$,求个一个最大的整数$K(K \geq 1)$（如果K存在），使得S的前i个字符组成的前缀是某个字符串重复K次得到的。输出所有存在K的i和对应的K。 比如对于字符串aabaabaabaab,只有当i = 2,6,9,12时K存在,且分别为2，2，3，4. 分析回想一下mp中getfail函数的含义。求第i个字符前的最长公共前后缀。 a b c a b c a b c a b c a b c a b c 如图，back[8] = 5,说明最后一位前面最长公共前后缀的长度为5，算上最后一位，那么最长公共前后缀的长度就为6. 试想，最长的前后缀有六位相同，也就是说中间有重叠的三个。 如图， 1 = a, 2 = b, 3 = c. 2 = a , 3 = b. 所以1 = 2 = 3 = a = b = c. a b c e e a b c a b c e e a b c 如图， 1 = a, 2 = b, 3 = c. 3 = a. 所以没有循环节。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ybmj#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1000000 + 5;struct MP &#123; int back[maxn]; void getFail(string P) &#123; back[0] = back[1] = 0; for (int i = 1; i &lt; P.size(); i++) &#123; int k = back[i]; while (k &amp;&amp; P[i] != P[k]) k = back[k]; back[i + 1] = P[i] == P[k] ? k + 1 : 0; &#125; // for (int i = 0; i &lt; P.size(); i++) &#123; // cout &lt;&lt; P[i] &lt;&lt; ' ' &lt;&lt; back[i] &lt;&lt; endl; // &#125; &#125;&#125;;MP mp;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; int kase = 1; while (cin &gt;&gt; n) &#123; if (n == 0) break; string line; cin &gt;&gt; line; // cout &lt;&lt; line &lt;&lt; endl; mp.getFail(line); cout &lt;&lt; "Test case #" &lt;&lt; kase++ &lt;&lt; '\n'; for (int i = 2; i &lt;= line.size(); i++) &#123; if (mp.back[i] &gt; 0 &amp;&amp; i % (i - mp.back[i]) == 0) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; i / (i - mp.back[i]) &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125;&#125; Obsessive String CodeForces - 494B mp + dp题意给定一个字符串T，让你选两个集合$A(a_i)，B(b_i)$，对于其中的$s_{a_i} ··· s_{b_i}$,含有指定字符串P。问总共有多少种不同的集合？ 结果模1e9+7. $(1 \leq T,P \leq 10^5)$ 分析我们只要保证所选的$s_{a_i} ··· s_{b_i}$中至少包含一个P串即可。 考虑dp。 dp[i] 表示以第i个字符结尾的前i个字符的选择方式。 关键是如何转移？ 假设P串的长度为m。 当T[i-m+1 … i] 与P串不同时,dp[i] = dp[i-1]. 否则，我们可以将 T[k…i] (k &lt; i-m+1) 作为集合中的一个确定的元素$(a_z = k,b_x = i)$，然后我们可以从T[1…k]中选择子串放到这个集合中，这样的选择一共有$\sum_{x=1}^{i-m} (sum[x]+1)$.多加1是因为，这个子串我可以什么都不选。 sum[i] 表示第i个字符前一共有多少种选择方式。 那么如何判断T[i-m+1 .. i] 与P串是否相同呢？ 当然是用mp算法，若相同，则将flag[i]记为1，否则为0. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;iomanip&gt;using namespace std;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9+7;const int maxn = 100005;bool flag[maxn];int dp[maxn],sum[maxn],tot[maxn];struct MP&#123; int back[maxn]; void getfail(string P)&#123; back[0] = back[1] = 0; for(int i=1;i&lt;P.size();i++)&#123; int k = back[i]; while(k &amp;&amp; P[i] != P[k]) k = back[k]; back[i+1] = P[i] == P[k] ? k+1 : 0; &#125; &#125; void match(string T,string P)&#123; getfail(P); int k = 0; for(int i=0;i&lt;T.size();i++)&#123; while(k &amp;&amp; T[i] != P[k]) k = back[k]; if(T[i] == P[k]) k++; if(k == P.size())&#123; flag[i] = 1; k = back[k]; &#125; &#125; &#125;&#125;;MP mp;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); string T,P; while(cin &gt;&gt; T &gt;&gt; P)&#123; memset(flag,0,sizeof(flag)); mp.match(T,P); dp[0] = 0; sum[0] = 0; tot[0] = 0; for(int i=1;i&lt;=T.size();i++)&#123; if(flag[i-1])&#123; dp[i] = (tot[i-P.size()] +i-P.size()+1) % mod; sum[i] = (sum[i-1] + dp[i]) % mod; tot[i] = (tot[i-1] + sum[i]) % mod; &#125; else&#123; dp[i] = dp[i-1]; sum[i] = (sum[i-1] + dp[i]) % mod; tot[i] = (tot[i-1] + sum[i]) % mod; &#125; &#125; cout &lt;&lt; sum[T.size()] &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
        <category>KMP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉路]]></title>
    <url>%2F2018%2F04%2F12%2F%E6%AC%A7%E6%8B%89%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[莫名其妙之前总结的不见了，只好ｃｏｐｙ一下蔡大佬的嘻嘻 基本概念欧拉图: 能够没有重复地一次遍历所有边的图。（必须是连通图） 欧拉路: 上述遍历的路径就是欧拉路。 欧拉回路: 若欧拉路是闭合的（一个圈，从起点开始遍历最终又回到起点），则为欧拉回路。 无向图G有欧拉路径的充要条件 G是连通图 G中奇顶点（连接边的数量为奇数）的数量等于0或2. 无向图G有欧拉回路的充要条件 G是连通图 G中每个顶点都是偶顶点 有向图G有欧拉路径的充要条件 G是连通图 u的出度比入度大1，v的出度比入度小1，其他所有点出度和入度相同。（u为起点，v为终点） 有向图G有欧拉回路的充要条件 G是连通图 G中每个顶点的出度等于入度 模板123456789101112131415int G[maxn][maxn];int deg[maxn][maxn];vector&lt;int&gt; Ans;void init() &#123; clr(G, 0), clr(deg, 0); &#125;void addedge(int u, int v) &#123; deg[u]++, deg[v]++, G[u][v]++, G[v][u]++; &#125;void Fleury(int s)&#123; for (int i = 0; i &lt; n; i++) if (G[s][i]) &#123; G[s][i]--, G[i][s]--; Fleury(i); &#125; Ans.pb(s);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>欧拉路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[吉哥系列故事――恨7不成妻]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%95%E2%80%95%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 4507 如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 整数中某一位是7； 整数的每一位加起来的和是7的整数倍； 这个整数是7的整数倍； 吉哥想知道在一定区间内和7无关的数字的平方和。 分析我们分析一个整数平方和的拆分$A^2 = (a + b + c + d) ^ 2 = a^2 + 2 \times a \times (b + c + d) + (b + c + d)^2$ 发现是可以递归计算的。 式子中需要用到数的和（sum） 而计算数的和需要用到数的个数 所以我们要维护三个值： cnt 满足条件数的个数 sum 满足条件数的和 squ 满足条件数的平方和 squ的计算方法上面已经给出来了，那么sum怎么计算呢？ 假设枚举到第i位，那么这一位的贡献就是 val pow(10,i) cnt val是当前数位的值，cnt是枚举到第i+1位时满足条件数的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9 + 7;int num[20];ll Pow[20];struct P &#123; ll cnt, squ, sum; P() &#123; cnt = -1; squ = sum = 0; &#125; P(int c, int s1, int s2) : cnt(c), sum(s1), squ(s2) &#123;&#125;&#125;;P dp[20][20][20];P dfs(int pos, bool limit, int sum, int mul) &#123; if (pos == -1) &#123; P ret(0, 0, 0); if (sum &amp;&amp; mul) ret.cnt = 1; return ret; &#125; if (!limit &amp;&amp; dp[pos][sum][mul].cnt != -1) return dp[pos][sum][mul]; int up = limit ? num[pos] : 9; P ans(0, 0, 0); for (int i = 0; i &lt;= up; i++) &#123; if (i == 7) continue; P temp = dfs(pos - 1, limit &amp;&amp; i == up, (sum + i) % 7, (mul * 10 + i) % 7); ll A = i * Pow[pos] % mod; ans.cnt += temp.cnt % mod; ans.cnt %= mod; ans.sum += (A * temp.cnt % mod + temp.sum) % mod; ans.sum %= mod; ans.squ += ((A * A % mod * temp.cnt % mod + 2 * A % mod * temp.sum) % mod + temp.squ) % mod; ans.squ %= mod; &#125; if (!limit) dp[pos][sum][mul] = ans; return ans;&#125;P solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 0, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; Pow[0] = 1; for (int i = 1; i &lt; 20; i++) &#123; Pow[i] = Pow[i - 1] * 10 % mod; &#125; while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; P R = solve(r); P L = solve(l - 1); cout &lt;&lt; (R.squ - L.squ + mod) % mod &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XHXJ's-LIS]]></title>
    <url>%2F2018%2F04%2F12%2FXHXJ-s-LIS%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 4352 一个整数，他的数位的最长上升子序列的长度为k，则成是合格的。 问区间内合格的整数的数量 分析因为数位的取值一共只有十个（0~9）， 所以我们可以用十个二进制来保存状态。 0表示出现过，1表示未出现过 最后check的时候检查状态中1的数量是否为k即可。 $dp[i][sta][k]$ i 表示枚举第i位，sta表示当前状态，k表示最长上升子序列的长度。 这里需要注意的是更新状态的方法。 做法与nlog(n)求最长上升子序列的思想相同。 假设要更新第pos位，那么就找原状态中第一个大于等于pos位置，然后将其置为0！ 然后把pos位设为1. 如果想不通就好好想想是怎么处理最长上升子序列的吧。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[20][1024][20];int num[20];int w[20];int K;int getnew(int sta, int val) &#123; for (int i = val; i &lt; 10; i++) &#123; if (sta &amp; (1 &lt;&lt; i)) return (sta ^ (1 &lt;&lt; i)) | (1 &lt;&lt; val); // !求最长上升子序列！ &#125; // sta ^= 1 &lt;&lt; (val); sta |= 1 &lt;&lt; (val); return sta;&#125;int getnum(int sta) &#123; int ret = 0; while (sta) &#123; if (sta &amp; 1) ret++; sta &gt;&gt;= 1; &#125; return ret;&#125;ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return getnum(sta) == K; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta][K] != -1) return dp[pos][sta][K]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, sta); else ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, getnew(sta, i)); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta][K] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, true, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T, kase = 1; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; ll l, r; cin &gt;&gt; l &gt;&gt; r &gt;&gt; K; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Round-Number]]></title>
    <url>%2F2018%2F04%2F12%2FRound-Number%2F</url>
    <content type="text"><![CDATA[题意来源： POJ - 3252 一个数其二进制表示形式，若0的数量大于等于1的数量，则称该数合格。 问区间内合格的整数的数量 分析$dp[i][sta]$ i表示枚举到当前位，sta表示到当前位一共有多少个0 因为sta可能会小于零，所以我们先给sta加一个值（offset），最后判断的时候再减去这个offset即可。 这里注意前导零的影响，因为前面的零是不算0的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[35];int dp[35][100];int dfs(int pos, int sta, bool limit, bool lead) &#123; if (pos == -1) return sta &gt;= 35; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 1; int ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, sta, limit &amp;&amp; i == num[pos], true); else ans += dfs(pos - 1, sta + (i == 0 ? 1 : -1), limit &amp;&amp; i == num[pos], false); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;int solve(int val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 2; val /= 2; &#125; return dfs(pos - 1, 35, true, true);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int l, r; clr(dp, -1); while (cin &gt;&gt; l &gt;&gt; r) &#123; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[F(x)]]></title>
    <url>%2F2018%2F04%2F12%2FF-x%2F</url>
    <content type="text"><![CDATA[题意来源： HDU - 4734 For a decimal number x with n digits $(A_n A_{n-1} … A_2 A_1)$, we define its weight as $F(x) = A_n \times 2^{n-1} + A_n-1 \times 2^{n-2} + … + A_1 \times 1$. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). 分析$dp[i][sta]$ 表示枚举到第i位，还有sta可用。 为什么不用sta表示前i位的和呢？ 以为A每次都是不一样的，所以每次都要清空dp数组，会超时的！ 注意 很重要的技巧！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 4700;ll W[] = &#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;;ll dp[12][maxn];int num[20];ll dfs(int pos, bool limit, int sta) &#123; if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; // 表示枚举到pos位，还有sta可用 int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (sta - i * W[pos] &gt;= 0) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], sta - i * W[pos]); &#125; else break; &#125; if (!limit) dp[pos][sta] = ans; return ans;&#125;ll solve(ll l, ll r) &#123; int pos = 0; int val = 0; while (l) &#123; val += (l % 10) * W[pos++]; l /= 10; &#125; pos = 0; while (r) &#123; num[pos++] = r % 10; r /= 10; &#125; return dfs(pos - 1, true, val);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T, kase = 1; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; solve(l, r) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不要62]]></title>
    <url>%2F2018%2F04%2F12%2F%E4%B8%8D%E8%A6%8162%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 2089 区间内不包含“62”或者“4”的整数的个数 分析数位dp的经典入门题，推荐一篇博文 里面讲的很清楚，就不再赘述了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[20][2];int num[20];ll dfs(int pos, bool limit, bool sta) &#123; // sta 表示前一位是否为6 if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (i == 4) continue; if (i == 2 &amp;&amp; sta == true) continue; if (i == 6) ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], true); else ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], false); &#125; if (!limit) dp[pos][sta] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, false);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); ll l, r; clr(dp, -1); while (cin &gt;&gt; l &gt;&gt; r) &#123; if (l == 0 &amp;&amp; r == 0) break; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beautiful-numbers]]></title>
    <url>%2F2018%2F04%2F12%2FBeautiful-numbers%2F</url>
    <content type="text"><![CDATA[题意来源：CodeForces - 55D 每个整数可以被他每个非零的数位整除。 问区间内符合上述条件的整数的个数。 分析被每个非零数位整除，即可以被所有非零数位的最小公倍数整除。 所以我们可以枚举这个最小公倍数，1~9的最小公倍数为2520. 所以我们可以得到 $dp[i][k][sta]$ i表示枚举到当前位，k表示所有数位的最小公倍数，sta表示当前整数模k的结果。 最后如果sta为0，则return 1 但是！ 爆内存了！ 考虑我们要枚举的是最小公倍数，但之前上我们做的是枚举1 到 2520，然而实际上真正的最小公倍数实际上不过只有40多个。（如果2520能被k整除，那么k一定是一个由若干数位组成的最小公倍数） 所以我们用一个map映射一下，就可以减少内存的消耗啦！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2600;ll dp[20][50][maxn];int num[20];map&lt;int, int&gt; maps;ll gcd(ll a, ll b) &#123; if (b) while ((a %= b) &amp;&amp; (b %= a)) ; return a + b;&#125;ll lcm(ll a, ll b) &#123; if (a == 0 || b == 0) return a + b; return a * b / gcd(a, b);&#125;ll dfs(int pos, bool limit, int sta, int val) &#123; if (pos == -1) &#123; if (val % sta == 0) &#123; return 1; &#125; else return 0; &#125; if (!limit &amp;&amp; dp[pos][maps[sta]][val] != -1) return dp[pos][maps[sta]][val]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], lcm(sta, i), (val * 10 + i) % 2520); &#125; if (!limit) dp[pos][maps[sta]][val] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 1, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int cnt = 0; for (int i = 1; i &lt;= 2520; i++) &#123; if (2520 % i == 0) &#123; maps[i] = cnt++; &#125; &#125; int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Balanced-Number-spoj]]></title>
    <url>%2F2018%2F04%2F12%2FBalanced-Number-spoj%2F</url>
    <content type="text"><![CDATA[题意来源：Cuban Olympiad in Informatics 2012 - Day 2 Problem A 数位的值为偶数，则要出现奇数次。 数位的值为奇数，则要出现偶数次。 计算区间内符合条件的整数的数量。 分析首先因为数位的值一共只有10个(0 ~ 9),所以我们可以用二进制来保存每个值出现的次数是奇是偶（0 表示出现偶数次，1 表示出现奇数次） 但有个问题是，如果某个值在整数中没有出现过，那么它并不能直接判定为0. 也就是说我们需要一个vis，来表示某个值（0 ～ 9）是否在当前整数中出现过。 我的解决办法是再用十位二进制数来记录，如果值出现过，则相应的二进制为1. 在check的时候，先检查当前数位是否出现过，再检查出现次数的奇偶性。 $dp[i][sta]$ i表示枚举到当前位，sta表示当前状态。（高十位表示vis，低十位表现出现次数的奇偶性） 注意 这种用二进制保存状态的方法非常常见！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e6 + 5e4;int num[25];ll dp[25][maxn];bool check(int sta) &#123; for (int i = 10; i &lt; 20; i++) &#123; if ((sta &gt;&gt; i) &amp; 1) &#123; if ((i &amp; 1) == ((sta &gt;&gt; (i - 10)) &amp; 1)) return false; &#125; &#125; return true;&#125;int getsta(int sta, int val) &#123; sta |= (1 &lt;&lt; (val + 10)); sta ^= (1 &lt;&lt; val); return sta;&#125;ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return check(sta); if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, limit &amp;&amp; i == up, true, sta); else ans += dfs(pos - 1, limit &amp;&amp; i == up, false, getsta(sta, i)); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, true, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ull l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Balanced-Number]]></title>
    <url>%2F2018%2F04%2F12%2FBalanced-Number%2F</url>
    <content type="text"><![CDATA[题意来源： HDU3709 一个数被称作平衡数当且仅当其存在一个对称轴，使得对称轴两边可以平衡。 定义重量为数位的值乘数位到对称轴的距离。 比如4139 可以把3当做对称轴，4 2 + 1 1 == 9 * 1 问区间内有多少个平衡数 分析枚举对称轴和对称轴左边的值 $dp[i][k][sta]$ i表示枚举到第i位，k表示对称轴的位置，sta表示枚举到当前位的值。 最后sta为0时表示当前整数符合条件，return 1. 这里如果sta变成负数，就不需要继续dfs下去了。 还要注意的是左边界为0，所以需要做一下特殊情况的判断。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[20];ll dp[20][20][2000];ll dfs(int pos, bool limit, int mid, int w) &#123; if (pos == -1) return w == 0; if (!limit &amp;&amp; dp[pos][mid][w] != -1) return dp[pos][mid][w]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (pos &gt; mid) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w + i * (pos - mid)); &#125; else if (pos &lt; mid) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w - i * (mid - pos)); &#125; else ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w); &#125; if (!limit) dp[pos][mid][w] = ans; return ans;&#125;ll solve(ll val) &#123; if (val == -1) return 0; if (val == 0) return 1; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; ll ans = 0; for (int i = 0; i &lt; pos; i++) &#123; ans += dfs(pos - 1, true, i, 0); &#125; return ans;&#125;int countnum(ll val) &#123; int cnt = 0; if (val &lt; 10) &#123; cnt = 1; &#125; else &#123; while (val) &#123; cnt++; val /= 10; &#125; &#125; return cnt;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; ll ans = solve(r) - solve(l - 1); int cntr = countnum(r); int cntl = countnum(l - 1); cout &lt;&lt; ans - (cntr - cntl) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B-number]]></title>
    <url>%2F2018%2F04%2F12%2FB-number%2F</url>
    <content type="text"><![CDATA[题意来源： HDU3652 区间内有多少个可以包含“13”，并且可以被13整除的数字。 分析$dp[i][k][sta]$ i表示枚举到第i位，k表示前i位组成的整数模13的结果，sta表示前一位是否为1，以及之前是否出现过13. 这里再解释一下k 假设整数A = （a + b + c + d) 那么A%13 == 0 等价于 (a + b + c + d) % 13 等价于a % 13 + b % 13 + c % 13 + d % 13 所以最后判断k是否为0，即可知道当前整数是否能被13整除。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[20];int dp[20][20][3];int dfs(int pos, bool limit, int val, int sta) &#123; if (pos == -1) return sta == 2 &amp;&amp; val == 0; if (!limit &amp;&amp; dp[pos][val][sta] != -1) return dp[pos][val][sta]; int up = limit ? pos[num] : 9; int ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (sta == 2) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 2); else if (i == 1) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 1); else if (sta == 1 &amp;&amp; i == 3) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 2); else ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 0); &#125; if (!limit) dp[pos][val][sta] = ans; return ans;&#125;int solve(int val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 0, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int val; clr(dp, -1); while (cin &gt;&gt; val) &#123; cout &lt;&lt; solve(val) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密体系]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8A%A0%E5%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[消息摘要消息摘要的作用在网络安全目标中，要求信息在生成、存储或传输过程中保证不被偶然或蓄意地删除、修改、伪造、乱序、重放、插入等破坏和丢失，因此需要一个较为安全的标准和算法，以保证数据的完整性。 常见的消息摘要算法 ： MD5 ，SHA Hash函数消息摘要算法采用单向散列（hash）函数从明文产生摘要密文。 散列函数的输出值有固定的长度，该散列值是消息M的所有位的函数并提供错误检测能力，消息中的任何一位或多位的变化都将导致该散列值的变化。从散列值不可能推导出消息M ，也很难通过伪造消息M’来生成相同的散列值。 Hash函数的值称为作为自变量的消息的“散列值”或“消息摘要”、“数字指纹” 消息M -&gt; Hash函数 -&gt; 散列值h(原像)…….(映射)…………(映像) 不同的原像映射出相同的映象称为“碰撞”或“冲突” 映象相同的两个原像互称为“等价原像” ###抗碰撞性 弱抗碰撞性(Weak collision resistance): 对于任意给定的M，找到满足 M≠N 且H(M)=H(N)的N，在计算上是不可行的； 强抗碰撞性(Strong collision resistance): 找到任何满足H(x)= H(y) 的偶对(x，y)在计算上是不可行的。 Hash函数的分类根据安全水平: 弱抗碰撞 强抗碰撞 根据是否使用密钥: 使用密钥，此时散列值称作 MAC(Message Authentication Code) 不使用密钥，此时散列值称作 MDC(Message Detection Code) ###Hash函数的应用 由Hash函数产生消息的散列值,以消息的散列值来判别消息的完整性 用加密消息的散列值来产生数字签名 用口令的散列值来安全存储口令（认证系统中的口令列表中仅存储口令的Hash函数值，以避免口令被窃取。认证时用输入口令的Hash函数值与其比较） ##消息摘要的安全隐患 无法完全阻止数据的修改。 如果在数据传递过程中，窃取者将数据窃取出来，并且修改数据，再重新生成一次摘要，将改后的数据和重新计算的摘要发送给接收者，接收者利用算法对修改过的数据进行验证时，生成的消息摘要和收到的消息摘要仍然相同，消息被判断为“没有被修改”。 所以除了需要知道消息和消息摘要之外，还需要知道发送者身份—消息验证码。 消息验证码即MAC(带密钥的哈希函数) 简单来说，发送者A和接受者B之间共同拥有一个密钥key，A将消息摘要用key加密。然后连同数据一起发给B。 B接收到之后，先用key对消息摘要解密，然后本地计算数据的消息摘要与解密得到的进行对比。 可以防止数据被修改。因为篡改者没有key。 消息验证码的局限性消息验证码可以保护信息交换双方不受第三方的攻击，但是它不能处理通信双方的相互攻击 信宿方可以伪造消息并称消息发自信源方，信源方产生一条消息，并用和信宿方共享的密钥产生认证码，并将认证码附于消息之后 信源方可以否认曾发送过某消息，因为信宿方可以伪造消息，所以无法证明信源方确实发送过该消息 在收发双方不能完全信任的情况下，引入数字签名来解决上述问题,数字签名的作用相当于手写签名 消息认证消息认证（message authentication）就是验证消息的完整性，当接收方收到发送方的报文时，接收方能够验证收到的报文是真实的和未被篡改的。它包含两层含义：一是验证信息的发送者是真正的而不是冒充的，即数据起源认证；二是验证信息在传送过程中未被篡改、重放或延迟等。 消息认证的方式 加密认证——用消息的密文本身充当认证信息 消息认证码MAC——由以消息和密钥作为输入的公开函数产生的认证信息 散列值──由以消息作为唯一输入的散列函数产生的认证信息（无需密钥） 基于消息加密的认证用对称密码体制进行加密认证过程──用同一密钥加密、解密消息 作用──认证+保密 原理──攻击者无法通过改变密文来产生所期望的明文变化 特点──接收方需要判别消息本身的逻辑性或合法性。“我请你吃饭”被乱改成“我请你謯斸” 私钥加密，公钥解密过程──发送者用自己的私钥加密明文、接收者用发送者的公钥解密密文 作用──认证及签名，但不保密 原理──因不知发送者的私钥，故其他人无法产生密文或伪造签名 若用公钥加密、私钥解密，则无法起到认证的作用。因为知道公钥的人都可以通过产生伪造的密文来篡改消息。 用私钥、公钥双重加密、解密过程──发送者先用自己的私钥加密明文，再用接收者的公钥加密一次；接收者先用自己的私钥解密密文，再用发送者的公钥解密一次 作用──认证、签名，且保密 原理──认证、签名由发送者的私钥加密实现；保密性由接收者的公钥加密保证 基于消息验证码MAC的认证产生──发送者以消息M和与接收者共享的密钥K为输入，通过某公开函数C进行加密运算得到MAC 传送并接收──M+MAC 认证──接收者以接收到的M和共享密钥K为输入，用C重新加密算得MAC’ ，若MAC’=MAC，则可确信M未被篡改 作用──认证，但不保密 基于散列值的认证 对附加了散列值的消息实施对称加密，得到并发送Ek(M+H(M)) —— 认证+保密 仅对散列值实施对称加密，得到Ek(H(M))，并与M一起发送 —— 认证+不保密 对散列值实施私钥加密，得到EKRa(H(M))并与M一起发送 —— 认证+签名，不保密 将消息与用私钥加密后的散列值一起再用共享密钥加密，最后得到Ek(M+EKRa(H(M)))并发送 —— 认证+签名+保密 将消息串接一个由通信各方共享的密值S后计算散列值，得到H(M+S)并与M一起发送 —— 认证，不保密 先将消息串接一个由通信各方共享的密值S后计算散列值，再将它与消息M一起用共享密钥加密，最后得到Ek(M+H(M+S))并发送 —— 认证+保密 数字签名在公钥体制中，用接受者的公钥加密消息得到密文，接受者用自己的私钥解密密文得到消息。加密过程任何人都能完成，解密过程只有接受者能够完成。 考虑一种相反的过程，发送者用自己的私钥“加密”消息得到“密文”，然后利用发送者的公钥“解密”密文得到消息。 很显然，加密只有发送者能够完成，而解密任何人都可以完成。 所以，任何人都可相信是特定的发送者产生了该消息，这就相当于“签名”，证明一个消息的所属。 数字签名的特点传统签名的基本特点: 与被签的文件在物理上不可分割 签名者不能否认自己的签名 签名不能被伪造 容易被验证 数字签名是传统签名的数字化: 能与所签文件“绑定” 签名者不能否认自己的签名 容易被自动验证 签名不能被伪造 数字签名必须具有下述特征 收方能够确认或证实发方的签名，但不能伪造，简记为R1-条件（unforgeable） 发方发出签名的消息给收方后，就不能再否认他所签发的消息，简记为S-条件(non-repudiation) 收方对已收到的签名消息不能否认，即有收报认证，简记作R2-条件 第三者可以确认收发双方之间的消息传送，但不能伪造这一过程，简记作T-条件 数字签名与消息认证的区别 与手书签名的区别：手书签名是模拟的，且因人而异。数字签名是0和1的数字串，因消息而异。 与消息认证的的区别：消息认证使收方能验证消息发送者及所发消息内容是否被窜改过。当收发者之间没有利害冲突时，这对于防止第三者的破坏来说是足够了。但当收者和发者之间有利害冲突时，就无法解决他们之间的纠纷，此时须借助满足前述要求的数字签名技术。 与消息加密区别：消息加密和解密可能是一次性的，它要求在解密之前是安全的；而一个签名的消息可能作为一个法律上的文件，如合同等，很可能在对消息签署多年之后才验证其签名，且可能需要多次验证此签名。因此，签名的安全性和防伪造的要求更高些，且要求证实速度比签名速度还要快，特别是联机在线实时验证。 数字签名的分类根据签名的内容分: 对整体消息的签名 对压缩消息的签名 按明、密文的对应关系划分: 确定性(Deterministic)数字签名，其明文与密文一一对应，它对一特定消息的签名不变化，如RSA、Rabin等签名； 随机化的(Randomized)或概率式数字签名 数字签名常见算法普通数字签名算法 RSA ElGamal /DSS/DSA ECDSA 盲签名算法 群签名算法 RSA 盲签名一般数字签名中，总是要先知道文件内容而后才签署，这正是通常所需要的。但有时需要某人对一个文件签名，但又不让他知道文件内容，称此为盲签名(Blind Signature) Chaum在1983年提出 适应于电子选举、数字货币协议中 群签名群体密码学由Desmedt于1987年提出，群签名是群体密码学中的课题，1991由Chaum和van Heyst提出，其特点有： 一个群体中的任意一个成员可以匿名地代表整个群体进行签名； 接收到签名的人可以用公钥验证群签名，但不可能知道由群体中哪个成员所签； 发生争议时可由群体中的成员或可信赖机构识别群签名的签名者。 数字水印数字水印（Digital Watermark）是指永久镶嵌在其它数据（主要指宿主数据）中具有可鉴别性的数字信号或数字模式。 特点 不可感知性（imperceptible）：包括视觉上的不可见性和水印算法的不可推断性。 鲁棒性（Robustness）：嵌入水印必须难以被一般算法清除。也就是说多媒体信息中的水印能够抵抗各种对数据的破坏，如A/D 、D/A转换、重量化、滤波、平滑、有失真压缩以及旋转、平移、缩放及分割等几何变换和恶意的攻击等。 可证明性：指对嵌有水印信息的图像，可以通过水印检测器证明嵌入水印的存在。 自恢复性：指含水印的图像在经受一系列攻击后（图像可能有较大的破坏），水印信息也经过了各种操作或变换。但可以通过一定的算法从剩余的图像片段中恢复出水印信息，而不需要整个原始图像的特性。 安全保密性：数字水印系统使用一个或多个密钥以确保安全，防止修改和擦除。同时若与密码学进行有机的结合，对数据可起到双重加密作用。 数字证书任何的密码体制都不是坚不可摧的，公开密钥体制也不例外。由于公开密钥体制的公钥是对所有人公开的，从而免去了密钥的传递，简化了密钥的管理。 但是这个公开性在给人们带来便利的同时，也给攻击者冒充身份篡改公钥有可乘之机。所以，密钥也需要认证，在拿到某人的公钥时，需要先辨别一下它的真伪。这时就需要一个认证机构，将身份证书作为密钥管理的载体，并配套建立各种密钥管理设施。 数字证书（Digital Certificate）又称为数字标识（Digital ID）。它提供一种在Internet上验证身份的方式，是用来标志和证明网络通信双方身份的数字信息文件。 数字安全证书是由权威公正的第三方机构即CA中心签发的。它是在证书申请被认证中心批准后，通过登记服务机构将其发放给申请者。 数字证书的内容最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。一般情况下证书中还包括密钥的有效时间，发证机关(证书授权中心)的名称，该证书的序列号等信息，证书的格式遵循ITU-T X.509国际标准。 一个标准的X.509数字安全证书包含以下一些内容： 证书的版本号。不同的版本的证书格式也不同，在读取证书时首先需要检查版本号。 证书的序列号。每个证书都有一个唯一的证书序列号。 证书所使用的签名算法标识符。签名算法标识符表明数字签名所采用的算法以及使用的参数。 证书的发行机构名称。创建并签署证书的CA的名称，命名规则一般采用X.500格式。 证书的有效期。证书的有效期由证书有效起始时间和终止时间来定义。 证书所有人的名称。命名规则一般采用X.500格式； 证书所有人的公开密钥及相关参数。相关参数包括加密算法的标识符及参数等 证书发行机构ID。这是版本2中增加的可选字段。 证书所有人ID。这是版本2中增加的可选字段。 扩展域。这是版本3中增加的字段，它是一个包含若干扩展字段的集合。 证书发行机构对证书的签名，即CA对证书内除本签名字段以外的所有字段的数字签名。 认证中心CA（Certificate Authority，认证中心）作为权威的、可信赖的、公正的第三方机构，专门负责发放并管理所有参与网上交易的实体所需的数字证书。 CA作为一个权威机构，对密钥进行有效地管理，颁发证书证明密钥的有效性，并将公开密钥同某一个实体（消费者、商户、银行）联系在一起。 CA的主要职责 颁发证书：如密钥对的生成、私钥的保护等，并保证证书持有者应有不同的密钥对。 管理证书：记录所有颁发过的证书，以及所有被吊销的证书。 用户管理：对于每一个新提交的申请，都要和列表中现存的标识名相比较，如出现重复，就给予拒绝。 吊销证书：在证书有效期内使其无效，并发表CRL（Certificate Revocation List，被吊销的证书列表） 验证申请者身份：对每一个申请者进行必要的身份认证。 保护证书服务器：证书服务器必须安全的，CA应采取相应措施保证其安全性。 保护CA私钥和用户私钥：CA签发证书所用的私钥要受到严格的保护，不能被毁坏，也不能被非法使用。同时，根据用户密钥对的产生方式，CA在某些情况下有保护用户私钥的责任。 审计和日志检查：为了安全起见，CA对一些重要的操作应记入系统日志。在CA发生事故后，要根据系统日志做善后追踪处理――审计，CA管理员要定期检查日志文件，尽早发现可能的隐患。 CA的基本组成认证中心主要有三个部分组成: 注册服务器（RS）：面向用户，包括计算机系统和功能接口； 注册中心（RA）：负责证书的审批； 认证中心（CA）：负责证书的颁发，是被信任的部门 一个完整的安全解决方案除了有认证中心外，一般还包括以下几个方面： 密码体制的选择 安全协议的选择2.1 SSL（Secure Socket Layer 安全套接字层）2.2 S-HTTP（Secure HTTP，安全的http协议）2.3 SET（Secure Electonic Transaction，安全电子交易协议） CA的三层体系结构 第一层为RCA（Root Certificate Authority，根认证中心）。它的职责是负责制定和审批CA的总政策，签发并管理第二层CA的证书，与其它根CA进行交叉认证。 第二层为BCA（Brand Certificate Authority，品牌认证中心）。它的职责是根据RCA的规定，制定具体政策、管理制度及运行规范；签发第三层证书并进行证书管理。 第三层为ECA（End user CA，终端用户CA）。它为参与电子商务的各实体颁发证书。签发的证书可分为三类：分别是支付网关（Payment Gateway）、持卡人（Cardholder）和商家（Merchant）签发的证书；签发这三种证书的CA对应的可称之为PCA、CCA和MCA。]]></content>
      <categories>
        <category>信息安全</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hash——MD5 and SHA]]></title>
    <url>%2F2018%2F04%2F08%2FHash%2F</url>
    <content type="text"><![CDATA[MD5 : Message-Digest作用通过对原文件通过运算，产生出一个固定长度（通常为128位）的散列值（Hash Value）。 哪怕原文件有一点点的改动，这个Hash Value都会产生巨大的差异。 因此可以用来验证文件的的完整性： 我将文件和这个Hash Value一起发送给另一个人，他只要检查一下文件的Hash Value和我发过去的Hash Value是否相同即可知道文件是否完整。 MD5亦有应用于部份网上赌场以保证赌博的公平性，原理是系统先在玩家下注前已生成该局的结果，将该结果的字串配合一组随机字串利用MD5 加密，将该加密字串于玩家下注前便显示给玩家，再在结果开出后将未加密的字串显示给玩家，玩家便可利用MD5工具加密验证该字串是否吻合。—— From Wikipedia 缺陷2009年，我国研究人员在$2^{20.96}$的时间复杂度下破解了MD5的碰撞抵抗。 但这里的破解也只是非特定碰撞，由于MD5算法的特性，要构造出特定内容的碰撞有很大难度。 因此仅用MD5来检测文件完整性一致性已经是不可行的了。但由于其操作简单，还有一些人在使用。 SHA 作用与MD5一样，只是生成算法不同。 相对于MD5，性能肯定没那么好，但是目前来说是很安全的！ 代码参考本人 github]]></content>
      <categories>
        <category>信息安全</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf961D Pair Of Lines]]></title>
    <url>%2F2018%2F04%2F05%2Fcf961D-Pair-Of-Lines%2F</url>
    <content type="text"><![CDATA[题意题目链接给你n个点（二维），问是否能找出两条直线，使得可以覆盖所有点。 分析假设原图满足题目要求。 那么我们每次随机取两个点，将该直线上的点全部去掉， 然后判断剩下的点是否共线。 因为原图满足题目要求，所以我们可以将图中的点分为两个点集。 假设其中一个点集中点的数量为x，则另一个点集中点的数量为y = n-x 那么我们取到的两个点在一个点集中的概率就是$1 - \frac{ C_{x}^{1} \times C_{y}^{1} } { C_{n}^{2}}$ 由基本不等式可知，上述概率至少是$\frac{1}{2}$ 我们可以随机一百次，这样如果原图是满足题目要求的，那么他成功选取同一个点集中两个点的概率就是$1 - \frac{1}{2^{100}}$. 即，如果原图满足条件，则大概率可以输出yes. 注意 每次随机要更换种子！1srand(time(0)) // 利用当前系统时间作为种子 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 1e5 + 5;const double eps = 1e-9;pair&lt;ll, ll&gt; p[maxn];int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p[i].first &gt;&gt; p[i].second; &#125; if (n &lt;= 2) &#123; cout &lt;&lt; "yes" &lt;&lt; endl; return 0; &#125; srand(time(0)); //注意！ bool flag = false; for (int i = 0; i &lt; 100; i++) &#123; int p1 = rand() % n; int p2 = rand() % n; while (p1 == p2) p2 = rand() % n; ll a = p[p2].first - p[p1].first; ll b = p[p2].second - p[p1].second; ll m = p[p1].second * p[p2].first - p[p1].first * p[p2].second; vector&lt;int&gt; V; for (int i = 0; i &lt; n; i++) &#123; if (m != p[i].second * a - b * p[i].first) V.push_back(i); &#125; if (V.size() &lt;= 2) &#123; flag = true; break; &#125; p1 = V[0]; p2 = V[1]; a = p[p2].first - p[p1].first; b = p[p2].second - p[p1].second; m = p[p1].second * p[p2].first - p[p1].first * p[p2].second; flag = true; for (int i = 2; i &lt; V.size(); i++) &#123; if (m != p[V[i]].second * a - b * p[V[i]].first) &#123; flag = false; break; &#125; &#125; if (flag) break; &#125; if (flag) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>随机概率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Build Blog]]></title>
    <url>%2F2018%2F04%2F04%2FBuild-Blog%2F</url>
    <content type="text"><![CDATA[https://xuanwo.org/2015/03/26/hexo-intor/ https://righere.github.io/2016/10/10/install-hexo/ 利用Travis实现自动部署 ：http://www.cnblogs.com/babycool/p/7326722.html 对于购买过域名的同学，要在Source里面加一个CNAME文件，里面写上新的域名即可。]]></content>
      <categories>
        <category>关于本博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Prim]]></title>
    <url>%2F2018%2F04%2F04%2FPrim%2F</url>
    <content type="text"><![CDATA[Prim思想:Prim和Kruskal实质上都是用了权值最小的边一定在生成树中这个性质。 Kruskal对于稠密图来说性能比较差，因为要维护一个权值最小的边，所以有一个优先队列。 而Prim对于稠密图有比较好的性能，那么它是怎么确定权值最小的边？ Prim与Kruskal不同的是，Prim每次以一个没有访问过的点为起点，在所有连接着起点的边中找一个最小。而Kruskal每次找的是整张图中权值最小的边，并用并查集来维护访问过的点。 设n为顶点数量 所以Prim只要对每个顶点都做一次上述的操作即可得到最小生成树，时间复杂度为$O(n^2)$ 1234567891011121314151617181920212223242526272829// 耗费矩阵cost[][],标号从0开始,0~n-1// 返回最小生成树的权值,返回-1表示原图不连通// O(n^2)const int maxn = 100;bool vis[maxn];int lowc[maxn];int cost[maxn][maxn]; //初始化为正无穷int Prim(int n) &#123; int ans = 0; clr(vis, 0); vis[0] = 1; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; vis[p] = 1; ans += minc; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LCA---Tarjan]]></title>
    <url>%2F2018%2F03%2F28%2FLCA-Tarjan%2F</url>
    <content type="text"><![CDATA[网上看到一篇很详细的blog，带有模拟过程，所以自己就不再写啦（懒癌.. Tarjan算法是离线的，时间复杂度为O(n+q) 转载自 大神博客 假设我们有一组数据 9个节点 8条边 联通情况如下： 1–2，1–3，2–4，2–5，3–6，5–7，5–8，7–9 即下图所示的树 设我们要查找最近公共祖先的点为9–8，4–6，7–5，5–3； 设f[]数组为并查集的父亲节点数组，初始化f[i]=i，vis[]数组为是否访问过的数组，初始为0; 下面开始模拟过程： 取1为根节点，往下搜索发现有两个儿子2和3； 先搜2，发现2有两个儿子4和5，先搜索4，发现4没有子节点，则寻找与其有关系的点； 发现6与4有关系，但是vis[6]=0，即6还没被搜过，所以不操作； 发现没有和4有询问关系的点了，返回此前一次搜索，更新vis[4]=1； 表示4已经被搜完，更新f[4]=2，继续搜5，发现5有两个儿子7和8; 先搜7，发现7有一个子节点9，搜索9，发现没有子节点，寻找与其有关系的点； 发现8和9有关系，但是vis[8]=0,即8没被搜到过，所以不操作； 发现没有和9有询问关系的点了，返回此前一次搜索，更新vis[9]=1； 表示9已经被搜完，更新f[9]=7，发现7没有没被搜过的子节点了，寻找与其有关系的点； 发现5和7有关系，但是vis[5]=0，所以不操作； 发现没有和7有关系的点了，返回此前一次搜索，更新vis[7]=1； 表示7已经被搜完，更新f[7]=5，继续搜8，发现8没有子节点，则寻找与其有关系的点； 发现9与8有关系，此时vis[9]=1，则他们的最近公共祖先为find(9)=5； (find(9)的顺序为f[9]=7–&gt;f[7]=5–&gt;f[5]=5 return 5;) 发现没有与8有关系的点了，返回此前一次搜索，更新vis[8]=1； 表示8已经被搜完，更新f[8]=5，发现5没有没搜过的子节点了，寻找与其有关系的点； 发现7和5有关系，此时vis[7]=1，所以他们的最近公共祖先为find(7)=5； (find(7)的顺序为f[7]=5–&gt;f[5]=5 return 5;) 又发现5和3有关系，但是vis[3]=0，所以不操作，此时5的子节点全部搜完了； 返回此前一次搜索，更新vis[5]=1，表示5已经被搜完，更新f[5]=2； 发现2没有未被搜完的子节点，寻找与其有关系的点； 又发现没有和2有关系的点，则此前一次搜索，更新vis[2]=1； 表示2已经被搜完，更新f[2]=1，继续搜3，发现3有一个子节点6； 搜索6，发现6没有子节点，则寻找与6有关系的点，发现4和6有关系； 此时vis[4]=1，所以它们的最近公共祖先为find(4)=1; (find(4)的顺序为f[4]=2–&gt;f[2]=2–&gt;f[1]=1 return 1;) 发现没有与6有关系的点了，返回此前一次搜索，更新vis[6]=1，表示6已经被搜完了； 更新f[6]=3，发现3没有没被搜过的子节点了，则寻找与3有关系的点； 发现5和3有关系，此时vis[5]=1，则它们的最近公共祖先为find(5)=1； (find(5)的顺序为f[5]=2–&gt;f[2]=1–&gt;f[1]=1 return 1;) 发现没有和3有关系的点了，返回此前一次搜索，更新vis[3]=1； 更新f[3]=1，发现1没有被搜过的子节点也没有有关系的点，此时可以退出整个dfs了。 经过这次dfs我们得出了所有的答案，有没有觉得很神奇呢？是否对Tarjan算法有更深层次的理解了呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ybmjvector&lt;pair&lt;int, int&gt; &gt; G[maxn], Q[maxn];bool vis[maxn];int par[maxn], dist[maxn], ANS[maxn];int find(int u) &#123; return u == par[u] ? u : par[u] = find(par[u]); &#125;void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; par[v] = u; &#125;&#125;void initn(int n) &#123; for (int i = 0; i &lt; n + 1; i++) &#123; G[i].clear(); vis[i] = 0; par[i] = i; &#125;&#125;void initm(int m) &#123; for (int i = 0; i &lt; m + 1; i++) &#123; Q[i].clear(); &#125;&#125;void add_edge(int u, int v, int w) &#123; G[u].pb(mp(v, w)); G[v].pb(mp(u, w));&#125;void add_query(int u, int v, int id) &#123; Q[u].pb(mp(v, id)); Q[v].pb(mp(u, id));&#125;void Tarjan(int u, int fa) &#123; vis[u] = true; for (auto V : G[u]) &#123; if (fa != V.first) &#123; Tarjan(V.first, u); merge(u, V.first); // 注意合并顺序，一定是v合并到u上 &#125; &#125; for (auto V : Q[u]) &#123; if (vis[V.first] == true) &#123; ANS[V.second] = find(V.first); // 公共祖先为par[v] &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最近公共祖先LCA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Manacher]]></title>
    <url>%2F2018%2F03%2F09%2FManacher%2F</url>
    <content type="text"><![CDATA[Manacher本文转载自： 链接 问题定义最长回文子串问题：给定一个字符串，求它的最长回文子串长度。 如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例： 112321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词） Brute-force 解法对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有$n^2$个子串。这些子串的平均长度大约是$n/2$，因此这个解法的时间复杂度是$O(n^3)$。 改进的方法显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有2n-1个，在每个位置上平均大约要进行$n/4$次字符比较，于是此算法的时间复杂度是$O(n^2)$。 Manacher 算法对于一个比较长的字符串，$O(n^2)$的时间复杂度是难以接受的。Can we do better? 先来看看解法2存在的缺陷。 1.由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法2要对两种情况分别处理； 2.很多子串被重复多次访问，造成较差的时间效率。 缺陷2）可以通过这个直观的小🌰体现： 12char: a b a b a i : 0 1 2 3 4 当 i==1，和 i ==2 时，左边的子串aba分别被遍历了一次。 如果我们能改善解法2的不足，就很有希望能提高算法的效率。Manacher正是针对这些问题改进算法。 解决长度奇偶性带来的对称轴位置问题Manacher算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。以插入#号为例：12aba ———&gt; #a#b#a#abba ———&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。 解决重复访问的问题我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用RL[i]表示以第i个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义RL[i]为第i个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组：123456789char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 上面我们还求了一下RL[i]-1。通过观察可以发现，RL[i]-1的值，正是在原本那个没有插入过分隔符的串中，以位置i为对称轴的最长回文串的长度。那么只要我们求出了RL数组，就能得到最长回文子串的长度。 于是问题变成了，怎样高效地求的RL数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量MaxRight，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下MaxRight对应的回文串的对称轴所在的位置，记为pos，它们的位置关系如下。 我们从左往右地访问字符串来求RL，假设当前访问到的位置为i，即要求RL[i]，在对应上图，i必然是在po右边的(obviously)。但我们更关注的是，i是在MaxRight的左边还是右边。我们分情况来讨论。 1）当i在MaxRight的左边 情况1)可以用下图来刻画： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以i为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到i关于pos的对称位置j，这个j对应的RL[j]我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。 以j为对称轴的回文串比较短，短到像下图这样。 这时我们知道RL[i]至少不会小于RL[j]，并且已经知道了部分的以i为中心的回文串，于是可以令RL[i]=RL[j]。但是以i为对称轴的回文串可能实际上更长，因此我们试着以i为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以j为对称轴的回文串很长，这么长： 这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 具体操作如下： step 1: 令RL[i]=min(RL[2*pos-i], MaxRight-i)step 2: 以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。step 3: 更新MaxRight和pos2）当i在MaxRight的右边 遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从i的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新MaxRight和pos。 代码1234567891011121314151617181920212223const int maxn = 1e6+5;char Ma[maxn*2]; //插入新字符后的字符串int Mp[maxn*2]; //以当前位置为对称轴的回文半径void Manacher(string &amp;s)&#123; int l = 0; Ma[l++] = '$'; //防止越界 Ma[l++] = '#'; for(int i=0;i&lt;s.size();i++)&#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; //结尾设置为空字符，防止越界 int mx = 1,id = 1; for(int i=1;i&lt;l;i++)&#123; Mp[i] = mx &gt; i ? min(Mp[2*id-i],mx-i) : 1; while(Ma[i+Mp[i]] == Ma[i-Mp[i]]) Mp[i] ++; //扩展 if(i + Mp[i] &gt; mx)&#123; mx = i + Mp[i]; id = i; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
        <category>最长回文子串</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kruskal]]></title>
    <url>%2F2018%2F03%2F09%2FKruskal%2F</url>
    <content type="text"><![CDATA[kruskal思想：贪心+并查集 从权值最小的边开始遍历，若当前两个点在一个连通分量里，则忽略。 否则选取这条边加入到最小生成树中，当选取n-1条边后停止，因为只需要n-1条边即可连接n个点。 若图不连通，则会出现问题… 可以稍微模改一下 (●’◡’●) 模板123456789101112131415161718192021222324252627282930313233const int maxn = 10;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;Edge&gt; edges;int par[maxn];void addedge(int u, int v, int w) &#123; edges.push_back(Edge(u, v, w)); // edges.push_back(Edge(v, u, w));&#125;int find(int x) &#123; return par[x] == x ? x : find(par[x]); &#125;int kruskal(int n) &#123; int ans = 0; for (int i = 0; i &lt; n; i++) par[i] = i; sort(edges.begin(), edges.end()); //按权值排序 int cnt = 0; for (int i = 0; i &lt; edges.size(); i++) &#123; if (cnt &gt;= n - 1) break; Edge &amp;now = edges[i]; int x = find(now.u); int y = find(now.v); if (x != y) &#123; cnt++; par[x] = y; ans += now.w; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Floyd-Warshall]]></title>
    <url>%2F2018%2F03%2F09%2FFloyd-Warshall%2F</url>
    <content type="text"><![CDATA[Floyd_Warshall思想通过不断的松弛操作求有向图或无向图上任意两点间的最短距离。 同时可以判断图中是否存在负环。（如果自身到自身的距离被更新，说明存在负环） 转移： 任意两点如i到k，其最短距离可以表示为dp[i][k]。 $$dp[i][k] = min(dp[i][k], dp[i][t] + dp[t][k])$$ 表示i到k的最短距离可以由i到t的最短距离距离加上t到k的最短距离更新 通过枚举起点，中间节点和终点，可以得到任意两点间的最短距离。 时间复杂度 ：$O(N^3)$ 传递闭包作用 : 判断任意两点间是否连通。 如果i和k之间有通路,则$dp[i][k] = 1$,否则为0. 那么递推式变为$$dp[i][k] = dp[i][k]\ ||\ (dp[i][t]\ \&amp;\&amp;\ dp[t][k])$$ 但因为复杂度较高，所以还是慎用。 模板12345678910111213141516171819202122232425const int maxn = 100;int dp[maxn][maxn];// dp初始化为正无穷void addedge(int u, int v, int w) &#123; dp[u][v] = w; // dp[v][u] = w;&#125;bool floyd_warshall(int n) &#123; for (int i = 0; i &lt; n; i++) dp[i][i] = 0; for (int t = 0; t &lt; n; t++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; n; k++) &#123; if (dp[i][k] &gt; dp[i][t] + dp[t][k]) &#123; dp[i][k] = dp[i][t] + dp[t][k]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (dp[i][i] &lt; 0) &#123; return false; // exist negative circle &#125; &#125; return true;&#125; 练习题]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2018%2F03%2F09%2FDijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra思想本质上是个贪心。 从起点开始，依次把连通的路放到优先队列里（权值小的在top),然后每次取top，相当于连接这条边，再把与边的另一点所连接的边都放到优先队列里。（把已经连接的边看作一个整体） 注意: 图中不能存在负权边 时间复杂度 : $O(E \times logV)$ 模板1234567891011121314151617181920212223242526272829typedef pair&lt;int, int&gt; pii;const int maxn = 100;int d[maxn];vector&lt;pii&gt; G[maxn];inline void addedge(int u, int v, int w) &#123; G[u].push_back(make_pair(w, v)); // G[v].push_back(make_pair(w,u));&#125;void dijkstra(int s, int n) &#123; for (int i = 0; i &lt; n; i++) d[i] = INF; d[s] = 0; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq; pq.push(mp(0, s)); while (!pq.empty()) &#123; pii now = pq.top(); pq.pop(); int v = now.second; if (d[v] &lt; now.first) continue; //剪枝！ 重要 for (int i = 0; i &lt; G[v].size(); i++) &#123; pii e = G[v][i]; int to = e.second; if (d[to] &gt; d[v] + e.first) &#123; d[to] = d[v] + e.first; pq.push(pii(d[to], to)); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bellman-Ford]]></title>
    <url>%2F2018%2F03%2F09%2FBellman-Ford%2F</url>
    <content type="text"><![CDATA[Bellman_Ford思想实际上就是Floyd_Warshall的单源版本 不断对边进行松弛操作，其实就是再求两点间的最小距离，因为每次更新两点之间的最小距离，可能会影响到其它两点间的最小距离。 方程表示就是$$dp[i][k] = min(dp[i][k],dp[i][t]+dp[t][k])$$ 当，$dp[i][t]$或$dp[t][k]$被更新的时候，也许$dp[i][k]$会发生改变。 所以这样一直更新下去，直到没有更新，就结束了。 因为有V个顶点，所以最多更新V-1次。 这个可以这么理解：每次对所有边松弛之后，至少有一个点会被更新。 所以V个点的图，除了起点，就剩下V-1个点了，所以最多更新V-1次。 若更新超过 V-1 次，则说明图中存在负环。 时间复杂度 : $O(E\times V)$ 模板12345678910111213141516171819202122232425262728293031struct Edge&#123; int u,v,w; Edge(int u,int v,int w):u(u),v(v),w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;inline void addedge(int u,int v,int w)&#123; edges.push_back(Edge(u,v,w)); // edges.push_back(Edge(v,u,w));&#125;bool bellman_ford(int s,int n)&#123; for(int i=0;i&lt;n;i++) d[i] = INF; d[s] = 0; int cnt = 0; while(true)&#123; if(cnt &gt; n-1) return false; // exist negative circle cnt++; bool update = false; for(int i=0;i&lt;edges.size();i++)&#123; int from = edges[i].from; int to = edges[i].to; if(d[to] &gt; d[from] + edges[i].w)&#123; d[to] = d[from] + edges[i].w; // par[to] = from; // record path update = true; &#125; &#125; if(update == false) break; &#125; return true;&#125; 练习题]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最小费用最大流]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[最小费最大流思想最小费最大流问题是指：在每条边都有一个权值的时候，使得流量最大时候，权值和最小。 基本思想和最大流的相同，只不过找边的时候用bellmanford，因为会存在负边。 注意这里的费用（可改进量）指的是单位流量的费用。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct Edge&#123; int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) &#123;&#125;&#125;;struct MCMF&#123; int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; //是否在队列中 int d[maxn]; //bellmanford 到源点距离 int p[maxn]; //上一条弧 int a[maxn]; //可改进量 void init(int n)&#123; this-&gt; n = n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost)&#123; edges.push_back(Edge(from,to,cap,0,cost)); edges.push_back(Edge(to,from,0,0,-cost)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BellmanFord(int s,int t,int&amp; flow,ll&amp; cost)&#123; for(int i=0;i&lt;=n;i++) d[i] = INF; memset(inq,0,sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); inq[u] = 0; for(int i=0;i&lt;G[u].size();i++)&#123; Edge&amp; e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to]) &#123;Q.push(e.to); inq[e.to] = 1;&#125; &#125; &#125; &#125; if(d[t] == INF) return false; // 当没有可增广的路时退出 flow += a[t]; cost += (ll)d[t] * (ll)a[t]; for(int u=t; u!= s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; return true; &#125; int MincostMaxflow(int s,int t,ll&amp; cost)&#123; int flow = 0; cost = 0; while(BellmanFord(s,t,flow,cost)); return flow; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最大流]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[最大流 - 增广路算法思想 将A看作水源，G看作汇点，每一条边可以看作管道，每个管道有一个最大容量，每条路上有一个流量。很明显每条管道上的流量是不可能超过管道的容量的。 现在水从A源源不断的流入，那么单位时间内流过G的最大流量是多少？ 算法很显然： 不断找能从起点走到汇点的路即可。 接下来介绍增广路算法。 什么是增广路？ 就是每一条能从起点走到汇点的路，已经满流的路就不用管了。 证明： 若还能够从s出发，找到一条通往t的，权值不为0的路径，即当前的流量还可以继续增加。直到无法找到这样一条路，这样的流量就是最大的。 为什么要建立反向边？ 因为在有的图中 不只有单向边 可能从 a到b 的容量为5， b到a的容量为3. 所以对于只有单向边的图，我们可以认为 反向边的容量为0. 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Edge&#123; int from,to,cap,flow; Edge(int u,int v,int c,int f): from(u),to(v),cap(c),flow(f) &#123;&#125;&#125;;struct EdmonsKarp&#123; //时间复杂度O(v*E*E) int n,m; vector&lt;Edge&gt; edges; //边数的两倍 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号 int a[maxn]; //起点到i的可改进量 int p[maxn]; //最短路树上p的入弧编号 void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap)&#123; edges.push_back(Edge(from,to,cap,0)); edges.push_back(Edge(to,from,0,0)); //反向弧 m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; int Maxflow(int s,int t)&#123; int flow = 0; for(;;)&#123; memset(a,0,sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while(!Q.empty())&#123; int x = Q.front();Q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; Edge&amp; e = edges[G[x][i]]; if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123; //!a[e.to] 是了保证不会回退和出现分叉 p[e.to] = G[x][i]; //记录边的编号 a[e.to] = min(a[x],e.cap - e.flow); Q.push(e.to); &#125; &#125; if(a[t]) break; //走到汇点 &#125; if(!a[t]) break; //没有一条增广路存在 for(int u=t;u != s;u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序思想拓扑排序: 就是按照逻辑上先后发生的顺序进行排序。 所以只有 有向图 才有拓扑序。 根据定义，如果图中有环则不能拓扑排序。 常用的方法有两种，一种是dfs，一种是根据度来bfs（可以字典序）。 这里主要介绍第二种方法。 把每一个事件都看作一个点。如果a事件在b事件后面发生，则连一条a到b的有向边。 如果一个点的入度为0，那么说明没有事件早于它发生，则将它入队。所以我们要先将所有入度为0的点入队。 每次取队头元素记为u， 将所有与u相连的点的入度减一，如果入度为0了，则入队。 如果原图中存在环，则最后topo数组内元素的数量一定小于n。 优点： 这种方法是以点为重心，dfs是以边为重心。那么如果有删边的操作，最好就用第二种方法 ： 直接入度减一即可。 可以保证拓扑序是按照字典序的。 如果想要输出是字典序的话，需要将队列改为优先队列。（ 如果用邻接矩阵实现，需要去重边 注意 : 判环的时候，如果是邻接矩阵实现，则要判重边！ 模板1234567891011121314151617181920212223242526vector&lt;int&gt; G[maxn],topo; //存图； 记录拓扑序。int deg[maxn];void addedge(int u,int v)&#123; G[u].push_back(v);&#125;bool Topo(int n)&#123; queue&lt;int&gt; Q; topo.clear(); for(int i=1;i&lt;=n;i++) if(deg[i] == 0) Q.push(i); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); topo.push_back(u); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(deg[v] &gt; 0)&#123; deg[v]--; if(deg[v] == 0) Q.push(v); &#125; &#125; &#125; if(topo.size() != n) return false; //存在环 return true;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强联通分量——Tarjan]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F%E2%80%94%E2%80%94Tarjan%2F</url>
    <content type="text"><![CDATA[强联通分量 Tarjan概念强连通(Strongly Connected Compeonent) 指在一张有向图中，各个点互相可达。则称此图强连通。 若图中有子图是强连通的，则该子图成为强连通分量。 实际问题中，强连通分量往往会被看成一个点来处理(缩点)。 学习的博客：博客地址 Tarjan本质是在 dfs的过程中去维护一些信息 ： dfn数组： 时间戳，表示每个结点的访问顺序。 同时表示 一个强连通分量的“根”. 这里的意思是指：每走到一个新的元素，都会去初始化其 dfn[i] = low[i] = ++index, 表示以当前时间戳为根的一个强连通分量。 为什么不用dfn[i] = low[i] = i 呢，因为搜索的顺序不一定是严格递增的。时间戳的作用就是保持顺序搜索。 这里还有一个性质： 如果发现 dfn[i] != low[i], 说明以当前时间戳为根的强连通分量， 属于另一个更“早”的强连通分量。不理解的话可以先看模拟的过程 若 dfn[i] == low[i] , 说明又搜了一圈之后又搜回到当前结点，那么在这个搜索的过程中所有的元素（即栈内i节点之后进来的的所有元素） 都属于以当前时间戳为根的强连通分量。 low数组： 当前结点属于哪个“根” （ 即属于哪个强连通分量） belong数组： 表示每个点属于哪一个强连通分量。 栈： 用来标记已经走过的点 模拟第一步： 从第一个点开始搜索，最初的dfn[1] = low[1] = ++index(1)。 此时栈里的结点是1. 第二步: 接下来搜到第2个结点，同时也初始化dfn[2] = low[2] = ++index(2). 此时栈里的结点是 : 1 , 2. 第三步： 接下来搜到第3个结点，同时也初始化low[3] = low[3] = ++index(3) .此时栈里的结点是: 1, 2, 3. 然后发现没有结点可以走了，开始回溯，离开之前发现dfn[3] == low[3], 表示找了一个连通分量。 所以开始出栈，直到3结点为止，所有出栈的元素都是一个强连通分量。 所以3结点自己就是一个强连通分量。 此时栈里的结点是： 1， 2. 第四步： 从3结点离开后，回到2结点，然后搜到4结点。初始化dfn[4] = low[4] = ++index(4), 此时栈里的结点是: 1, 2 , 4. 接着继续搜，搜到1结点，但发现1结点已经被搜过了（在栈里），此时要做的就是更新 low[4] = dfn[1]. 说明4结点属于 以 1结点的时间戳 为根的强连通分量。 此时栈里的元素是： 1, 2, 4. 第五步: 继续搜3结点，发现3结点以前搜过(dfn[3] != 0, 表示以前搜过)，所以不去管它。 第六步： 搜完3发现没有结点可搜了，所以要回溯，但离开4之前要判断 dfn[4] == low[4] ? 发现并不相等，说明这个强连通分量中还有其它点，所以不用管。 回到2之后，因为没结点可搜，继续回溯，离开2之前要判断 dfn[2] == low[2] ? 发现并不相等，所以不用管。 回到1之后，开始搜5结点， 更新 dfn[5] = low[5] = ++index(5)， 此时栈里元素是： 1, 2, 4, 5. 然后继续搜6结点，更新 dfn[6] = low[6] = ++index(6), 此时栈里元素是： 1, 2, 4, 5, 6. 第七步： 搜4结点，发现它搜过（在栈里），所以此时更新 low[6] = dfn[4]. 继续搜其它儿子。 第八步： 发现6结点没有其它儿子了，所以回溯到5结点，离开6之前判断 dfn[6] == low[6] ? 不等，不管。 回到5之后，要更新 low[5] = low[6]. 这里要注意！容易忘记！ 继续搜其它儿子。 第九步： 搜到7结点，更新 dfn[7] = low[7] = ++index(7), 此时栈里结点是： 1, 2, 4, 5, 6, 7. 然后继续搜8结点，更新 dfn[8] = low[8] = ++index(8), 此时栈里结点是: 1, 2, 4, 5, 6, 7, 8. 然后继续搜，发现5结点之前搜过（在栈里),所以更新 low[8] = dfn[5]. 第十步： 然后继续搜9， 更新 dfn[9] = low[9] = ++index(9), 此时栈里结点是： 1, 2, 4, 5, 6, 7, 8, 9. 发现9没有儿子，所以要回溯，离开之前发现 dfn[9] == low[9], 所以开始出栈，直到9结点。 所有出栈元素构成一个强连通分量。 故9结点单独是个强连通分量。 第十一步： 回溯到8，此时 low[8] &lt; dfn[8], 不用管，继续回退。 第十二步： 回溯到7，此时 low[7] &lt; dfn[7], 不用管，继续回退。 第十三步： 回溯到5，此时 low[5] &lt; dfn[5], 不用管，继续回退。 第十四步： 回溯到1， 此时 low[1] == dfn[1], 开始出栈， 直到1结点。 发现所有的元素都出栈了，即(1, 2, 4, 5, 6, 7, 8) 构成了一个强连通分量。 故原图中共有三个强连通分量。 结束 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;int&gt; G[maxn]; //存图int scc; //强连通分量的数量int idx; // 时间戳int top; // 栈顶bool instack[maxn];int dfn[maxn],low[maxn],belong[maxn],Stack[maxn];// int num[maxn]; // 每个强连通分量的数量。 1 ~ scc// int maps[maxn]; //缩点之后 每个点对应的新点的标号void Tarjan(int u)&#123; dfn[u] = low[u] = ++idx; instack[u] = true; Stack[top++] = u; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!dfn[v])&#123; Tarjan(v); low[u] = min(low[u],low[v]); &#125; else if(instack[v]) low[u] = min(low[u],dfn[v]); &#125; if(dfn[u] == low[u])&#123; ++scc; int cnt = 0; int now; while(top &gt; 0)&#123; now = Stack[--top]; instack[now] = false; belong[now] = u; ++cnt; if(now == u)&#123; // num[scc] = cnt; // maps[u] = scc; break; &#125; &#125; &#125;&#125;void solve(int n)&#123; memset(instack,0,sizeof(instack)); memset(dfn,0,sizeof(dfn)); scc = idx = top = 0; for(int i=1;i&lt;=n;i++)&#123; // 点的标号从1开始 if(!dfn[i]) Tarjan(i); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>强联通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图最大权完美匹配]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[二分图最大权完美匹配思想 根据 大牛博客 改编 注意前提是二分图存在完美匹配 核心思想： 调整思想 讲算法之前先问个问题： 如果你要结婚，你会选择你爱的还是爱你的？（请各位直男以girl的角度回答） 相信大部分人的回答都是找一个爱自己多一点的。至于为什么…爱过你就知道了。 那么问题来了，我们如何高效的找出一种匹配方法，使得每个女孩都能尽可能的被爱自己更多的人在一起？ 如图，每条红线表示男生对女生的喜欢程度。 女生左边的数字是她们心里的期望。（即男生对她最大的喜欢程度） 男生右边的数字是他们的自我膨胀指数（后面会解释）。 问题搞清楚了，那么怎么找呢？ 首先，要理解这个算法，必须先明白几个道理： （如果你是从二分图匹配看下来的，那么你会发现接下来的男女和讲二分图匹配的时候顺序反了过了。只是因为网上的图是这么给的，所以就这么讲了。（其实是因为我有一颗男女平等的心）） 女生都有一颗不过分的舍己为人的心 （同二分图最大匹配） 女生在选男朋友的时候，只要这个男朋友满足她心里的期望，她就会选择他。 原因是：女生不傻，她的期望一定是在可满足范围内最高的，即总会存在至少一个男生满足她的心理期望。 男生也是人，也有自尊。 如果现在只有林俊杰和我同时喜欢徐佳莹，但是我对徐佳莹的喜欢有5分，林俊杰对她的喜欢只有3分。那么徐佳莹的心理期望肯定是5分，肯定也会选我作为她的男盆友 (๑•̀ㅂ•́)و✧ 徐佳莹选完之后，张碧晨开始选。她发现所有男生里只有我喜欢她，所以她不得不选我。但是因为我之前被徐佳莹选走了，抱着一颗舍己为人的心，徐佳莹只能重新选择林俊杰。所以徐佳莹的心理期望必须要由5降到3。那我就开始膨胀了，毕竟现在我是抢手货了，我的膨胀指数就会相应的增加2（后面有解释）。（可把我牛逼坏了，叉会腰&lt;(￣︶￣)&gt;)。我一膨胀，那么碧晨的期望值就要下降（毕竟哥哥我现在是抢手货，肯定不能像以前一样宠着她了），那么她的心理期望就应该成为： 我原来对她的喜欢程度 - 我的膨胀指数。 为什么增加2 ：可以从两个方面理解 一： 本来我对徐佳莹需要五分的喜欢，她才会选我。现在她的期望变成了三，所以只要三分就可以了。我就会觉得我的个人魅力（膨胀指数）提高了两分。（应该蛮好理解的吧，如果还是不理解…先去谈恋爱吧） 二： 参考接下来的第4条。 那么现在我们可以知道女生选择男朋友的条件实际上是： 心理期望 == 该男生对她原本的喜欢程度 - 该男生的膨胀指数 算法的原理其实和二分图最大匹配的原理差不多，只不过多出来了期望值和自我膨胀指数这两个东西。所以在每次无法成功找到匹配的时候都要相应的去减少女生的期望和增加男生的膨胀指数，然后再重新匹配，直到匹配成功为止，因为图本身就是完全图，所以一定会有解。 需要注意的是，为了保证所求的结果是最大的。 我们在女生降低期望时希望降低的尽可能小，于是这里用一个slack数组维护： 当一个女生需要重新选择时，她所需要降低的最小期望值。 同时，这个值也是男生所增加的膨胀值。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 复杂度 O(nx * nx * ny)// x - girl , y - boy// lx - 心理期望 ly - 膨胀指数// slack - 女生心理期望降低的最小程度 或 男生膨胀指数增加的最小程度int nx,ny;int G[maxn][maxn];int linker[maxn],lx[maxn],ly[maxn];int slack[maxn];bool visx[maxn],visy[maxn];void addedge(int i,int k,int w)&#123; G[i][k] = w;&#125;bool dfs(int x) &#123; visx[x] = true; for (int y = 0; y &lt; ny; y++) &#123; if (visy[y]) continue; int temp = lx[x] + ly[y] - G[x][y]; //心理期望与男生实际喜欢自己程度的差值 if (temp == 0) &#123; // 该男生满足心理期望 visy[y] = true; if (linker[y] == -1 || dfs(linker[y])) &#123; linker[y] = x; return true; &#125; &#125; else if (slack[y] &gt; temp) //不满足心理期望，记录女生需要降低多少心理期望 slack[y] = temp; &#125; return false;&#125;int KM() &#123; memset(linker, -1, sizeof(linker)); memset(ly, 0, sizeof(ly)); //一开始男生一点都不膨胀 for (int i = 0; i &lt; nx; i++) &#123; lx[i] = NINF; for (int k = 0; k &lt; ny; k++) &#123; if (G[i][k] &gt; lx[i]) &#123; lx[i] = G[i][k]; &#125; &#125; &#125; for (int x = 0; x &lt; nx; x++) &#123; for (int i = 0; i &lt; ny; i++) slack[i] = INF; while (true) &#123; memset(visx, 0, sizeof(visx)); memset(visy, 0, sizeof(visy)); if (dfs(x)) break; // 如果x女生匹配成功则退出 int d = INF; for (int i = 0; i &lt; ny; i++) &#123; if (!visy[i] &amp;&amp; d &gt; slack[i]) d = slack[i]; // 记录x女生需要降低的最小期望值 &#125; for (int i = 0; i &lt; nx; i++) &#123; if (visx[i]) lx[i] -= d; &#125; for (int i = 0; i &lt; ny; i++) &#123; if (visy[i]) ly[i] += d; //女生期望降低对应着某些男性的膨胀 else slack[i] -= d; //因为女生的心理期望降低了，所以该女生和其它备胎之间的差值也会缩小 &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; ny; i++) &#123; if (linker[i] != -1) res += G[linker[i]][i]; &#125; return res;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[二分图最大匹配思想大牛博客 另一个大牛博客 本节内容根据上述资料改编而来。 核心思想： 调整思想 假设我们现在身处相亲大会，每个女孩都有几个心仪的男孩，每个男孩也都有几个心仪的女孩。 （如果这里出现了同性恋，那么就不是二分图了…） 那么我们最多可以撮合几对呢？ 这就是二分图最大匹配问题。 如图，每一条红线表示互相有好感。（单相思是不可能的，谁愿意将就呢对吧） 它的最大匹配是 清楚了问题，接下来就要解决如何求的问题。 这个算法的思想核心就是 ： 男生都有一颗（不过分的）舍己为人的心。 比如现在我先选择了徐佳莹，接下来下一个boy也选择了徐佳莹。这时候即使我再怎么喜欢徐佳莹，因为我舍己为人的心，我也要把徐佳莹让出来。然后我重新选择了张碧晨，但是我发现在我之前已经有boy选了张碧晨。这时候同样的，他也会忍痛割爱把碧晨让给我，然后他再去选择其它女生。 当然了，如果我只喜欢徐佳莹，而对其它女生没有兴趣。那么当下个boy选择徐佳莹的时候我是不会拱手送人的。这就是所谓的不过分，自己都没有对象了，就不要管别人了。 具体的实现使用递归的方法： 如果我选了徐佳莹，但是徐佳莹被林俊杰选了，那么继续去递归林俊杰，看看他是否能选别人。如果不行的话，我再换一个选。 接下来给出了两种实现方式，邻接表和邻接矩阵。 这里有个小小的说明 为什么邻接矩阵用girl而邻接表里用linker？ 因为邻接表里linker[u] == v，说明u和v匹配，那么同样的linker[v] == u. 这样可以快速查询某人的配偶是谁。 模板123456789101112131415161718192021222324252627282930313233// 邻接矩阵// 复杂度 O(nx * ny)// 点的编号 boy: 0 ~ n-1. girl: 0 ~ m-1. 只建单向边bool vis[maxn];int G[maxn][maxn],girl[maxn];int n; // boy 数量int m; // girl 数量void addedge(int u,int v)&#123; G[u][v] = 1; // boy -&gt; girl&#125;bool find(int x) &#123; for (int i = 0; i &lt; m; i++) &#123; if (G[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (girl[i] == -1 || find(girl[i])) &#123; girl[i] = x; return true; &#125; &#125; &#125; return false;&#125;int hungary() &#123; int ret = 0; memset(girl, -1, sizeof(girl)); for (int i = 0; i &lt; n; i++) &#123; memset(vis, 0, sizeof(vis)); if (find(i)) ret++; &#125; return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 邻接表// 复杂度 O(V * E)// 注意点的编号。 boy : 0 ~ n-1. girl: n ~ n+m-1.bool vis[maxn];vector&lt;int&gt; G[maxn];int linker[maxn];void init(int n) &#123; // 这里n为总人数 for (int i = 0; i &lt;= n; i++) G[i].clear();&#125;void addedge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u);&#125;bool find(int u) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; int vv = linker[v]; if (vv &lt; 0 || !vis[vv] &amp;&amp; find(vv)) &#123; linker[v] = u; linker[u] = v; return true; &#125; &#125; return false;&#125;int hungary(int n) &#123; // n 为boy的数量（如果已知boy数量） 或 总人数 int ret = 0; memset(linker, -1, sizeof(linker)); for (int i = 0; i &lt; n; i++) &#123; if (linker[i] &lt; 0) &#123; memset(vis, 0, sizeof(vis)); if (find(i)) ret++; &#125; &#125; return ret;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[二分图二分图定义二分图的几种定义 ： 不含奇环的图 用两种颜色给每个顶点染色，可以保证相邻的顶点颜色不同 可以分成两堆，所有的边都是从一堆连到另一堆的 二分图判定判定方法 ： 染色法 12345678910111213141516171819202122232425vector&lt;int&gt; G[maxn];int color[maxn];// 把顶点染成1或-1bool dfs(int u,int c)&#123; color[u] = c; //把u点染成颜色c for(auto v : G[u])&#123; if(color[v] == c) return false; if(color[v] == 0 &amp;&amp; !dfs(v,-c)) return false; &#125; return true;&#125;void solve(int n)&#123; memset(color,0,sizeof(color)); for(int i=0;i&lt;n;i++)&#123; if(color[i] == 0)&#123; if(!dfs(i,1))&#123; cout &lt;&lt; "No" &lt;&lt; '\n'; return ; &#125; &#125; &#125; cout &lt;&lt; "Yes" &lt;&lt; '\n';&#125; 二分图上最大匹配和最小点覆盖的关系最大匹配数 = 最小点覆盖数 证明： 采用反证法。 首先，最小点覆盖的数量一定大于等于最大匹配数。若现在有一条边没有被覆盖，这与最大匹配数相矛盾。得证。 与最小边覆盖的关系最小边覆盖数 = 顶点数 - 最大匹配数 证明： 设最大匹配数为n，顶点数为V。 我们可以先选n条边，这样只剩 $V - 2\times n$ 个点了。 接下来只能一条边搞一个点，所以还需要 $V - 2\times n$条边。 于是，最小边覆盖数 $= V - 2\times n + n = V - n$ 与最大独立集的关系独立集：给定图$G=(V,E)$,$V’$ 是$V$的一个非空子集。若$V’$的任何两个顶点$u,v$都不是同一条边的两个端点，则称$V’$是$G$的一个空子图。设$V’$是G的空子图，若$V’$任意增加一个$G$中不在$V’$中的点后都不是空子图，则称$V’$是$G$的独立集。$G$中所含顶点数最多的独立集$V’$称为$G$的最大独立集。 最大独立集中的顶点数 = 最小边覆盖数 = 总顶点数 - 最大匹配数(最小顶点覆盖) 总顶点数再去最小顶点覆盖数就是孤立点的数目。这些点相互之间都没有边。 与最小支配集的关系支配集：设$G=(V,E)$是无向简单图，$S$是$V$的一个非空子集。若对于不在$S$中的$G$的点$u$，$u$与$S$里至少一个顶点$v$相关联，则称$S$是图$G$的支配集。设$S$是图$G$的支配集，若$S$的任何真子集都不是$G$的支配集，则称$S$为图$G$的极小支配集。$G$中含顶点数最少的支配集$S$，称为$G$的最小支配集，其顶点个数$|S|$称为图$G$的支配数。 设$G$是无孤立顶点的图，则$G$的极大独立集必为极小支配集，其逆不真。]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829struct Mat&#123; ll m[maxn][maxn];&#125;;Mat operator * (Mat a, Mat b)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i=0;i&lt;n;i++)&#123; for(int k=0;k&lt;n;k++)&#123; if(a.m[k][i] == 0) continue; for(int p=0;p&lt;n;p++)&#123; if(b.m[i][p] == 0) continue; c.m[k][p] = (c.m[k][p] + a.m[k][i] * b.m[i][p] % mod ) % mod; &#125; &#125; &#125; return c;&#125;Mat operator ^ (Mat a,int x)&#123; Mat c; for(int i=0;i&lt;n;i++) for(int k=0;k&lt;n;k++) c.m[i][k] = (i == k); for(; x ; x &gt;&gt;= 1)&#123; if(x &amp; 1) c = c * a; a = a * a; &#125; return c;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[一次不定方程设整数$k \geq 2$,$c,a_1…a_k$是整数，且$a_1…a_k$都不等于零，以及$x_1…x_k$是整数变数，方程$$a_1x_1 + … + a_kx_k = c \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)$$ 称为k元一次不定方程,$a_1….a_k$称为它的系数. (1)有解的充要条件: $gcd(a_1..a_k) | c$ 设二元一次不定方程$$a_1x_1 + a_2x_2 = c\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2)$$ 有解，$x_{1,0},x_{2,0}$是它的一组解，那么它的所有解为 $$\begin{cases} x_1 = x_{1,0} + \frac{a_2}{(a_1,a_2)}\times t\\ {x_2 = x_{2,0} - \frac{a_1}{(a_1,a_2)}\times t} \end{cases}$$ $t = 0,\pm1,\pm2….$ 其中$(a_1,a_2)$ 表示二者的最大公约数 $$\begin{cases} a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1 \\ &amp;&amp;&amp;&amp;\vdots\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp; \end{cases}$$ 扩展欧几里得算法对于$ax + by = c$ exgcd会先算$ax + by = 1$ 得到的一组解$x_1,y_1$要再乘$c$才是最后的答案。 47x - 30y = 1与47x + 30y = 1之间有没有差别呢？ 其实是没有的，实际手算过程是是不考虑负号的，最后结束的时候才会考虑。所以在传递参数的时候只要传递47和30即可(不能传递47和-30！！)，然后再去直接改变x和y的符号. 手算模拟： 47 = 30*1 + 17 30 = 17*1 + 13 17 = 13*1 + 4 4 = 4*1 17 = 47 - 30*1 13 = 30 - 17*1 4 = 17 - 13*1 1 = 13 - 4*3 1 = 13 - (17 - 131)3 = 47(-7) + 3011 x = -7 y = 11 模板12345678910111213141516171819202122232425262728// ax + by = 1ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if((b == 0) &amp;&amp; (a == 0)) return -1; //无最大公因数 if(b == 0)&#123; x = 1; y = 0; return a; &#125; else&#123; ll d = ex_gcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int main()&#123; ll a,b,c; // ax + by = c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; ll x,y; ll d = ex_gcd(a,b,x,y); // 返回gcd(a,b) if(c % d != 0) cout &lt;&lt; "无解" &lt;&lt; endl; else&#123; // x = (x % (b/d) + b/d) % (b/d) //取最大非负整数 // y = (1 - a*x) / b; x *= c; y *= c; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>扩展欧几里得</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树思想线段树是一棵二叉树，用来维护区间信息。 树的叶子用来记录结点信息，其父亲记录所有儿子(子区间)的信息。 根节点记录的就是整个区间的信息。 通过pushup的操作，将底层信息向根结点进行反馈。 通过pushdown的操作，将标记下放。 区间合并: 对于区间合并。 我们需要维护三个值： 最长连续子区间 - mx 包含左端点的最长连续子区间 - lmx 包含右端点的最长连续子区间 - rmx 那么对mx的更新，它的可能值有三个： 左儿子的mx 右儿子的mx 左儿子的mmx + 右儿子的lmx 对于lmx的更新： 左儿子的lmx 如果左儿子的lmx值为 左儿子区间长度(lson_len) 的话，那么还要加上右儿子的lmx 对于rmx的更新： 右儿子的rmx 如果右儿子的rmx值为 右儿子的区间长度(rson_len) 的话，那么还要加上左儿子的rmx 证明： 模板1234567// 左闭右闭#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)const int maxn = "Edit";int seg[maxn &lt;&lt; 2]; 单点更新，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 左闭右闭 [l,r]void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] = num[l]; // cin &gt;&gt; seg[rt]; //建立的时候直接输入叶节点 return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int p, int add, int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] += add; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, add,l,m,lson); else update(p, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; // L R 是要查询的区间 if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) s += query(L, R, l,m,lson); if (m &lt; R) s += query(L, R, m+1,r,rson); return ret;&#125;// update interval// lazy[rt]用于存放懒惰标记，注意PushDown时标记的传递const int maxn = "Edit";int lazy[maxn &lt;&lt; 2], seg[maxn &lt;&lt; 2];void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void pushdown(int rt, int len) &#123; if (lazy[rt] == 0) return; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; seg[lson] += lazy[rt] * lson_len; seg[rson] += lazy[rt] * rson_len; lazy[rt] = 0;&#125;void build(int l, int r, int rt) &#123; lazy[rt] = 0; if (l == r) &#123; seg[rt] = num[l]; //cin &gt;&gt; seg[rt]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int L, int R, int add, int l, int r, int rt) &#123; // L R 是要更新的区间 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; lazy[rt] += add; seg[rt] += add * (r - l + 1); return; &#125; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, add, l,m,lson); if (m &lt; R) update(L, R, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) ret += query(L, R, l,m,lson); if (m &lt; R) ret += query(L, R, m+1,r,rson); return ret;&#125;// interval mergestruct Seg&#123; int mx,lmx,rmx;&#125;;void pushup(int rt,int len)&#123; seg[rt].mx = max(seg[lson].mx, max(seg[rson].mx, seg[lson].rmx + seg[rson].lmx)); seg[rt].lmx = seg[lson].lmx; seg[rt].rmx = seg[rson].rmx; if(seg[rt].lmx == lson_len) seg[rt].lmx += seg[rson].lmx; if(seg[rt].rmx == rson_len) seg[rt].rmx += seg[lson].rmx;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[单调栈模板12345678910111213141516171819202122232425int L[maxn], R[maxn];int a[maxn];// 找到左边第一个大于它的元素位置l，和右边第一个大于它的元素位置r // [l,r]void init(int n) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; n; i++) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) L[i] = 0; else L[i] = st.top() + 1; st.push(i); &#125; while (!st.empty()) st.pop(); for (int i = n - 1; i &gt;= 0; i--) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) R[i] = n-1; else R[i] = st.top() - 1; st.push(i); &#125;&#125; 练习题poj2559 最大公共矩形题意 给定若干小矩形的高度（默认宽度都为1），求出最大公共矩形。 分析我们想知道每个矩形向右能扩展多大和向左能扩展多大。枚举当然可以，这里介绍一种复杂度更低的做法，单调栈。从左向右遍历。保持栈里元素单调递增。对于每个pop出来的矩形，可以得到它所对应的左右扩展的位置。具体可以看代码 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;ll ans;int n;ll num[100005];void solve()&#123; stack&lt;pair&lt;int, ll &gt; &gt; st; for(int i= 0 ; i &lt; n; i++)&#123; int pos = i; //记录向左可扩展到的位置 while(st.size() &amp;&amp; num[i] &lt; st.top().second)&#123; pair&lt;int,ll&gt; temp = st.top(); pos = temp.first; st.pop(); ans = max(ans,(i - temp.first)*temp.second); &#125; st.push(make_pair(pos,num[i])); &#125; while(st.size())&#123; //若栈不为空，则继续pop pair&lt;int,ll&gt; temp = st.top(); st.pop(); ans = max(ans, (n - temp.first)*temp.second); &#125;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF)&#123; if(!n) break; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;num[i]); &#125; ans = -1000000; solve(); printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>单调栈</category>
      </categories>
  </entry>
</search>
